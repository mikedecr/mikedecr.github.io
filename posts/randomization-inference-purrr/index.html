<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Purrrmutation Testing | Michael DeCrescenzo</title>
  <meta name="description" content="[SITE UNDER CONSTRUCTION.] I am a statistical researcher working in quantitative/high-frequency finance. This site contains some info about me, some notes about my work, and blog posts about stats and statistical programming.">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="Purrrmutation Testing" />
<meta property="og:description" content="Randomization Inference within the Tidyverse" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/randomization-inference-purrr/" />
<meta property="article:published_time" content="2020-03-10T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-03-10T00:00:00+00:00" />

  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Purrrmutation Testing"/>
<meta name="twitter:description" content="Randomization Inference within the Tidyverse"/>

  
  
    
  
  
  <link rel="stylesheet" href="/css/style-classic.css">
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="/images/favicon.ico" />

  
  
  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

  <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
        <li><a href="/">Home</a></li>
         
        <li><a href="/about">About</a></li>
         
        <li><a href="/posts">Blog</a></li>
         
        <li><a href="/research">Public Research</a></li>
         
        <li><a href="/teaching">Teaching Resources</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li>
          <a class="icon" href=" /teaching/ps-811/">
            <i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i>
          </a>
        </li>
        
        
        <li>
          <a class="icon" href="/posts/visualizing-what-matters/">
            <i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i>
          </a>
        </li>
        
        <li>
          <a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');">
            <i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i>
          </a>
        </li>
        <li>
          <a class="icon" href="#">
            <i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i>
          </a>
        </li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      
      <ul>
  
  
    
  
  
  <li>
    <a class="icon" href="http://www.facebook.com/sharer.php?u=%2fposts%2frandomization-inference-purrr%2f">
      <i class="fab fa-facebook " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://twitter.com/share?url=%2fposts%2frandomization-inference-purrr%2f&text=Purrrmutation%20Testing">
      <i class="fab fa-twitter " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.linkedin.com/shareArticle?url=%2fposts%2frandomization-inference-purrr%2f&title=Purrrmutation%20Testing">
      <i class="fab fa-linkedin " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=%2fposts%2frandomization-inference-purrr%2f&is_video=false&description=Purrrmutation%20Testing">
      <i class="fab fa-pinterest " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="mailto:?subject=Purrrmutation%20Testing&body=Check out this article: %2fposts%2frandomization-inference-purrr%2f">
      <i class="fas fa-envelope " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://getpocket.com/save?url=%2fposts%2frandomization-inference-purrr%2f&title=Purrrmutation%20Testing">
      <i class="fab fa-get-pocket " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://reddit.com/submit?url=%2fposts%2frandomization-inference-purrr%2f&title=Purrrmutation%20Testing">
      <i class="fab fa-reddit " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.stumbleupon.com/submit?url=%2fposts%2frandomization-inference-purrr%2f&title=Purrrmutation%20Testing">
      <i class="fab fa-stumbleupon " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://digg.com/submit?url=%2fposts%2frandomization-inference-purrr%2f&title=Purrrmutation%20Testing">
      <i class="fab fa-digg " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.tumblr.com/share/link?url=%2fposts%2frandomization-inference-purrr%2f&name=Purrrmutation%20Testing&description=Randomization%20Inference%20within%20the%20Tidyverse">
      <i class="fab fa-tumblr " aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://news.ycombinator.com/submitlink?u=%2fposts%2frandomization-inference-purrr%2f&t=Purrrmutation%20Testing">
      <i class="fab fa-hacker-news " aria-hidden="true"></i>
    </a>
  </li>
</ul>

    </div>
    <div id="toc">
      
    </div>
  </span>
</div>


  <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
    <header>
      <h1 class="posttitle" itemprop="name headline">
        Purrrmutation Testing
      </h1>
      <div class="meta">
        
        <div class="postdate">
          
          <time datetime="2020-03-10 00:00:00 &#43;0000 UTC" itemprop="datePublished">2020-03-10</time>
          
        </div>
        
        <div class="article-category">
            <i class="fas fa-archive"></i>
            
            
            <a class="category-link" href="/categories/methods">Methods</a>
            
        </div>
        
        
        <div class="article-tag">
            <i class="fas fa-tag"></i>
            
            
            <a class="tag-link" href="/tags/causal-inference" rel="tag">Causal Inference</a>
            
             ,  
            <a class="tag-link" href="/tags/computational-methods" rel="tag">Computational Methods</a>
            
        </div>
        
      </div>
    </header>

  
    <div class="content" itemprop="articleBody">
      
<link href="/rmarkdown-libs/anchor-sections/anchor-sections.css" rel="stylesheet" />
<script src="/rmarkdown-libs/anchor-sections/anchor-sections.js"></script>


<div id="overview" class="section level2">
<h2>Overview</h2>
<p>Permutation testing (or “randomization inference,” RI) is an approach to statistical inference based on hypothetical allocations of treatment rather than sampling error. It has an appealing intuition, but researchers may feel intimidated by the prospect of implementing it computationally. Although helpful packages exist for conducting permutation tests in R,<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>
my goal for this post is to show that <code>tidyverse</code> tools (in particular, functional programming with <code>purrr</code>) make it easy to implement randomization inference in R flexibly and efficiently.</p>
<p>Below I provide a brief overview of RI’s logic, implement a simple permutation test for a single treatment, and then demonstrate how to incorporate additional design features such as blocking or clustered randomization into the workflow. We will see that many of these design features are easily translated into <code>tidyverse</code> dialect without warping or overextending the workflow into something unrecognizable or impractical.</p>
</div>
<div id="what-is-randomization-inference" class="section level2">
<h2>What is Randomization Inference</h2>
<p>Randomization inference is a method for conducting statistical hypothesis tests without making distributional assumptions about test statistics. Like all null hypothesis tests, it is a comparison between (1) an estimated effect or relationship from observed data and (2) a “null distribution” of estimates that we might have observed if the null hypothesis were true. Unlike traditional null hypothesis tests, however, the null distribution is not based on repeated sampling of a hypothetical population. Instead, it is constructed by imagining <em>other ways that treatment may have been randomly allocated</em> among units.</p>
<p>For instance, suppose we had some small sample of data for <span class="math inline">\(n = 6\)</span> units. We randomly assign half of the units to treatment and half to control:</p>
<!-- centering this table -->
<center>
<table style="width:40%;">
<colgroup>
<col width="6%" />
<col width="16%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">ID</th>
<th align="center">Treatment</th>
<th align="center">Outcome</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center">0</td>
<td align="center"><span class="math inline">\(Y_1\)</span></td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center">0</td>
<td align="center"><span class="math inline">\(Y_2\)</span></td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center">1</td>
<td align="center"><span class="math inline">\(Y_3\)</span></td>
</tr>
<tr class="even">
<td align="center">4</td>
<td align="center">1</td>
<td align="center"><span class="math inline">\(Y_4\)</span></td>
</tr>
<tr class="odd">
<td align="center">5</td>
<td align="center">1</td>
<td align="center"><span class="math inline">\(Y_5\)</span></td>
</tr>
<tr class="even">
<td align="center">6</td>
<td align="center">0</td>
<td align="center"><span class="math inline">\(Y_6\)</span></td>
</tr>
</tbody>
</table>
</center>
<p>We could use this data to calculate some difference in means <span class="math inline">\(\hat{\delta} = \bar{Y}_{1} - \bar{Y}_{0}\)</span>. How do we form an inference about <span class="math inline">\(\delta\)</span> from <span class="math inline">\(\hat{\delta}\)</span>? Typically we would standardize <span class="math inline">\(\hat{\delta}\)</span> and compare it against a <span class="math inline">\(t\)</span>-distribution, finding a <span class="math inline">\(p\)</span>-value that represents “the probability of obtaining some other <span class="math inline">\(\hat{\delta}&#39;\)</span> at least as extreme as <span class="math inline">\(\hat{\delta}\)</span>, under the null hypothesis that the true <span class="math inline">\(\delta\)</span> is zero.” Under this approach, this <span class="math inline">\(t\)</span>-distribution serves as our “null distribution,” the sampling distribution of estimates that we would obtain assuming that the null is true.</p>
<p>Randomization inference constructs this null distribution using a different method. Instead of making the parametric assumption that the standardized <span class="math inline">\(\hat{\delta}\)</span> follows a <span class="math inline">\(t\)</span> distribution, we take advantage of random assignment in the research design, constructing a null distribution of treatment effect estimates by <em>repeatedly permuting the treatment assignments</em> for our units. For example, the treatment vector in the small sample of data above was <span class="math inline">\(\mathbf{T} = \left[0, 0, 1, 1, 1, 0\right]\)</span>, but we could have obtained a different treatment vector by random chance alone. We could have randomly realized treatment assignments as <span class="math inline">\(\mathbf{T}&#39; = \left[0, 0, 1, 0, 1, 1\right]\)</span>, or <span class="math inline">\(\mathbf{T}&#39; = \left[1, 1, 1, 0, 0, 0\right]\)</span>. Imagine that in each of these alternate treatment assignments, we estimate the treatment effect <span class="math inline">\(\hat{\delta}\)</span>. Under the null hypothesis, outcomes are not affected (on average) by treatment assignment, so each <span class="math inline">\(\hat{\delta}\)</span> that we estimate under the permuted treatment assignments a draw from the “null distribution” of <span class="math inline">\(\hat{\delta}\)</span>. If we could specify every possible treatment assignment, we would have a full accounting of every equally-likely null <span class="math inline">\(\hat{\delta}\)</span> estimate under the research design. This would let us calculate an “exact” <span class="math inline">\(p\)</span>-value by comparing our in-sample estimate to the null distribution: the proportion of null estimates that are more extreme than the estimate obtained in our real data. These <span class="math inline">\(p\)</span>-values are valid even in nonrandom samples because they operate by <em>design uncertainty</em> instead of sampling uncertainty.</p>
<p>More formally, suppose that random variable <span class="math inline">\(S\)</span> is a test statistic that is a function of <span class="math inline">\(\mathbf{T}\)</span> and <span class="math inline">\(\mathbf{Y}\)</span>, vectors of treatment assignments and outcome data respectively (<a href="https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.1540-5907.2011.00576.x?casa_token=YjkCBZcxieAAAAAA:-WVWyv9NfA_83dsFCKLYjofLTVBEKehe0cG3a3na-7OQhSQrURDVGsjgeKwHSv6KI5jrXpmNV5Bog9A">Keele, McConnaughy, and White</a>). A <span class="math inline">\(p\)</span>-value is the probability that <span class="math inline">\(S\)</span> exceeds the test statistic calculated from your data, <span class="math inline">\(s^{*}\)</span>, given the null distribution of <span class="math inline">\(S\)</span>.
<span class="math display" id="eq:test-stat">\[\begin{align}
  p &amp;= \mathrm{Pr}\left(S ≥ s^{*} | H_{0}\right) %_
  \tag{1}
\end{align}\]</span>
A permutation test finds this <span class="math inline">\(p\)</span>-value by calculating the test statistic for your sample of data, <span class="math inline">\(s^{*}\)</span>, as well as test statistics <span class="math inline">\(s_{m}\)</span> for <span class="math inline">\(m \in \mathcal{M}\)</span>, treatment permutations from the set of possible treatment permutations. The <span class="math inline">\(p\)</span>-value in the permutation test is the proportion of permuted test statistics that exceed the in-sample test statistic.
<span class="math display" id="eq:permute-p">\[\begin{align}
  p &amp;= \frac{\sum\limits_{m = 1}^{M} I(s_{m} &gt; s^{*})}{M}
  \tag{2}
\end{align}\]</span>
where <span class="math inline">\(I(\cdot)\)</span> is the indicator function and <span class="math inline">\(M\)</span> is the number of permutations being considered. If <span class="math inline">\(M\)</span> is equal to the total number of possible permutations, this <span class="math inline">\(p\)</span>-value is exact. If the set of permutations <span class="math inline">\(\mathcal{M}\)</span> is too large to calculate every <span class="math inline">\(s_{m}\)</span> (which is likely for even moderate samples sizes), sampling a subset of <span class="math inline">\(M &lt; |\mathcal{M}|\)</span> permutations lets you treat Equation <a href="#eq:permute-p">(2)</a> as an approximation of the <span class="math inline">\(p\)</span>-value.</p>
<p><strong><em>TLDR</em></strong>, how do we perform randomization inference?</p>
<ol style="list-style-type: decimal">
<li>Estimate the treatment effect in our sample</li>
<li>Compute or approximate the null distribution of the treatment effect estimate under repeated reallocations of treatment to units (conditional on the sample)</li>
<li>Compare the in-sample estimate to its null distribution</li>
</ol>
</div>
<div id="randomization-inference-for-a-simple-experiment" class="section level2">
<h2>Randomization Inference for a Simple Experiment</h2>
<p>This section shows how to implement permutation tests for a simple experiment with a binary treatment and binary outcome. First I describe the model used to generate data, and then we perform a permutation test using the generated data.</p>
<div id="data" class="section level3">
<h3>Data</h3>
<p>We will use various tools in the <code>tidyverse</code>, so for now that is the only package we will load.</p>
<pre class="r"><code>library(&quot;tidyverse&quot;)</code></pre>
<p>I simulate a dataset of <span class="math inline">\(n = 500\)</span> units with outcome variable <span class="math inline">\(y_{i} \in \left\{0, 1\right\}\)</span>, treatment status <span class="math inline">\(z_{i} \in \left\{0, 1\right\}\)</span>, treatment probability <span class="math inline">\(0.5\)</span>. The generative model can be represented as follows:
<span class="math display">\[\begin{align}
  y_{i} &amp;\sim \mathrm{Bernoulli}\left(0.5 + \delta z_{i}\right) \\
  z_{i} &amp;\sim \mathrm{Bernoulli}\left(0.5 \right)
\end{align}\]</span>
where the treatment effect <span class="math inline">\(\delta\)</span> has a true value of <span class="math inline">\(0.06\)</span>. In R, I generate the data like so:</p>
<pre class="r"><code>set.seed(90181)

n_obs &lt;- 500
control_mean &lt;- 0.5
treat_effect &lt;- .06

d &lt;- 
  tibble(id = 1:n_obs) %&gt;%
  mutate(
    treatment = rbernoulli(n = n(), p = 0.5) %&gt;% as.numeric(),
    y = rbernoulli(n = n(), p = control_mean + (treatment * treat_effect)) %&gt;%
        as.numeric()
  ) %&gt;%
  print()
## # A tibble: 500 x 3
##       id treatment     y
##    &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;
##  1     1         1     1
##  2     2         0     0
##  3     3         0     0
##  4     4         1     1
##  5     5         1     1
##  6     6         1     1
##  7     7         0     0
##  8     8         0     1
##  9     9         0     1
## 10    10         0     1
## # … with 490 more rows</code></pre>
<p>The data are a random draw from the generative model, so the treatment effect in the data won’t be exactly equal to the true effect. In these data, we estimate an in-sample treatment effect of about 0.05. We will want to save a data frame of in-sample estimates.</p>
<pre class="r"><code>observed_estimates &lt;- d %&gt;%
  summarize(
    mean_control = mean(y[treatment == 0]),
    mean_treatment = mean(y[treatment == 1]),
    diff_means = mean_treatment - mean_control
  ) %&gt;%
  print()
## # A tibble: 1 x 3
##   mean_control mean_treatment diff_means
##          &lt;dbl&gt;          &lt;dbl&gt;      &lt;dbl&gt;
## 1        0.514          0.563     0.0495</code></pre>
</div>
<div id="permuting-treatment-assignments-tidily" class="section level3">
<h3>Permuting treatment assignments, tidily</h3>
<p>The <code>tidyverse</code> advantage comes in when we permute the treatment assignments. Ordinarily we might think about permuting treatment assignments using a for loop—for each iteration <code>m</code> in <code>1:M</code>, reshuffle the treatment assignments and calculate <span class="math inline">\(\hat{\delta}_{\mathtt{m}}\)</span>. Except we want to avoid a for loop because…</p>
<ol style="list-style-type: decimal">
<li>For loops in R are famously slow.</li>
<li>For loops in R are rarely necessary. For many common data wrangling problems, iteration <span class="math inline">\(m\)</span> does not depend on iteration <span class="math inline">\(m-1\)</span>, so a vectorized approach is usually more efficient.</li>
<li><strong>A technical but important workflow point</strong>: the data structure that results from a loop (usually a vector or a list) often throws away useful information, and it can be <em>organizationally idiosyncratic</em> if the rest of our work is data frame-driven. If we can do this routine using a more capable data structure and extensible workflow, we have the potential to do more cool things while staying organized along the way.</li>
</ol>
<p>We deal with points (1) and (2) by using functional programming: applying a function over groups of data (see <a href="http://adv-r.had.co.nz/Functional-programming.html">here</a> for instance). In our case, a <em>group</em> will be a data frame, and the <em>function</em> is permuting the treatment assignments and estimating the treatment effect. We address point (3) by doing everything with a <em>nested data frame</em> and applying functions to groups using <code>purrr::map()</code>. I will describe the approach below one step at a time. After each step is explained, I will show how simple it is to combine them into a small, efficient block of readable code.</p>
<p>The first step is to make a nested data frame: a data frame that itself contains data frames (see e.g. <a href="https://blog.rstudio.com/2016/02/02/tidyr-0-4-0/">[1]</a>, <a href="https://r4ds.had.co.nz/many-models.html">[2]</a>, <a href="https://cran.r-project.org/web/packages/tidyr/vignettes/nest.html">[3]</a>). Here I create a data frame with two columns: an identifier <code>m</code> that indexes our treatment permutations, and a data column that contains copies of our original dataset for each <code>m</code>.</p>
<pre class="r"><code># total number of iterations
n_sims &lt;- 2000

# nested data frame of all M iterations
sim_table &lt;- d %&gt;%
  crossing(m = 1:n_sims) %&gt;%
  group_by(m) %&gt;%
  nest() %&gt;%
  print()
## # A tibble: 2,000 x 2
## # Groups:   m [2,000]
##        m data              
##    &lt;int&gt; &lt;list&gt;            
##  1     1 &lt;tibble [500 × 3]&gt;
##  2     2 &lt;tibble [500 × 3]&gt;
##  3     3 &lt;tibble [500 × 3]&gt;
##  4     4 &lt;tibble [500 × 3]&gt;
##  5     5 &lt;tibble [500 × 3]&gt;
##  6     6 &lt;tibble [500 × 3]&gt;
##  7     7 &lt;tibble [500 × 3]&gt;
##  8     8 &lt;tibble [500 × 3]&gt;
##  9     9 &lt;tibble [500 × 3]&gt;
## 10    10 &lt;tibble [500 × 3]&gt;
## # … with 1,990 more rows</code></pre>
<p>The <code>data</code> column is a <em>list column</em>, in this case a list of data frames for each row <code>m</code> (but it could contain other object types if we wanted). List columns are powerful for large-scale data manipulation because we can apply functions over each element in the list, similar to the way <code>apply()</code> functions work in base R. In our case, we want to apply a function that permutes the values in the <code>treatment</code> variable. We map this function over the nested data using <code>purrr::map()</code>, creating a new list column of data frames.</p>
<pre class="r"><code>perm_table &lt;- sim_table %&gt;%
  mutate(
    permuted_data = map(
      .x = data, 
      .f = mutate, 
      treatment = sample(treatment)
    )
  ) %&gt;%
  print()
## # A tibble: 2,000 x 3
## # Groups:   m [2,000]
##        m data               permuted_data     
##    &lt;int&gt; &lt;list&gt;             &lt;list&gt;            
##  1     1 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt;
##  2     2 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt;
##  3     3 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt;
##  4     4 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt;
##  5     5 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt;
##  6     6 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt;
##  7     7 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt;
##  8     8 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt;
##  9     9 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt;
## 10    10 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt;
## # … with 1,990 more rows</code></pre>
<p>If you are new to <code>purrr::map()</code>, it needs to know two things: a vector or list column <code>.x</code>, and a function <code>.f</code> that is applied to each element in <code>.x</code>. In this case, <code>.x</code> is a list of data frames, and the function we apply is <code>mutate()</code>, which creates/modifies variables. We supply the additional function argument saying that we are overwriting the <code>treatment</code> variable by sampling its current values without replacement. This adds a list-column of 2,000 new data frames, each with a different permutation of treatment assignments. In case you need convincing, here is a table that glimpses the treatment assignments for a subset of <code>m</code> values.</p>
<pre class="r"><code>perm_table %&gt;%
  ungroup() %&gt;%
  sample_n(5) %&gt;%
  unnest(permuted_data) %&gt;%
  select(m, id, treatment) %&gt;%
  pivot_wider(
    names_from = m, 
    values_from = treatment,
    names_prefix = &quot;trt, m = &quot;
  )
## # A tibble: 500 x 6
##       id `trt, m = 561` `trt, m = 1471` `trt, m = 1325` `trt, m = 844`
##    &lt;int&gt;          &lt;dbl&gt;           &lt;dbl&gt;           &lt;dbl&gt;          &lt;dbl&gt;
##  1     1              0               0               0              1
##  2     2              0               1               1              0
##  3     3              1               0               1              1
##  4     4              0               1               1              1
##  5     5              1               0               1              1
##  6     6              0               0               1              0
##  7     7              0               0               1              1
##  8     8              1               0               1              1
##  9     9              1               1               0              1
## 10    10              0               0               1              1
## # … with 490 more rows, and 1 more variable: `trt, m = 943` &lt;dbl&gt;</code></pre>
<p>Now that we have datasets with permuted treatments, we calculate some test statistic in each iteration. I will calculate the difference between the treatment and control means, but other statistics are possible as well.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>
We again do this with <code>map()</code>, this time applying the <code>summarize()</code> function to calculate the treatment mean, the control mean, and the difference.</p>
<pre class="r"><code>est_table &lt;- perm_table %&gt;%
  mutate(
    estimates = map(
      .x = permuted_data,
      .f = summarize, 
      mean_treatment_m = mean(y[treatment == 1]),
      mean_control_m = mean(y[treatment == 0]),
      diff_means_m = mean_treatment_m - mean_control_m
    )
  ) %&gt;%
  print()
## # A tibble: 2,000 x 4
## # Groups:   m [2,000]
##        m data               permuted_data      estimates       
##    &lt;int&gt; &lt;list&gt;             &lt;list&gt;             &lt;list&gt;          
##  1     1 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  2     2 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  3     3 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  4     4 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  5     5 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  6     6 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  7     7 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  8     8 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  9     9 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
## 10    10 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
## # … with 1,990 more rows</code></pre>
<p>We can view the estimates in each iteration by unnesting the <code>estimates</code> column…</p>
<pre class="r"><code>est_summary &lt;- est_table %&gt;%
  select(m, estimates) %&gt;%
  unnest(cols = estimates) %&gt;%
  ungroup() %&gt;%
  print()
## # A tibble: 2,000 x 4
##        m mean_treatment_m mean_control_m diff_means_m
##    &lt;int&gt;            &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;
##  1     1            0.563          0.514      0.0495 
##  2     2            0.539          0.537      0.00152
##  3     3            0.563          0.514      0.0495 
##  4     4            0.535          0.541     -0.00648
##  5     5            0.551          0.525      0.0255 
##  6     6            0.567          0.510      0.0575 
##  7     7            0.490          0.584     -0.0945 
##  8     8            0.535          0.541     -0.00648
##  9     9            0.518          0.557     -0.0385 
## 10    10            0.588          0.490      0.0976 
## # … with 1,990 more rows</code></pre>
<p>We can calculate our <span class="math inline">\(p\)</span>-value by comparing our sample estimate to the null distribution…</p>
<pre class="r"><code>pval &lt;- est_summary %&gt;%
  summarize(
    p.value = mean(abs(diff_means_m) &gt; abs(observed_estimates$diff_means))
  ) %&gt;%
  pull(p.value) %&gt;%
  print()
## [1] 0.2515</code></pre>
<p>and we can plot our estimate against the null distribution. In our case, 25% of estimates from the null distribution exceed our in-sample estimate in magnitude, so we would not reject a null hypothesis in this setting.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
<p><img src="/posts/purrrmutation-tests/index_files/figure-html/compare-null-1.png" width="80%" style="display: block; margin: auto;" /></p>
</div>
<div id="putting-it-all-together" class="section level3">
<h3>Putting it all together</h3>
<p>In practice, we would not tediously create lots of objects to trace our method every step of the way. Instead, we could build our nested data frame, permute the treatment assignments, and estimate null treatment effects in one continuous operation.</p>
<pre class="r"><code># nested data, permute, estimate.
# bonus: permuted_data demos the &quot;quosure-style lambda function&quot; syntax 
ri_data &lt;- d %&gt;%
  crossing(m = 1:n_sims) %&gt;%
  group_by(m) %&gt;%
  nest() %&gt;%
  mutate(
    permuted_data = map(
      .x = data, 
      .f = ~ mutate(.x, treatment = sample(treatment))
    ),
    estimates = map(
      .x = permuted_data,
      .f = summarize,
      mean_treatment_m = mean(y[treatment == 1]),
      mean_control_m = mean(y[treatment == 0]),
      diff_means_m = mean_treatment_m - mean_control_m
    )
  ) %&gt;%
  print()
## # A tibble: 2,000 x 4
## # Groups:   m [2,000]
##        m data               permuted_data      estimates       
##    &lt;int&gt; &lt;list&gt;             &lt;list&gt;             &lt;list&gt;          
##  1     1 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  2     2 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  3     3 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  4     4 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  5     5 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  6     6 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  7     7 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  8     8 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
##  9     9 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
## 10    10 &lt;tibble [500 × 3]&gt; &lt;tibble [500 × 3]&gt; &lt;tibble [1 × 3]&gt;
## # … with 1,990 more rows</code></pre>
</div>
</div>
<div id="extensibility-of-the-tidy-approach" class="section level2">
<h2>Extensibility of the Tidy Approach</h2>
<p>We’ve seen that using <code>purrr::map()</code> lets us push around a <em>lot</em> of data with little code. Yet the <code>purrr</code> approach is still more verbose than other approaches that we might have used (see Thomas Leeper’s use of <code>replicate()</code> and <code>by()</code> <a href="https://thomasleeper.com/Rcourse/Tutorials/permutationtests.html">here</a>). Why would we use the tidy approach if slimmer methods exist? For one, it is eminently extensible. By keeping the fruits of your work together in one data frame, it is easy to adapt the workflow to incorporate other quantities of interest and research design features while keeping your work organized. This section will take a quick tour of how easy it is to (1) calculate confidence intervals and permute data from (2) multiple treatments, (3) cluster randomization, and (4) block-randomization.</p>
<div id="confidence-intervals" class="section level3">
<h3>Confidence Intervals</h3>
<p>So far we have entertained a generative model where (1) treatment has a constant, additive effect <span class="math inline">\(\delta\)</span> on unit-level response and (2) a null hypothesis that <span class="math inline">\(\delta = 0\)</span>.<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>
If we entertain null hypothesis values for <span class="math inline">\(\delta\)</span> other than strictly zero, we can construct a <span class="math inline">\(100 - \alpha\)</span> confidence region as <em>the values of <span class="math inline">\(\delta\)</span> for which we cannot reject the null hypothesis</em>.</p>
<p>We do this as follows. For a null value of <span class="math inline">\(\delta_{0}\)</span>:</p>
<ul>
<li>Adjust the in-sample test statistic by subtracting <span class="math inline">\(\delta_{0}\)</span> from the difference in means. This is similar to the way we would subtract the null value from a standard <span class="math inline">\(z\)</span>-test <span class="math inline">\(\left(\frac{\hat{\mu} - \mu_{0}}{\sigma}\right)\)</span>.</li>
<li>Calculate the <span class="math inline">\(p\)</span> value for this adjusted <span class="math inline">\(\hat{\delta}\)</span>.</li>
<li>If <span class="math inline">\(p &lt; \frac{\alpha}{2}\)</span>, we reject the null hypothesis that <span class="math inline">\(\delta = \delta_0\)</span>, meaning the value <span class="math inline">\(\delta_{0}\)</span> is <em>not</em> contained in the confidence interval.</li>
</ul>
<p>We can implement this routine by augmenting our data structure with a sequence of null values and performing the appropriate adjustments.</p>
<pre class="r"><code># for each m x delta_0, adjust the test statistic
# for each delta_0, calculate p-value 
conf_table &lt;- ri_data %&gt;%
  select(m, estimates) %&gt;%
  unnest(estimates) %&gt;%
  ungroup() %&gt;%
  crossing(null_value = seq(-0.2, 0.2, .01)) %&gt;%
  mutate(test_value = observed_estimates$diff_means - null_value) %&gt;%
  group_by(null_value) %&gt;%
  summarize(
    p.value = mean(diff_means_m &gt; abs(test_value))
  ) %&gt;%
  print()
## # A tibble: 41 x 2
##    null_value p.value
##         &lt;dbl&gt;   &lt;dbl&gt;
##  1      -0.2        0
##  2      -0.19       0
##  3      -0.18       0
##  4      -0.17       0
##  5      -0.16       0
##  6      -0.15       0
##  7      -0.14       0
##  8      -0.13       0
##  9      -0.12       0
## 10      -0.11       0
## # … with 31 more rows</code></pre>
<p>We saw above that our point estimate for the difference in means is roughly 0.05, but now that we found the <span class="math inline">\(p\)</span>-value under this sequence of hypothesis tests, we know the null values of <span class="math inline">\(\delta_0\)</span> that cannot be rejected, giving us a 93% interval [-0.04, 0.13] inclusive.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>
Below I plot the <span class="math inline">\(p\)</span>-value at each null <span class="math inline">\(\delta_{0}\)</span> as bars. Bars are colored red if they represent values of <span class="math inline">\(\delta_{0}\)</span> that can be rejected at <span class="math inline">\(\alpha = .05\)</span>. What remains is the values that cannot be rejected, which I use to draw the confidence interval below the bars. It’s important to remember that this is not a plot of a posterior distribution, so the height of the bar does not indicate the plausibility or credibility of a given <span class="math inline">\(\delta\)</span> value.</p>
<p><img src="/posts/purrrmutation-tests/index_files/figure-html/plot-conf-1.png" width="90%" style="display: block; margin: auto;" /></p>
</div>
<div id="multiple-treatments" class="section level3">
<h3>Multiple treatments</h3>
<p>Suppose that we had outcome data that were a function of multiple treatment conditions. Here is some fake data from an experiment where subjects rate potential candidates on a 0-10 scale, where the researcher manipulates the candidates party affiliation, occupation, and issue stances.</p>
<pre><code>## # A tibble: 500 x 7
##       id cand_rating party occupation issue_tax issue_abortion issue_environment
##    &lt;int&gt;       &lt;int&gt; &lt;dbl&gt;      &lt;int&gt;     &lt;int&gt;          &lt;int&gt;             &lt;int&gt;
##  1     1           9     1          4         3              2                 3
##  2     2           2     2          2         1              3                 3
##  3     3           2     2          4         2              4                 1
##  4     4           7     2          3         2              3                 3
##  5     5           2     1          4         2              3                 1
##  6     6           5     2          2         1              2                 2
##  7     7           2     2          1         3              4                 3
##  8     8           8     2          3         3              2                 3
##  9     9          10     1          4         3              3                 2
## 10    10           6     1          2         2              1                 2
## # … with 490 more rows</code></pre>
<p>It is easy to permute the values of multiple variables at once. The only thing that changes from the above workflow is that we map <code>mutate_at()</code> to each iteration, specifying that we want to sample the values of an arbitrary set of treatment variables. Supposing that this data were called <code>multi_treat</code>…</p>
<pre class="r"><code>
# helpful but not necessary:
# save a vector of treatment names for easy access
treatments &lt;- 
  c(&quot;party&quot;, &quot;occupation&quot;, &quot;issue_tax&quot;, &quot;issue_abortion&quot;, &quot;issue_environment&quot;)

# resample values for each var in `treatments`
multi_permuted &lt;- multi_treat %&gt;%
  crossing(m = 1:1000) %&gt;%
  group_by(m) %&gt;%
  nest() %&gt;%
  mutate(
    permuted_data = map(
      .x = data, 
      .f = mutate_at,
      .vars = vars(one_of(treatments)),
      .funs = sample
    )
  ) %&gt;%
  print()
## # A tibble: 1,000 x 3
## # Groups:   m [1,000]
##        m data               permuted_data     
##    &lt;int&gt; &lt;list&gt;             &lt;list&gt;            
##  1     1 &lt;tibble [500 × 7]&gt; &lt;tibble [500 × 7]&gt;
##  2     2 &lt;tibble [500 × 7]&gt; &lt;tibble [500 × 7]&gt;
##  3     3 &lt;tibble [500 × 7]&gt; &lt;tibble [500 × 7]&gt;
##  4     4 &lt;tibble [500 × 7]&gt; &lt;tibble [500 × 7]&gt;
##  5     5 &lt;tibble [500 × 7]&gt; &lt;tibble [500 × 7]&gt;
##  6     6 &lt;tibble [500 × 7]&gt; &lt;tibble [500 × 7]&gt;
##  7     7 &lt;tibble [500 × 7]&gt; &lt;tibble [500 × 7]&gt;
##  8     8 &lt;tibble [500 × 7]&gt; &lt;tibble [500 × 7]&gt;
##  9     9 &lt;tibble [500 × 7]&gt; &lt;tibble [500 × 7]&gt;
## 10    10 &lt;tibble [500 × 7]&gt; &lt;tibble [500 × 7]&gt;
## # … with 990 more rows</code></pre>
<p>You would then be able to <code>map()</code> whatever estimation model you wanted over the <code>permuted_data</code> column, thereby estimating the model in each group <code>m</code>.</p>
</div>
<div id="block-randomization" class="section level3">
<h3>Block Randomization</h3>
<p>Suppose we had data that were randomized within blocks. The data below contain <span class="math inline">\(n = 500\)</span> observations and 5 blocks, with each block containing 50 treated units and 50 control units.</p>
<pre><code>## # A tibble: 500 x 4
##       id block treatment     y
##    &lt;int&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;
##  1     1     2         1     0
##  2     2     3         0     1
##  3     3     4         0     0
##  4     4     5         1     1
##  5     5     1         0     0
##  6     6     2         0     1
##  7     7     3         1     1
##  8     8     4         1     0
##  9     9     5         1     0
## 10    10     1         1     1
## # … with 490 more rows</code></pre>
<p>We can’t naively permute the treatments over the whole data, since we want to respect the blocking structure. To permute treatments within blocks, we only require one additional step, which is to group the data by block during the permutation step.</p>
<pre class="r"><code>block_data %&gt;%
  crossing(m = 1:1000) %&gt;%
  group_by(m) %&gt;%
  nest() %&gt;%
  mutate(
    permuted_data = map(
      .x = data, 
      .f = ~ .x %&gt;%
             group_by(block) %&gt;%
             mutate(treatment = sample(treatment)) %&gt;%
             ungroup()
    )
  ) %&gt;%
  print()
## # A tibble: 1,000 x 3
## # Groups:   m [1,000]
##        m data               permuted_data     
##    &lt;int&gt; &lt;list&gt;             &lt;list&gt;            
##  1     1 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  2     2 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  3     3 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  4     4 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  5     5 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  6     6 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  7     7 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  8     8 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  9     9 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
## 10    10 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
## # … with 990 more rows</code></pre>
</div>
<div id="cluster-randomization" class="section level3">
<h3>Cluster randomization</h3>
<p>With cluster-randomized data, units are grouped within a cluster, and then every unit within a cluster gets the same treatment. Cluster-randomized data might look like so:</p>
<pre><code>## # A tibble: 500 x 4
##       id cluster treatment     y
##    &lt;int&gt;   &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;
##  1     1       1         0     1
##  2     2       1         0     0
##  3     3       1         0     0
##  4     4       1         0     1
##  5     5       1         0     0
##  6     6       2         1     1
##  7     7       2         1     0
##  8     8       2         1     1
##  9     9       2         1     1
## 10    10       2         1     0
## # … with 490 more rows</code></pre>
<p>In order to permute the treatment assignments, we have to reshuffle the treatment status for each cluster such that all units in the same cluster get the same treatment. This is possible, but it’s a bit abstract, since it requires a nest-within-a-nest (whoa…). When we <code>map()</code> the function to permute the data, we do the following within each iteration <code>m</code>.</p>
<ul>
<li>Nest the unit-level variables (<code>id</code> and <code>y</code>) into a list-column. What remains is a data frame that is one row per cluster.</li>
<li>Permute the treatment assignments at the cluster level</li>
<li>Unnest the unit-level data, at which point every unit inherits its cluster-level treatment assignment.</li>
</ul>
<pre class="r"><code>cluster_permuted &lt;- cluster_data %&gt;%
  crossing(m = 1:1000) %&gt;%
  group_by(m) %&gt;%
  nest() %&gt;%
  mutate(
    permuted_data = map(
      .x = data,
      .f = ~ .x %&gt;%
             nest(within_cluster = c(id, y)) %&gt;%
             mutate(treatment = sample(treatment)) %&gt;%
             unnest(within_cluster)
    )
  ) %&gt;%
  print()
## # A tibble: 1,000 x 3
## # Groups:   m [1,000]
##        m data               permuted_data     
##    &lt;int&gt; &lt;list&gt;             &lt;list&gt;            
##  1     1 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  2     2 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  3     3 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  4     4 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  5     5 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  6     6 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  7     7 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  8     8 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
##  9     9 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
## 10    10 &lt;tibble [500 × 4]&gt; &lt;tibble [500 × 4]&gt;
## # … with 990 more rows</code></pre>
<p>To assure you that this works, I will plot the treatment status of all units within 3 clusters across the first 10 permutations. We should see that all units in the same cluster share the same treatment status within the same treatment permutation <code>m</code>.</p>
<p><img src="/posts/purrrmutation-tests/index_files/figure-html/plot-unit-clusters-1.png" width="90%" style="display: block; margin: auto;" /></p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>
I’ll shout out <a href="https://cran.r-project.org/web/packages/ri2/">ri2</a> in particular.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>
The paper by <a href="https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.1540-5907.2011.00576.x?casa_token=YjkCBZcxieAAAAAA:-WVWyv9NfA_83dsFCKLYjofLTVBEKehe0cG3a3na-7OQhSQrURDVGsjgeKwHSv6KI5jrXpmNV5Bog9A">Keele, McConnaughy, and White</a> discusses and includes examples of other statistics such as rank-based tests, encouraging researchers to consider theory and the assumptions they are willing to make about the data, such as the choice of a “sharp” null hypothesis.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>
The estimated treatment effect is actually very close to the true effect, so what we’re seeing is a low-powered study.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>
This arguably requires more (or at least “different”) assumptions compared to a pure “Fisherian” approach to randomization inference, which is possible under a sharp null hypothesis that <em>treatment has zero effect for all units</em>.<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>
Due to the discrete nature of the <span class="math inline">\(\delta_{0}\)</span> values, we do not obtain a perfect 95% interval.<a href="#fnref5" class="footnote-back">↩</a></p></li>
</ol>
</div>

    </div>
  </article>

  
  





  <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about">About</a></li>
         
          <li><a href="/posts">Blog</a></li>
         
          <li><a href="/research">Public Research</a></li>
         
          <li><a href="/teaching">Teaching Resources</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      
    </div>

    <div id="share-footer" style="display: none">
      
      <ul>
  
  
    
  
  
  <li>
    <a class="icon" href="http://www.facebook.com/sharer.php?u=%2fposts%2frandomization-inference-purrr%2f">
      <i class="fab fa-facebook fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://twitter.com/share?url=%2fposts%2frandomization-inference-purrr%2f&text=Purrrmutation%20Testing">
      <i class="fab fa-twitter fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.linkedin.com/shareArticle?url=%2fposts%2frandomization-inference-purrr%2f&title=Purrrmutation%20Testing">
      <i class="fab fa-linkedin fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=%2fposts%2frandomization-inference-purrr%2f&is_video=false&description=Purrrmutation%20Testing">
      <i class="fab fa-pinterest fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="mailto:?subject=Purrrmutation%20Testing&body=Check out this article: %2fposts%2frandomization-inference-purrr%2f">
      <i class="fas fa-envelope fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://getpocket.com/save?url=%2fposts%2frandomization-inference-purrr%2f&title=Purrrmutation%20Testing">
      <i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://reddit.com/submit?url=%2fposts%2frandomization-inference-purrr%2f&title=Purrrmutation%20Testing">
      <i class="fab fa-reddit fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.stumbleupon.com/submit?url=%2fposts%2frandomization-inference-purrr%2f&title=Purrrmutation%20Testing">
      <i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://digg.com/submit?url=%2fposts%2frandomization-inference-purrr%2f&title=Purrrmutation%20Testing">
      <i class="fab fa-digg fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="http://www.tumblr.com/share/link?url=%2fposts%2frandomization-inference-purrr%2f&name=Purrrmutation%20Testing&description=Randomization%20Inference%20within%20the%20Tidyverse">
      <i class="fab fa-tumblr fa-lg" aria-hidden="true"></i>
    </a>
  </li>
  <li>
    <a class="icon" href="https://news.ycombinator.com/submitlink?u=%2fposts%2frandomization-inference-purrr%2f&t=Purrrmutation%20Testing">
      <i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i>
    </a>
  </li>
</ul>

    </div>

    <div id="actions-footer">
      
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;">
          <i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;">
          <i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;">
          <i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');">
          <i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>


  <footer id="footer">
  <div class="footer-left" align=right>
    Copyright  &copy; 2020  Michael DeCrescenzo 
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>


  


<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

</html>
