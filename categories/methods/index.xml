<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Methods on Michael DeCrescenzo</title>
    <link>/categories/methods/</link>
    <description>Recent content in Methods on Michael DeCrescenzo</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>&amp;copy; Michael DeCrescenzo {year}</copyright>
    <lastBuildDate>Tue, 21 Jul 2020 00:00:00 +0000</lastBuildDate>
    
	    <atom:link href="/categories/methods/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Fancy &#34;Neural Network&#34; Graphic but it&#39;s actually just Linear Regression
</title>
      <link>/post/linear-regression-neural-net/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/linear-regression-neural-net/</guid>
      <description>


&lt;div id=&#34;motivation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;If you aren’t familiar with neural networks, you might have heard people (especially academics) joke about how “deep learning is just linear regression.”
This might sound hard to believe, because after all, neural networks sound fancy, and they often introduced with a graphic like this…&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;net.png&#34; width=&#34;60%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;which, despite being supposedly helpful, doesn’t really explain the intuition of what a neural network model really is.&lt;/p&gt;
&lt;p&gt;The purpose of this post is to demystify neural networks by taking something easy—linear regression—and drawing it up in a “neural network-style graphic.”
I very much intend to be cheeky about this: neural networks are not that complicated.
If you know the algebra behind a generalized linear model, you know how to understand neural networks.
The only reason this isn’t obvious is because neural networks have good marketing.
But that’s what this post takes aim at.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;glms-and-neural-network-jargon&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;GLMs and Neural Network Jargon&lt;/h2&gt;
&lt;p&gt;Neural network jargon contains terms like &lt;em&gt;inputs, outputs, hidden nodes, hidden layers, weights, biases, activation functions&lt;/em&gt;…each of which has a pretty easy mapping to the basic structure of a GLM.&lt;/p&gt;
&lt;p&gt;Let’s start with a linear model with Normal errors.
For units indexed &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;, the outcome &lt;span class=&#34;math inline&#34;&gt;\(y_{i}\)&lt;/span&gt; is a linear function of a vector of predictors &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{x}_{i}\)&lt;/span&gt; and coefficients &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;.
We have &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt; many predictors, so the length of &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; is also &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt;.
Finally, we have a random Normal error &lt;span class=&#34;math inline&#34;&gt;\(\epsilon_{i}\)&lt;/span&gt;…
&lt;span class=&#34;math display&#34; id=&#34;eq:ols&#34;&gt;\[\begin{align}
\begin{split}
  y_{i} &amp;amp;= \alpha + \mathbf{x}_{i}^{\intercal}\beta + \epsilon_{i} \\
  \epsilon_{i} &amp;amp;\sim \mathrm{Normal}\left(0, \sigma \right)
\end{split}  
\tag{1}
\end{align}\]&lt;/span&gt;
We could write this more generally by construing &lt;span class=&#34;math inline&#34;&gt;\(y_{i}\)&lt;/span&gt; itself as a random variable with a mean that is conditional on data and parameters…
&lt;span class=&#34;math display&#34; id=&#34;eq:glm&#34;&gt;\[\begin{align}
\begin{split}
  y_{i} &amp;amp;\sim 
    \mathrm{Normal}\left(\mu_{i}, \sigma \right) \\
    \mu_{i} &amp;amp;= \alpha + \mathbf{x}_{i}^{\intercal}\beta
\end{split}
\tag{2}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;How does this relate to neural networks?
Already we have almost every element of the neural network jargon represented.
They go like so:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;input&lt;/strong&gt;: predictors &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{x}_{i}\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;output&lt;/strong&gt;: dependent variable &lt;span class=&#34;math inline&#34;&gt;\(y_{i}\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;weights&lt;/strong&gt;: a vector coefficients, &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;, length &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;biases&lt;/strong&gt;: a constant, &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hidden node&lt;/strong&gt;: a linear combination of input data &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{x}_{i}\)&lt;/span&gt;, weights &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;, and “bias term” &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt;. In regression this is equal to the linear predictor, &lt;span class=&#34;math inline&#34;&gt;\(\alpha + \mathbf{x}_{i}^{\intercal}\beta\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;activation function&lt;/strong&gt;: a function the connects the linear predictor (or “hidden node”) to the dependent variable (“output”).
This is similar to an inverse link function, although the neural network is slightly more general.
In a linear regression example, the linear predictor is linked to the outcome by the identity function, so there is no substantive transformation of the linear predictor.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/post/linear-net/index_files/figure-html/net-reg-1.png&#34; width=&#34;100%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://community.jmp.com/t5/JMP-Blog/Neural-networks-for-regression-lovers/ba-p/211796&#34; class=&#34;uri&#34;&gt;https://community.jmp.com/t5/JMP-Blog/Neural-networks-for-regression-lovers/ba-p/211796&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Non-Flat Implications of Flat Priors</title>
      <link>/post/nonflat-implications/</link>
      <pubDate>Tue, 30 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/nonflat-implications/</guid>
      <description>


&lt;div id=&#34;motivation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;Many researchers, when they’re introduced to Bayesian methods, are nervous about the possibility that their prior distributions will corrupt their posterior inferences.
Since they know that the posterior distribution is a precision-weighted average of the prior and the data (or “likelihood”), it initially makes sense to err toward a flatter, more diffuse prior density for model parameters.
These diffuse densities let the model put relatively more weight on data, which feels safer.&lt;/p&gt;
&lt;p&gt;The purpose of this post is to highlight a few areas where this “default tendency” to use flat priors runs into unexpected consequences.
We show how functions of model parameters have &lt;em&gt;implied priors&lt;/em&gt;: density functions of their own that inherit the prior uncertainty about the parameters that compose the function.
These implied priors can have strange shapes that you wouldn’t anticipate based on the raw parameters.&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;
We then show two cases where these strange shapes appear.
The first case comes from &lt;a href=&#34;/publication/nonvoters&#34;&gt;my own published work on voter ID in Wisconsin&lt;/a&gt;.
The second case is a hypothetical experiment where we “accidentally” create a non-flat prior for the treatment effect in a randomized experiment where we weren’t expecting it.&lt;/p&gt;
&lt;p&gt;Together, these exercises give concrete examples for the way flat priors and “uninformative” don’t necessarily mean the same thing.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;implied-priors&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Implied priors&lt;/h2&gt;
&lt;p&gt;We’ll begin with a notion of the &lt;em&gt;implied prior&lt;/em&gt;.
With some random variable &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt;, we can construct a function &lt;span class=&#34;math inline&#34;&gt;\(f\left(\theta\right)\)&lt;/span&gt;, which is necessarily a random variable as well.
If &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt; has a probability distribution &lt;span class=&#34;math inline&#34;&gt;\(p\left(\theta\right)\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(f\left(\theta\right)\)&lt;/span&gt; will have some probability distribution &lt;span class=&#34;math inline&#34;&gt;\(p\left(f\left(\theta\right)\right)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;A simple example.
Imagine some standard normal variable &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt; that is distributed &lt;span class=&#34;math inline&#34;&gt;\(\mathrm{Normal}\left(0, 1\right)\)&lt;/span&gt; prior.
If we have some function &lt;span class=&#34;math inline&#34;&gt;\(f(\nu) = \mu + \sigma\nu\)&lt;/span&gt;, then &lt;span class=&#34;math inline&#34;&gt;\(f(\nu)\)&lt;/span&gt; will have a probability distribution.
In this case, it is straightforward to see that this prior would be &lt;span class=&#34;math inline&#34;&gt;\(\mathrm{Normal}(\mu, \sigma)\)&lt;/span&gt;, but in more complicated examples it won’t be so easy to glean the implied prior directly.
We can create this example using code, setting &lt;span class=&#34;math inline&#34;&gt;\(\mu = 4\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\sigma = 2\)&lt;/span&gt;, to reassure you that I’m telling the truth.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;tidyverse&amp;quot;)
library(&amp;quot;hrbrthemes&amp;quot;)
library(&amp;quot;latex2exp&amp;quot;)
library(&amp;quot;viridisLite&amp;quot;)

theme_ipsum(base_family = &amp;quot;Fira Sans&amp;quot;) %+replace%
  theme(
    panel.grid.minor = element_blank(),
    axis.title.x.bottom = element_text(
      margin = margin(t = 0.35, unit = &amp;quot;cm&amp;quot;),
      size = rel(1.5)
    )
  ) %&amp;gt;%
  theme_set()

accent &amp;lt;- viridis(n = 1, begin = 0.5, end = 0.5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# set mu and sigma values
mu &amp;lt;- 4
sigma &amp;lt;- 2

# simulate nu and f(nu)
normal_example &amp;lt;- 
  tibble(
    nu = rnorm(100000),
    f_nu = mu + (nu * sigma)
  ) %&amp;gt;%
  print(n = 4) 
## # A tibble: 100,000 x 2
##        nu  f_nu
##     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1  0.669   5.34
## 2 -0.448   3.10
## 3  0.0987  4.20
## 4  0.591   5.18
## # … with 99,996 more rows

# implied prior is Normal(mu, sigma)
ggplot(normal_example) +
  aes(x = f_nu) +
  geom_histogram(binwidth = .1, fill = accent) +
  geom_vline(
    xintercept = c(mu - sigma, mu + sigma),
    linetype = &amp;quot;dashed&amp;quot;,
    size = 0.25
  ) +
  geom_vline(xintercept = mu) +
  scale_x_continuous(
    breaks = seq(mu - 5*sigma, mu + 5*sigma, sigma)
  ) +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = &amp;quot;Implied Prior for Transformed Normal&amp;quot;,
    subtitle = &amp;quot;Histogram of prior samples&amp;quot;,
    x = TeX(&amp;quot;$f(\\nu) = \\mu + \\sigma\\nu, \\; \\nu \\sim N(0, 1)$&amp;quot;),
    y = NULL
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/nonflat-implied-priors/index_files/figure-html/implied-normal-1.png&#34; width=&#34;100%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Bayesians will recognize this as a “non-centered parameterization” of a Normal distribution, or a normal distribution that sneaks the mean and standard deviation values out of the random variable.
Bayesian modelers invoke this trick all the time in hierarchical models, since sampling &lt;span class=&#34;math inline&#34;&gt;\(\nu\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;, and &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt; separately is easier for a computer to do than sampling a distribution for &lt;span class=&#34;math inline&#34;&gt;\(f(\nu)\)&lt;/span&gt; that itself contains &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;.
Parameterizations that de-correlate these parameters are generally easier to sample &lt;em&gt;and&lt;/em&gt;, conveniently, more manageable to set priors for.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;flat-priors-meet-nonlinear-transformations&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Flat priors meet nonlinear transformations&lt;/h2&gt;
&lt;p&gt;Suppose we have a parameter &lt;span class=&#34;math inline&#34;&gt;\(\pi\)&lt;/span&gt; has a flat prior in the &lt;span class=&#34;math inline&#34;&gt;\([0, 1]\)&lt;/span&gt; interval, and we calculate some function &lt;span class=&#34;math inline&#34;&gt;\(g(\pi)\)&lt;/span&gt;.
Will &lt;span class=&#34;math inline&#34;&gt;\(g(\pi)\)&lt;/span&gt; have a flat distribution?
It depends.&lt;/p&gt;
&lt;p&gt;I encountered an example of this in my work with Ken Mayer on &lt;a href=&#34;/publication/nonvoters&#34;&gt;voter ID in Wisconsin&lt;/a&gt; in Wisconsin,&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;
although I didn’t put this lesson about prior flatness in the paper.
We wanted to estimate the &lt;em&gt;number of eligible registered voters&lt;/em&gt; in two Wisconsin counties for whom Wisconsin’s voter ID requirement hindered their voting in 2016.
This estimate contains three ingredients.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt;: the number of individual records in the registered voter file for the target population.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\epsilon\)&lt;/span&gt;: the proportion of the population in the voter file that was eligible to vote in 2016.
This is relevant because voter files contain individuals who moved, died, or who were otherwise ineligible, that have to be cleaned out of voter files periodically.
The population size must be penalized by &lt;span class=&#34;math inline&#34;&gt;\(\epsilon\)&lt;/span&gt; to remove these ineligible records from our estimate.
Estimated by coding a finite sample of the voter file.&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\pi\)&lt;/span&gt;: the proportion of eligible registrants who experienced ID-related difficulty voting.
Estimated using a survey sample of registrants in the voter file.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The quantity we want to estimate is &lt;span class=&#34;math inline&#34;&gt;\(N\epsilon\pi\)&lt;/span&gt;, an eligibility-penalized population estimate for the number of voters affected by the voter ID requirement.
Suppose that we know &lt;span class=&#34;math inline&#34;&gt;\(N = 229,625\)&lt;/span&gt; from the voter file, but &lt;span class=&#34;math inline&#34;&gt;\(\pi\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\epsilon\)&lt;/span&gt; are proportions that must be estimated.
We give each proportion a flat &lt;span class=&#34;math inline&#34;&gt;\(\mathrm{Beta}(1, 1)\)&lt;/span&gt; prior on the &lt;span class=&#34;math inline&#34;&gt;\([0, 1]\)&lt;/span&gt; interval.
What is our implied prior for the population estimate?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tibble(
  pi = rbeta(10000, 1, 1),
  epsilon = rbeta(10000, 1, 1),
  N = 229625,
  pop_estimate = N * epsilon * pi
) %&amp;gt;%
  ggplot() +
  aes(x = pop_estimate) +
  geom_histogram(fill = accent, bins = 100, boundary = 0) +
  labs(
    title = &amp;quot;Implied Prior for Population Estimate&amp;quot;,
    subtitle = TeX(&amp;quot;Histogram of prior simulations&amp;quot;),
    x = TeX(&amp;quot;Population estimate $= N \\epsilon \\pi$&amp;quot;),
    y = NULL
  ) +
  scale_x_continuous(labels = scales::comma)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/nonflat-implied-priors/index_files/figure-html/voter-id-1.png&#34; width=&#34;100%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Seriously, what?
If I had plopped this graphic into my paper and said that it was my prior for this population quantity, I would have been in trouble.
Look at how swoopy that prior looks!
How can that be an uninformative prior?
Well, we know that the random components have vague priors, so this is the natural result of sending these parameters through a nonlinear function.
If you don’t like it, you should think about how this quantity is parameterized and whether some other priors make more sense.&lt;/p&gt;
&lt;p&gt;Bayesians may recognize this feature of prior distributions as well, where nonlinear functions of parameters have a density that does not simply reflect a shifting or scaling of the original density.
This happens because nonlinear transformations of parameters can “squish” or “stretch” probability mass into different areas/volumes than they were previously, thereby changing probability density.
If we wanted to write out the new density, we would need to start with the old density and use (spooky voice) &lt;em&gt;&lt;strong&gt;the Jacobian&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;honey-i-shrunk-my-treatment-effect&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Honey, I shrunk my treatment effect&lt;/h2&gt;
&lt;p&gt;When we think about causal inference, we are thinking about methods that want to be light on their assumptions.
If we imagine a Bayesian interpretation of this experiment (even if we don’t specify the Bayesian &lt;em&gt;model&lt;/em&gt; per se), it makes sense that we want vague priors on important quantities in order to “let the data speak” instead of deriving results from the prior.
This turns out to be less straightforward than you would think.&lt;/p&gt;
&lt;p&gt;Imagine an experiment where we treat individuals with an advertisement or we don’t, &lt;span class=&#34;math inline&#34;&gt;\(z_{i} \in \{0, 1\}\)&lt;/span&gt;, and then we measure whether they intend to vote for the Democratic candidate or not, &lt;span class=&#34;math inline&#34;&gt;\(y_{i} \in \{0, 1\}\)&lt;/span&gt;.
My treatment effect &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt; is the comparison between the Democratic vote proportion in the control group, &lt;span class=&#34;math inline&#34;&gt;\(\mu_{z = 0}\)&lt;/span&gt;, and the Democratic vote proportion in the treatment group, &lt;span class=&#34;math inline&#34;&gt;\(\mu_{z = 1}\)&lt;/span&gt;.
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  \tau = \mu_{1} - \mu_{0}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;If we estimate this effect with a linear model, we have a choice about how to parameterize the regression function.
We could use a constant and a treatment effect with error term &lt;span class=&#34;math inline&#34;&gt;\(u_{i}\)&lt;/span&gt;,
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  y_{i} = \mu_{0} + \tau z_{i} + u_{i}  
\end{align}\]&lt;/span&gt;
or we have two intercepts for each condition.
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  y_{i} = \mu_{z[i]} + u_{i}
\end{align}\]&lt;/span&gt;
Bayesians think it makes more sense to use the second parameterization.
Why?
If we want to set the same prior on both groups, it’s easier to do that when we can directly set priors on each mean instead of on one mean and the difference-in-means.
So let’s take that approach, giving each vote share a flat prior that says any vote share for both groups is &lt;em&gt;a priori&lt;/em&gt; equally likely. I will write these as flat Beta densities, but you could imagine them as standard Uniform densities as well.
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  \mu_{1}, \mu_{0} \sim \mathrm{Beta}(1, 1)
\end{align}\]&lt;/span&gt;
What is the prior for the treatment effect (the difference-in-means)?
Not flat!
We will again simulate to see the effect of combining parameters into a single function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# simulate means and calculate difference
tibble(
  mu_0 = rbeta(100000, 1, 1), 
  mu_1 = rbeta(100000, 1, 1),
  trt = mu_1 - mu_0 
) %&amp;gt;%
  ggplot() +
  aes(x = trt) +
  geom_histogram(fill = accent, binwidth = .05, boundary = 0) +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = &amp;quot;Implied Prior for Treatment Effect&amp;quot;,
    subtitle = &amp;quot;Histogram of prior samples&amp;quot;,
    x = &amp;quot;Difference in means&amp;quot;,
    y = NULL
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/nonflat-implied-priors/index_files/figure-html/rct-1.png&#34; width=&#34;100%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;What happened to my vague prior beliefs?
Why do I have this non-flat prior for something I thought I wanted to have vague information for?&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It still is a vague prior, but we’re wrong to expect it to be flat.
Why?
Well, averaging over my prior uncertainty in both groups, my expected difference in means ought to be &lt;em&gt;mean&lt;/em&gt; zero (natch).
But more than that, the reason why we get a &lt;em&gt;mode&lt;/em&gt; at zero there are many more ways to produce differences near zero with my raw means than differences far from zero.
The only way to get big differences (near &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;) is for both means to be far apart, which isn’t as likely to happen randomly as two means that are closer together in the prior.
When we think about the treatment effect prior in this way, we can understand why this actually feels &lt;em&gt;less informed&lt;/em&gt; than a direct flat prior for the treatment effect.
Putting a flat prior on the treatment effect is saying that we think big differences are just as likely as small differences.
This is like a prior that says my group means should be negatively correlated, effectively upweighting bigger differences from what we’d otherwise expect.
Weird!
I’d rather set reasonable priors for my means and let my treatment prior do what it do.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;flat-priors-often-have-non-flat-implications&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Flat priors often have non-flat implications&lt;/h2&gt;
&lt;p&gt;These implications feel strange at first, but they are all around us whether or not we notice them.
The flatness of a prior (or any shape, flat or not) is a &lt;em&gt;relative&lt;/em&gt; feature of a model parameterization or a quantity of interest, not an &lt;em&gt;absolute&lt;/em&gt; one.
Inasmuch as we believe priors are at work even when we don’t want to think about them—i.e. we accept Bayesian models as generalizations of likelihood models—we should respect how transforming a likelihood affects &lt;a href=&#34;https://www.mdpi.com/1099-4300/19/10/555&#34;&gt;which parameters are exposed to the researcher, and which spaces those parameters are defined in&lt;/a&gt;.
We should know that flat doesn’t imply uninformative, and that non-flat doesn’t imply informative.
What we’re seeing here is that flatness begets non-flatness in tons of circumstances, and that’s totally ordinary.
And more examples of how prior predictive checks show us what our model thinks about key quantities of interest.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;
These strange shapes tend to be extremely useful in practice.
For example, it is straightforward to create Bayesian versions of “L1” and “L2” by combining parameters with particular densities.
Topic for a future post maybe.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;
Or see the &lt;a href=&#34;https://www.liebertpub.com/doi/10.1089/elj.2018.0536&#34;&gt;published version&lt;/a&gt;.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;
You’ve probably seen this phenomenon previously in our stats education.
If you keep adding and subtracting more uniform variables, we would approach a Normal distribution.&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>How do I reinstall my packages for R 4.0 when many of them came from Github?</title>
      <link>/post/package-reinstall/</link>
      <pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/package-reinstall/</guid>
      <description>


&lt;div id=&#34;motivation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Motivation&lt;/h1&gt;
&lt;p&gt;R 4.0 &lt;a href=&#34;https://cran.r-project.org/&#34;&gt;is here&lt;/a&gt;, and that’s great. Be warned that if you install it, you will lose all of your installed packages. How should you reinstall them?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First,&lt;/strong&gt; there’s something to be said for installing as you go rather than inheriting all of your packages from your past self. A major upgrade can be a good excuse to clean house, trim unnecessary stuff from your computer, and &lt;a href=&#34;https://twitter.com/hadleywickham/status/1254387031842701312&#34;&gt;install packages from scratch&lt;/a&gt;. As much as I like to take this approach myself, I have to teach next week, so I want my R environment established quickly.&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If you don’t particularly want to install-as-you-go, one way to revitalize your R environment is to &lt;em&gt;record which packages you have installed&lt;/em&gt; and automate their re-installation with some code. You can find several helpful online guides that &lt;a href=&#34;https://rstats.wtf/maintaining-r.html#how-to-transfer-your-library-when-updating-r&#34;&gt;walk through the main idea&lt;/a&gt;: save the names of installed packages as a vector, and then pass these names to &lt;code&gt;install.packages()&lt;/code&gt; to do a batch installation from CRAN.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;But what about the packages that don’t live on CRAN?&lt;/strong&gt; My experiments with R have led me to install several packages from Github: maybe they were “development versions” that had yet to be published on CRAN, or they will never be on CRAN due to policy incompatibilities or the wishes of the package developer. (See Reason #5 in &lt;a href=&#34;https://twitter.com/hadleywickham/status/1254421747014737920&#34;&gt;this tweet&lt;/a&gt;.) How can we automate the reinstall process when these packages have different online sources? This post walks through a process for doing that, adapted from this &lt;a href=&#34;https://gist.github.com/mikedecr/6fd2e7855c71e4358534d5af3b72a03d&#34;&gt;Gist&lt;/a&gt; that I &lt;a href=&#34;https://twitter.com/mikedecr/status/1254152352241782787&#34;&gt;shared on Twitter&lt;/a&gt;. I adapted the whole thing to go into a little &lt;a href=&#34;https://github.com/mikedecr/update-R&#34;&gt;Github repository&lt;/a&gt; if you’d like to fork/clone that instead.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;roadmap&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Roadmap&lt;/h1&gt;
&lt;p&gt;The routine has the following main ideas.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;What packages have I installed, and where did they come from?&lt;/li&gt;
&lt;li&gt;Check my local package versions against the CRAN versions. Are the most recent versions on CRAN, or was I using a Github version that I should keep using?&lt;/li&gt;
&lt;li&gt;Render unto Caesar: install the packages from CRAN that makes sense to get from CRAN, but install the packages from Github that makes sense to get from Github.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;what-is-already-installed&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;What is already installed?&lt;/h1&gt;
&lt;p&gt;First we collect information on the packages we already have installed. I am working out of a project directory that manages all of my R updating business, so I &lt;a href=&#34;https://rstats.wtf/safe-paths.html&#34;&gt;use the &lt;code&gt;{here}&lt;/code&gt; package&lt;/a&gt; consistent with a &lt;a href=&#34;https://rstats.wtf/project-oriented-workflow.html&#34;&gt;project-oriented R workflow&lt;/a&gt;. We will also use tidyverse-style data manipulation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;here&amp;quot;)
library(&amp;quot;tidyverse&amp;quot;)
## Warning: package &amp;#39;tibble&amp;#39; was built under R version 4.0.2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;installed.packages()&lt;/code&gt; function returns a table of package information for all packages in your library. I convert this to a tibble to make things easier.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# data frame of all installed packages
local_pkgs &amp;lt;- installed.packages() %&amp;gt;%
  as_tibble() %&amp;gt;%
  print()
## # A tibble: 383 x 16
##    Package LibPath Version Priority Depends Imports LinkingTo Suggests Enhances
##    &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;   
##  1 abind   /Libra… 1.4-5   &amp;lt;NA&amp;gt;     &amp;quot;R (&amp;gt;=… method… &amp;lt;NA&amp;gt;       &amp;lt;NA&amp;gt;    &amp;lt;NA&amp;gt;    
##  2 adagio  /Libra… 0.7.1   &amp;lt;NA&amp;gt;     &amp;quot;R (&amp;gt;=… graphi… &amp;lt;NA&amp;gt;       &amp;lt;NA&amp;gt;    &amp;lt;NA&amp;gt;    
##  3 ade4    /Libra… 1.7-15  &amp;lt;NA&amp;gt;     &amp;quot;R (&amp;gt;=… graphi… &amp;lt;NA&amp;gt;      &amp;quot;ade4Tk… &amp;lt;NA&amp;gt;    
##  4 AER     /Libra… 1.2-9   &amp;lt;NA&amp;gt;     &amp;quot;R (&amp;gt;=… stats,… &amp;lt;NA&amp;gt;      &amp;quot;boot, … &amp;lt;NA&amp;gt;    
##  5 Amelia  /Libra… 1.7.6   &amp;lt;NA&amp;gt;     &amp;quot;R (&amp;gt;=… foreig… Rcpp (&amp;gt;=… &amp;quot;tcltk,… &amp;lt;NA&amp;gt;    
##  6 arrayh… /Libra… 1.1-0   &amp;lt;NA&amp;gt;      &amp;lt;NA&amp;gt;   method… &amp;lt;NA&amp;gt;       &amp;lt;NA&amp;gt;    &amp;lt;NA&amp;gt;    
##  7 askpass /Libra… 1.1     &amp;lt;NA&amp;gt;      &amp;lt;NA&amp;gt;   sys (&amp;gt;… &amp;lt;NA&amp;gt;      &amp;quot;testth… &amp;lt;NA&amp;gt;    
##  8 assert… /Libra… 0.2.1   &amp;lt;NA&amp;gt;      &amp;lt;NA&amp;gt;   tools   &amp;lt;NA&amp;gt;      &amp;quot;testth… &amp;lt;NA&amp;gt;    
##  9 audio   /Libra… 0.1-7   &amp;lt;NA&amp;gt;     &amp;quot;R (&amp;gt;=… &amp;lt;NA&amp;gt;    &amp;lt;NA&amp;gt;       &amp;lt;NA&amp;gt;    &amp;lt;NA&amp;gt;    
## 10 backpo… /Libra… 1.1.7   &amp;lt;NA&amp;gt;     &amp;quot;R (&amp;gt;=… utils   &amp;lt;NA&amp;gt;       &amp;lt;NA&amp;gt;    &amp;lt;NA&amp;gt;    
## # … with 373 more rows, and 7 more variables: License &amp;lt;chr&amp;gt;,
## #   License_is_FOSS &amp;lt;chr&amp;gt;, License_restricts_use &amp;lt;chr&amp;gt;, OS_type &amp;lt;chr&amp;gt;,
## #   MD5sum &amp;lt;chr&amp;gt;, NeedsCompilation &amp;lt;chr&amp;gt;, Built &amp;lt;chr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a start, but I also want to know if I got these packages from CRAN or from Github. I can do this with &lt;code&gt;sessioninfo::package_info()&lt;/code&gt;, passing a vector of package names to the function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# get source details (cran, github...) from package_info()
local_details &amp;lt;- 
  sessioninfo::package_info(pkgs = local_pkgs$Package) %&amp;gt;%
  as_tibble() %&amp;gt;%
  select(package, local_version = ondiskversion, source) %&amp;gt;%
  print()
## # A tibble: 369 x 3
##    package      local_version source        
##    &amp;lt;chr&amp;gt;        &amp;lt;chr&amp;gt;         &amp;lt;chr&amp;gt;         
##  1 abind        1.4-5         CRAN (R 4.0.0)
##  2 adagio       0.7.1         CRAN (R 4.0.0)
##  3 ade4         1.7-15        CRAN (R 4.0.0)
##  4 AER          1.2-9         CRAN (R 4.0.0)
##  5 Amelia       1.7.6         CRAN (R 4.0.0)
##  6 arrayhelpers 1.1-0         CRAN (R 4.0.0)
##  7 askpass      1.1           CRAN (R 4.0.0)
##  8 assertthat   0.2.1         CRAN (R 4.0.0)
##  9 audio        0.1-7         CRAN (R 4.0.0)
## 10 backports    1.1.7         CRAN (R 4.0.0)
## # … with 359 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that this new table has 14 fewer rows. That’s because &lt;code&gt;sessioninfo::package_info()&lt;/code&gt; isn’t returning the base packages that show up in &lt;code&gt;installed.packages()&lt;/code&gt;. That’s fine, since those will come with R 4.0 anyway.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;source&lt;/code&gt; column in this new table shows us what we want to know. For instance, let’s look at packages that I have from Github.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter(local_details, str_detect(source, &amp;quot;Github&amp;quot;))
## # A tibble: 9 x 3
##   package               local_version source                                    
##   &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;         &amp;lt;chr&amp;gt;                                     
## 1 colorout              1.2-2         Github (jalvesaq/colorout@726d681)        
## 2 emo                   0.0.0.9000    Github (hadley/emo@3f03b11)               
## 3 ggkeyboard            0.0.0.9009    Github (sharlagelfand/ggkeyboard@b1a965d) 
## 4 mRkov                 0.0.0.9000    Github (serrat839/mRkov@0f520e8)          
## 5 rethinking            2.00          Github (rmcelreath/rethinking@f393f30)    
## 6 springerQuarantineBo… 0.1.0         Github (renanxcortes/springerQuarantineBo…
## 7 Statamarkdown         0.4.5         Github (hemken/Statamarkdown@506cfc9)     
## 8 texreg                1.36.28       Github (leifeld/texreg@c1da5c8)           
## 9 waffle                1.0.1         Github (hrbrmstr/waffle@3f61463)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;determining-install-source-by-comparing-package-versions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Determining install source by comparing package versions&lt;/h1&gt;
&lt;p&gt;Before you update R, you may be using packages installed from Github, even if those packages are also on CRAN. We want to compare our locally installed package versions against the versions on CRAN. If the CRAN versions are more recent, we can go ahead and get those packages from CRAN. If the Github versions are still the most recent (or the &lt;em&gt;only&lt;/em&gt;) versions of some packages, we want to get them from Github.&lt;/p&gt;
&lt;p&gt;We will want to get a table of data on CRAN package versions. The &lt;code&gt;available.packages()&lt;/code&gt; function returns info for &lt;strong&gt;all&lt;/strong&gt; packages on CRAN.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# available.packages() returns pkg info for ALL pkgs on CRAN.
cran_pkgs &amp;lt;- available.packages() %&amp;gt;% 
  as_tibble(.name_repair = tolower) %&amp;gt;%
  print()
## # A tibble: 16,222 x 17
##    package version priority depends imports linkingto suggests enhances license
##    &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;  
##  1 A3      1.0.0   &amp;lt;NA&amp;gt;     R (&amp;gt;= …  &amp;lt;NA&amp;gt;   &amp;lt;NA&amp;gt;      randomF… &amp;lt;NA&amp;gt;     GPL (&amp;gt;…
##  2 aaSEA   1.1.0   &amp;lt;NA&amp;gt;     R(&amp;gt;= 3… &amp;quot;DT(&amp;gt;=… &amp;lt;NA&amp;gt;      knitr, … &amp;lt;NA&amp;gt;     GPL-3  
##  3 AATtoo… 0.0.1   &amp;lt;NA&amp;gt;     R (&amp;gt;= … &amp;quot;magri… &amp;lt;NA&amp;gt;      &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;     GPL-3  
##  4 ABACUS  1.0.0   &amp;lt;NA&amp;gt;     R (&amp;gt;= … &amp;quot;ggplo… &amp;lt;NA&amp;gt;      rmarkdo… &amp;lt;NA&amp;gt;     GPL-3  
##  5 abbyyR  0.5.5   &amp;lt;NA&amp;gt;     R (&amp;gt;= … &amp;quot;httr,… &amp;lt;NA&amp;gt;      testtha… &amp;lt;NA&amp;gt;     MIT + …
##  6 abc     2.1     &amp;lt;NA&amp;gt;     R (&amp;gt;= …  &amp;lt;NA&amp;gt;   &amp;lt;NA&amp;gt;      &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;     GPL (&amp;gt;…
##  7 abc.da… 1.0     &amp;lt;NA&amp;gt;     R (&amp;gt;= …  &amp;lt;NA&amp;gt;   &amp;lt;NA&amp;gt;      &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;     GPL (&amp;gt;…
##  8 ABC.RAP 0.9.0   &amp;lt;NA&amp;gt;     R (&amp;gt;= … &amp;quot;graph… &amp;lt;NA&amp;gt;      knitr, … &amp;lt;NA&amp;gt;     GPL-3  
##  9 abcADM  1.0     &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;    &amp;quot;Rcpp … Rcpp, BH  &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;     GPL-3  
## 10 ABCana… 1.2.1   &amp;lt;NA&amp;gt;     R (&amp;gt;= … &amp;quot;plotr… &amp;lt;NA&amp;gt;      &amp;lt;NA&amp;gt;     &amp;lt;NA&amp;gt;     GPL-3  
## # … with 16,212 more rows, and 8 more variables: license_is_foss &amp;lt;chr&amp;gt;,
## #   license_restricts_use &amp;lt;chr&amp;gt;, os_type &amp;lt;chr&amp;gt;, archs &amp;lt;chr&amp;gt;, md5sum &amp;lt;chr&amp;gt;,
## #   needscompilation &amp;lt;chr&amp;gt;, file &amp;lt;chr&amp;gt;, repository &amp;lt;chr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We only care about the packages in this table that we have already installed, so we will narrow the table down using a join.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;slimmer_frame &amp;lt;- 
  left_join(
    x = select(local_details, package, local_version, source),
    y = select(cran_pkgs, package, cran_version = version)
  ) %&amp;gt;%
  print()
## # A tibble: 369 x 4
##    package      local_version source         cran_version
##    &amp;lt;chr&amp;gt;        &amp;lt;chr&amp;gt;         &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;       
##  1 abind        1.4-5         CRAN (R 4.0.0) 1.4-5       
##  2 adagio       0.7.1         CRAN (R 4.0.0) 0.7.1       
##  3 ade4         1.7-15        CRAN (R 4.0.0) 1.7-15      
##  4 AER          1.2-9         CRAN (R 4.0.0) 1.2-9       
##  5 Amelia       1.7.6         CRAN (R 4.0.0) 1.7.6       
##  6 arrayhelpers 1.1-0         CRAN (R 4.0.0) 1.1-0       
##  7 askpass      1.1           CRAN (R 4.0.0) 1.1         
##  8 assertthat   0.2.1         CRAN (R 4.0.0) 0.2.1       
##  9 audio        0.1-7         CRAN (R 4.0.0) 0.1-7       
## 10 backports    1.1.7         CRAN (R 4.0.0) 1.1.9       
## # … with 359 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using this slimmer table, we categorize the sources of these packages and where we want to reinstall them from. Here is the basic idea: &lt;strong&gt;We want to install from Github only if our local Github version is more recent than the CRAN version.&lt;/strong&gt; This also applies when there is no version of a package on CRAN.&lt;/p&gt;
&lt;p&gt;Stated another way, we install a package from CRAN in any case that the CRAN version is more recent than the local version. This is true even if the local version was installed from Github! Remember, we don’t install from Github simply because we did so in the past. We install from Github if there is no better choice.&lt;/p&gt;
&lt;p&gt;There are edge cases to be aware of: we may find that the CRAN version of a package is behind our local version, &lt;em&gt;even if&lt;/em&gt; the local version was installed from CRAN. This happens for (at least) two reasons: if a package version was reverted on CRAN (which appeared to happen in the case of &lt;a href=&#34;https://github.com/cran/StanHeaders/commit/2294a66cb1876568b6af74a6c4a1233bf6b6e00f&#34;&gt;StanHeaders&lt;/a&gt;), or if the package is currently unavailable for installation from CRAN (due to some incompatibility, perhaps).&lt;/p&gt;
&lt;p&gt;The code below does this categorization using the &lt;code&gt;utils::compareVersion()&lt;/code&gt; function, which interprets the version numbers so we don’t have to. We do an additional step to note the Github repostory for any package that we still want to obtain from Github.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;compare_frame &amp;lt;- slimmer_frame %&amp;gt;%
  group_by(package) %&amp;gt;% 
  mutate(
    source_locale = case_when(
      compareVersion(local_version, cran_version) == 1 &amp;amp;
        str_detect(source, &amp;quot;Github&amp;quot;) ~ &amp;quot;Github&amp;quot;,
      compareVersion(local_version, cran_version) == 1 &amp;amp;
        is.na(cran_version) &amp;amp;
        str_detect(source, &amp;quot;CRAN&amp;quot;) ~ &amp;quot;Unavailable on CRAN&amp;quot;,
      compareVersion(local_version, cran_version) == 1 &amp;amp;
        (is.na(cran_version) == FALSE) &amp;amp;
        str_detect(source, &amp;quot;CRAN&amp;quot;) ~ &amp;quot;Downgraded on CRAN&amp;quot;,
      compareVersion(local_version, cran_version) %in% c(-1, 0) ~ &amp;quot;CRAN&amp;quot;
    ),
    github_repo = case_when(
      source_locale == &amp;quot;Github&amp;quot; ~ 
        str_split(string = source, pattern = &amp;quot;@&amp;quot;, simplify = TRUE)[,1] %&amp;gt;%
        str_replace(&amp;quot;Github \\(&amp;quot;, &amp;quot;&amp;quot;),
      TRUE ~ as.character(NA)
    ),
  ) %&amp;gt;%
  ungroup() %&amp;gt;%
  print()
## # A tibble: 369 x 6
##    package     local_version source       cran_version source_locale github_repo
##    &amp;lt;chr&amp;gt;       &amp;lt;chr&amp;gt;         &amp;lt;chr&amp;gt;        &amp;lt;chr&amp;gt;        &amp;lt;chr&amp;gt;         &amp;lt;chr&amp;gt;      
##  1 abind       1.4-5         CRAN (R 4.0… 1.4-5        CRAN          &amp;lt;NA&amp;gt;       
##  2 adagio      0.7.1         CRAN (R 4.0… 0.7.1        CRAN          &amp;lt;NA&amp;gt;       
##  3 ade4        1.7-15        CRAN (R 4.0… 1.7-15       CRAN          &amp;lt;NA&amp;gt;       
##  4 AER         1.2-9         CRAN (R 4.0… 1.2-9        CRAN          &amp;lt;NA&amp;gt;       
##  5 Amelia      1.7.6         CRAN (R 4.0… 1.7.6        CRAN          &amp;lt;NA&amp;gt;       
##  6 arrayhelpe… 1.1-0         CRAN (R 4.0… 1.1-0        CRAN          &amp;lt;NA&amp;gt;       
##  7 askpass     1.1           CRAN (R 4.0… 1.1          CRAN          &amp;lt;NA&amp;gt;       
##  8 assertthat  0.2.1         CRAN (R 4.0… 0.2.1        CRAN          &amp;lt;NA&amp;gt;       
##  9 audio       0.1-7         CRAN (R 4.0… 0.1-7        CRAN          &amp;lt;NA&amp;gt;       
## 10 backports   1.1.7         CRAN (R 4.0… 1.1.9        CRAN          &amp;lt;NA&amp;gt;       
## # … with 359 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;updating-r-and-reinstalling-packages&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Updating R and reinstalling packages&lt;/h1&gt;
&lt;p&gt;When we are satisfied with our decisions about where to install a package from, save this comparison table to file.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# output data location
dir.create(here(&amp;quot;data&amp;quot;))

# output file
out_file &amp;lt;- as.character(str_glue(&amp;quot;pkg-data_{Sys.Date()}.rds&amp;quot;))
write_rds(compare_frame, here(&amp;quot;data&amp;quot;, out_file))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After updating, we reopen R and install our packages according to our classifications. We want to begin by installing &lt;code&gt;{remotes}&lt;/code&gt; to enable installation from Github.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# to install from github
install.packages(&amp;quot;remotes&amp;quot;)

# should still be operating in your working directory
# so downloading {here} makes sense also
install.packages(&amp;quot;here&amp;quot;)

# read package data
pkgs &amp;lt;- readRDS(here::here(&amp;quot;data&amp;quot;, &amp;quot;pkg-data_2020-04-25.rds&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everything that we want to install from Github, we install by iterating &lt;code&gt;remotes::install_github&lt;/code&gt; over the github repository slugs that we saved previously. This requires us to write the code in “hard mode” because we aren’t using tidyverse dialect.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# install from github repos
github_pkgs &amp;lt;- pkgs[pkgs$source_locale == &amp;quot;Github&amp;quot;, ][[&amp;quot;github_repo&amp;quot;]]

remotes::install_github(github_pkgs)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, everything that we said we wouldn’t get from Github, we get by using plain ol’ &lt;code&gt;install.packages()&lt;/code&gt;. Before doing this, you may find it beneficial to filter out some of the packages that you don’t use anymore or that maybe we only installed as dependencies for other packages.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# install from cran with remaining package names
cran_pkgs &amp;lt;- pkgs[pkgs$source_locale != &amp;quot;Github&amp;quot;, ][[&amp;quot;package&amp;quot;]]

install.packages(cran_pkgs)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This should get you (more or less) up and running with R 4.0 and all of your old packages.&lt;/p&gt;
&lt;p&gt;Fair warning: I’m already getting burned by some C++ configuration problems for packages that want to compile from source. I think this is particular to my own computer and the klugey fixes I undertook to set up &lt;code&gt;{rstan}&lt;/code&gt; with MacOS Catalina. I remember reading somewhere that R 4.0 fixed some of the Stan x Catalina problems, so maybe I will confront these choices again soon, but I will cross that bridge when I get to it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;
And maybe I will do a fresh install of &lt;em&gt;everything&lt;/em&gt; once the semester is over.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Plotting What Matters</title>
      <link>/post/visualizing-what-matters/</link>
      <pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/visualizing-what-matters/</guid>
      <description>


&lt;div id=&#34;this-is-a-post-about-temptation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;This is a post about temptation&lt;/h2&gt;
&lt;p&gt;Or, resisting temptations when presenting statistical results.&lt;/p&gt;
&lt;p&gt;When you build a model to answer a question, it is often tempting to make a graphic about the &lt;em&gt;coolest thing about the model&lt;/em&gt;. Maybe you learned something new to build the model, or you noticed and corrected an important structure in the data, so naturally you want to show off your good work. The purpose of this post is to &lt;strong&gt;reflect on why this practice isn’t useful for communicating statistical results&lt;/strong&gt;. Instead, we should be communicating the information that will help the audience grasp the important takeaways of the analysis. A different focus entirely.&lt;/p&gt;
&lt;p&gt;This is almost too obvious, but it is easier said than done. Researchers wrestle with it in different ways based on our audiences, our professional goals, and (to be honest) our insecurities. Speaking for myself, I need to grapple with my biases and how they manifest in my work product. As a PhD student, I sometimes feel like academia cultivates incentives to convince our colleagues that we are Very Smart&lt;sup&gt;TM&lt;/sup&gt;, which is a distinct goal from doing good work (however defined). Cool graphics can be a way to show how much thought and work we put into something—a way of signaling that we belong. Understandable, but not always useful. I also like to use Bayesian methods, but I feel constant pressure to justify the Bayesian approach to audiences that I (rightly or wrongly) assume will be hostile to that choice. As a result, I feel tempted to plot something that would be impossible without Bayes—a way of saying, “Get off my back!” as if it ultimately mattered for what I’m trying to communicate with my analysis overall. Sometimes it does matter, but the way that it matters won’t be so simple as “just plot the flashy thing.”&lt;/p&gt;
&lt;p&gt;This post unpacks this using a recent example from a grad methods course that I am TA’ing. The assignment requires students to write a policy memo informed by a statistical analysis. The statistical model contains an important component that students are learning about in the course, but that component &lt;strong&gt;isn’t actually important to communicate in the policy memo&lt;/strong&gt;. So the assignment challenges students both on model-building but also communication skills: exercising restraint and judgment about what is and is not important to communicate about the details of the analysis.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-setting&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The setting&lt;/h2&gt;
&lt;p&gt;The assignment for students to complete lays out the following scenario.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You are an advisor to a newly elected mayor of Smallville. During the campaign, the mayor-elect charged that the Sanitation Department was being grossly mismanaged. Last year it cost &lt;span class=&#34;math inline&#34;&gt;\(\$ 48.50\)&lt;/span&gt; per household for once-a-week curbside waste pick-up. A private contractor has made an informal bid of &lt;span class=&#34;math inline&#34;&gt;\(\$ 40.60\)&lt;/span&gt; per household for collection services, but this would require eliminating Sanitation Department jobs, which would be difficult and politically costly. Before switching to private contracting, the mayor would like to know how much costs might be reduced with the appointment of a more competent Sanitation Department supervisor.&lt;/p&gt;
&lt;p&gt;Prepare a memorandum to the mayor advising her about the potential gains from better management. The mayor has had little statistical training, so be sure to explain your empirical work clearly and carefully.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Students are given a dataset of 30 other municipalities in the region, simulated from a model that they don’t directly see.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 30 x 5
##    hholds density  wage snowdays cost_per_household
##     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;              &amp;lt;dbl&amp;gt;
##  1   3.35    565.  18.2        3               29.4
##  2  11.2     740.  15.7       10               52.0
##  3   9.48    540.  17.4        3               34.4
##  4   9.43    629.  19.6        1               41.5
##  5  11.3     685.  20.6        6               63.4
##  6   6.18    605.  20.2        6               30.0
##  7   2.82    510.  16.5        4               20.8
##  8   2.95    459.  15.8        2               12.9
##  9   6.98    507.  16.5        3               21.8
## 10   7.89    524.  19.9        2               37.8
## # … with 20 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variables are described as follows.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cost_per_household&lt;/code&gt;: cost per household (&lt;span class=&#34;math inline&#34;&gt;\(\$\)&lt;/span&gt; U.S.) of once weekly curbside refuse pickup for last year.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hholds&lt;/code&gt;: number of households served in 10,000s. &lt;strong&gt;(Note: previous studies suggest refuse collection may involve non-constant returns to scale; that is, there may be some number of households at which the cost per household is minimized; communities with smaller or larger numbers of households have higher costs per household.)&lt;/strong&gt; Value for your city: 6.28.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;density&lt;/code&gt;: density of households per square mile. Value for your city: 620.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wage&lt;/code&gt;: average hourly wage in dollars for collection workers. Value for your city: 19.50.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snowdays&lt;/code&gt;: number of snow emergency days last year; may raise costs by interfering with regular schedule. Value for your city: 5.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;So what’s the objective?&lt;/strong&gt; Students are supposed to use the data to build a predictive (OLS) model for &lt;code&gt;cost_per_household&lt;/code&gt;, and then interpret the model to advise the mayor about the choice between (a) enlisting the private sanitation contractor or (b) replacing the supervisor of the Sanitation Department.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;source-of-temptation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Source of temptation&lt;/h2&gt;
&lt;p&gt;Students typically begin with a simple model where every variable is linearly related to the outcome variable…
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  \mathtt{cost\_per\_household}_{i} &amp;amp;= 
    \alpha + 
    \beta_{1} \mathtt{hholds} +
    \beta_{2} \mathtt{density} \\
  &amp;amp; \quad 
    + \beta_{3} \mathtt{wage} +
    \beta_{4} \mathtt{snowdays} +
    \varepsilon_{i}
\end{align}\]&lt;/span&gt;
…with a normally distributed error. But they should find that the simple model violates OLS assumptions by producing residuals with a curvilinear pattern. If students inspect the data more, they detect that the likely culprit is the &lt;code&gt;hholds&lt;/code&gt; variable, the number of households in the municipality. This is consistent with the hint in the variable descriptions above, that there may be some number of households that minimize sanitation costs per household. So they build a model with a quadratic term for &lt;code&gt;hholds&lt;/code&gt;.
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  \mathtt{cost\_per\_household}_{i} &amp;amp;= 
    \alpha + 
    \beta_{1} \mathtt{hholds} +
    \beta_{2} \mathtt{hholds}^{2} +
    \beta_{3} \mathtt{density} \\
  &amp;amp; \quad 
    + \beta_{4} \mathtt{wage} +
    \beta_{5} \mathtt{snowdays} +
    \varepsilon_{i}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;For the purposes of the assignment, this is the “correct” model, and the residuals look better than they did before (see below).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/vizualizing-what-matters/index_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;80%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now that we have the appropriate model, how do we visualize it? I’ll tell you what I did when I was a student in this course (many years ago): I plotted the nonlinear relationship between the number of households and the outcome variable. It the most interesting part of the model, and it was hidden in the data…how could it not be the important thing that I should focus on? I think I did something like this: generate model predictions with other variables fixed at their means, and then plot those model predictions alongside my city’s data (Smallville) and the private contractor’s proposal for reducing the curbside pickup costs per household.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/vizualizing-what-matters/index_files/figure-html/wrong-plot-1.png&#34; width=&#34;90%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;From this graphic, we could reason that even if we enlist the private contractor, their bid does not get us close to what we would expect from the model. This leads us the direction of saying that maybe we expect more savings from better mismanagement of the Sanitation Department than what the current supervisor is delivering.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;disciplined-plotting-choices&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Disciplined plotting choices&lt;/h2&gt;
&lt;p&gt;There are a few things that are misguided about the above approach.&lt;/p&gt;
&lt;p&gt;First, the comparison in this above graphic isn’t actually the relevant comparison. It is typical to teach students to visualize partial relationships in regression by varying one predictor and fixing other predictors to their means. But we don’t always want to compare against a typical observation. In this example, we would be more interested in holding covariates to the same values as we observe for our city. Applied situations like this remind us that many of the problems that we encounter aren’t questions about “typical” observations at all.&lt;/p&gt;
&lt;p&gt;Second, and more importantly, the only reason why we make the previous mistake is because we think that the quadratic relationship is the important thing to visualize. It’s understandable that we’re distracted by the quadratic relationship because it was initially a challenge to discover, but if we discipline ourselves about what is important to communicate to our audience (in this case, the mayor of “Smallville”), we would see that the nonlinearity is irrelevant to visualize. All that matters is comparing our city’s data and the contractor’s proposal to a specific model-based prediction for our city. Exploring how the prediction changes as we arbitrarily assign other values on key covariates doesn’t help us make a policy recommendation. We aren’t in a position to intervene on those variables (and we aren’t confident that our model identifies causal effects anyway), so we shouldn’t distract the mayor by presenting irrelevant information that draws focus away from the key insights.&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;What is a simpler way to show the model’s key takeaway? Here.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/vizualizing-what-matters/index_files/figure-html/plot-smallville-1.png&#34; width=&#34;100%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The takeaway from this figure is similar as it was above. We show a model-based prediction for a city with the same observable characteristics as Smallville (a point estimate, 95% confidence interval, and 95% prediction interval) alongside Smallville’s current costs and the contractor’s proposal.&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;
We see that the contractor’s proposal reduces sanitation costs, but they still get us nowhere near a level that we should expect given the characteristics of our city. If we are confident that replacing the Sanitation Department supervisor would make our costs “representative” of other similar towns, we would save a lot more money by replacing the supervisor than we would by hiring the contractor.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;we-can-do-better-visualize-cost-savings-directly&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;We can do better: visualize cost-savings directly&lt;/h2&gt;
&lt;p&gt;Even though the above graphic does a little better than what we were working with before, it still doesn’t directly communicate the aggregate financial impact of the policy. The audience has to do that work on their own still. If we really wanted to communicate the insights of the model, we could translate these predictions directly into something that mayors, comptrollers, and so on really understand: dollars.&lt;/p&gt;
&lt;p&gt;Here’s the idea. In terms of annual cost cost-per-household, we know our city’s current value, the contractor’s bid, and a distribution of model-based estimates for a city with our data. We also know the total number of households in our city, so it is straightforward to calculate the total costs from each of these per-household figures:
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  \text{Total annual cost} &amp;amp;= \text{Cost per household} \times \text{Number of households}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;So we calculate annual costs for the current per-household rate, the contractor’s bid, and three model-based scenarios&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;
that result from replacing the Sanitation Dept. supervisor:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An “average” scenario: plugging in the point estimate from the model as the annual cost per household under a new supervisor.&lt;/li&gt;
&lt;li&gt;An “optimistic” scenario: plugging in the 10th percentile of the predictive distribution as the estimated cost per household.&lt;/li&gt;
&lt;li&gt;A “pessimistic” scenario: plugging in the 90th percentile of the predictive distribution as the annual cost per household.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We plot two quantities for each scenario. First, how much money is saved annually by replacing the supervisor brings pickup costs to each of these benchmarks? And second, how much &lt;em&gt;more&lt;/em&gt; does each benchmark save us when we compare to the private contractor’s bid?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/vizualizing-what-matters/index_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;100%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The comparison against the contractor bid isn’t just for show! It gives decision-makers valuable information because it represents a “budget” for replacing the supervisor. How so? Replacing the supervisor wouldn’t be costless: the replacement may require a higher salary than the current supervisor, and the job search will involve some fixed costs. Comparing each scenario’s savings to the amount saved from the enlisting the contractor conveys how much money we can &lt;em&gt;invest&lt;/em&gt; in a new supervisor while still saving more money than hiring the contractor. Visualizing the results this way shows exactly how much money we’re working with and how much we stand to save by hiring supervisors with different salary expectations.&lt;/p&gt;
&lt;p&gt;By doing some further processing of the model’s insights, and in-turn moving &lt;em&gt;farther&lt;/em&gt; from the technical details of the model, we actually learn more about the consequences of our choices. We see that even under the pessimistic cost-savings scenario, we still have a roughly half-million dollar cushion before the decision to replace the supervisor starts to look like the wrong choice.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;reframing-what-to-be-proud-of&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Reframing what to be “proud” of&lt;/h2&gt;
&lt;p&gt;We feel proud when we build a technologically complex model. It makes us feel valuable when we work through something challenging, so we want to show it off. When we need to hide these technical details in order to communicate the results to non-experts, the choice is painful at first, especially for someone like me who takes a lot of pride in the time and effort that I invest in improving my statistical skills. This is a psychological game that we are playing with ourselves.&lt;/p&gt;
&lt;p&gt;But the “difficulty-level” of our work isn’t the only skill to take pride in. Distilling essential information out of a complicated piece of machinery is valuable, and we can see it as a distinct source of pride when we do it well. Better still, doing an effective job summarizing the important takeaways of an analysis makes it all the more rewarding to describe the technical backend, since the technical backend has a much stronger clarity-of-purpose after if is introduced effectively.&lt;/p&gt;
&lt;p&gt;Just to drive the point home, that last graph was a bar graph. I kinda hate bar graphs. But I don’t hate the fact that I recognized a context where it made something simpler to communicate. That’s valuable.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;
At this point you may wonder if we can intervene on the system by reducing the wages of sanitation workers to make up the cost difference. First of all, how dare you. Secondly, even though we know that lowering wages should have a causal effect on pickup costs, we don’t know that the coefficient for &lt;code&gt;wage&lt;/code&gt; in the model represents the causal effect of wages—certainly it doesn’t. Third, even if we could make that assumption, the numerical impact of decreasing sanitation worker wages to (say) the median wage for other cities would amount to only $5.54 saved per household, so we save even less than we would save from hiring the contractor.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;
The language used in the graphic (“95% range of predictions”) is doing a little violence against the meaning of a frequentist confidence interval. If I were implementing this analysis in real life, I would build a Bayesian model that lets me say, “This is the likely range of scenarios, as the data suggest,” because that’s conveniently what a posterior distribution actually means!&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;
Once again, interpreting the prediction interval as “possible scenarios” is more closely tied to Bayes than to a frequentist model. The more I think about the value of communicating model predictions as “possible scenarios,” the more I think this warrants its own blog post. &lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Purrrmutation Testing</title>
      <link>/post/randomization-inference-purrr/</link>
      <pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/randomization-inference-purrr/</guid>
      <description>


&lt;div id=&#34;overview&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Overview&lt;/h1&gt;
&lt;p&gt;Permutation testing (or “randomization inference,” RI) is an approach to statistical inference based on hypothetical allocations of treatment rather than sampling error. It has an appealing intuition, but researchers may feel intimidated by the prospect of implementing it computationally. Although helpful packages exist for conducting permutation tests in R,&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;
my goal for this post is to show that &lt;code&gt;tidyverse&lt;/code&gt; tools (in particular, functional programming with &lt;code&gt;purrr&lt;/code&gt;) make it easy to implement randomization inference in R flexibly and efficiently.&lt;/p&gt;
&lt;p&gt;Below I provide a brief overview of RI’s logic, implement a simple permutation test for a single treatment, and then demonstrate how to incorporate additional design features such as blocking or clustered randomization into the workflow. We will see that many of these design features are easily translated into &lt;code&gt;tidyverse&lt;/code&gt; dialect without warping or overextending the workflow into something unrecognizable or impractical.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;what-is-randomization-inference&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;What is Randomization Inference&lt;/h1&gt;
&lt;p&gt;Randomization inference is a method for conducting statistical hypothesis tests without making distributional assumptions about test statistics. Like all null hypothesis tests, it is a comparison between (1) an estimated effect or relationship from observed data and (2) a “null distribution” of estimates that we might have observed if the null hypothesis were true. Unlike traditional null hypothesis tests, however, the null distribution is not based on repeated sampling of a hypothetical population. Instead, it is constructed by imagining &lt;em&gt;other ways that treatment may have been randomly allocated&lt;/em&gt; among units.&lt;/p&gt;
&lt;p&gt;For instance, suppose we had some small sample of data for &lt;span class=&#34;math inline&#34;&gt;\(n = 6\)&lt;/span&gt; units. We randomly assign half of the units to treatment and half to control:&lt;/p&gt;
&lt;!-- centering this table --&gt;
&lt;center&gt;
&lt;table style=&#34;width:40%;&#34;&gt;
&lt;colgroup&gt;
&lt;col width=&#34;6%&#34; /&gt;
&lt;col width=&#34;16%&#34; /&gt;
&lt;col width=&#34;16%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;center&#34;&gt;ID&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Treatment&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Outcome&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(Y_1\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(Y_2\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(Y_3\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(Y_4\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(Y_5\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;span class=&#34;math inline&#34;&gt;\(Y_6\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/center&gt;
&lt;p&gt;We could use this data to calculate some difference in means &lt;span class=&#34;math inline&#34;&gt;\(\hat{\delta} = \bar{Y}_{1} - \bar{Y}_{0}\)&lt;/span&gt;. How do we form an inference about &lt;span class=&#34;math inline&#34;&gt;\(\delta\)&lt;/span&gt; from &lt;span class=&#34;math inline&#34;&gt;\(\hat{\delta}\)&lt;/span&gt;? Typically we would standardize &lt;span class=&#34;math inline&#34;&gt;\(\hat{\delta}\)&lt;/span&gt; and compare it against a &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution, finding a &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-value that represents “the probability of obtaining some other &lt;span class=&#34;math inline&#34;&gt;\(\hat{\delta}&amp;#39;\)&lt;/span&gt; at least as extreme as &lt;span class=&#34;math inline&#34;&gt;\(\hat{\delta}\)&lt;/span&gt;, under the null hypothesis that the true &lt;span class=&#34;math inline&#34;&gt;\(\delta\)&lt;/span&gt; is zero.” Under this approach, this &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;-distribution serves as our “null distribution,” the sampling distribution of estimates that we would obtain assuming that the null is true.&lt;/p&gt;
&lt;p&gt;Randomization inference constructs this null distribution using a different method. Instead of making the parametric assumption that the standardized &lt;span class=&#34;math inline&#34;&gt;\(\hat{\delta}\)&lt;/span&gt; follows a &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; distribution, we take advantage of random assignment in the research design, constructing a null distribution of treatment effect estimates by &lt;em&gt;repeatedly permuting the treatment assignments&lt;/em&gt; for our units. For example, the treatment vector in the small sample of data above was &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{T} = \left[0, 0, 1, 1, 1, 0\right]\)&lt;/span&gt;, but we could have obtained a different treatment vector by random chance alone. We could have randomly realized treatment assignments as &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{T}&amp;#39; = \left[0, 0, 1, 0, 1, 1\right]\)&lt;/span&gt;, or &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{T}&amp;#39; = \left[1, 1, 1, 0, 0, 0\right]\)&lt;/span&gt;. Imagine that in each of these alternate treatment assignments, we estimate the treatment effect &lt;span class=&#34;math inline&#34;&gt;\(\hat{\delta}\)&lt;/span&gt;. Under the null hypothesis, outcomes are not affected (on average) by treatment assignment, so each &lt;span class=&#34;math inline&#34;&gt;\(\hat{\delta}\)&lt;/span&gt; that we estimate under the permuted treatment assignments a draw from the “null distribution” of &lt;span class=&#34;math inline&#34;&gt;\(\hat{\delta}\)&lt;/span&gt;. If we could specify every possible treatment assignment, we would have a full accounting of every equally-likely null &lt;span class=&#34;math inline&#34;&gt;\(\hat{\delta}\)&lt;/span&gt; estimate under the research design. This would let us calculate an “exact” &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-value by comparing our in-sample estimate to the null distribution: the proportion of null estimates that are more extreme than the estimate obtained in our real data. These &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-values are valid even in nonrandom samples because they operate by &lt;em&gt;design uncertainty&lt;/em&gt; instead of sampling uncertainty.&lt;/p&gt;
&lt;p&gt;More formally, suppose that random variable &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; is a test statistic that is a function of &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{T}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{Y}\)&lt;/span&gt;, vectors of treatment assignments and outcome data respectively (&lt;a href=&#34;https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.1540-5907.2011.00576.x?casa_token=YjkCBZcxieAAAAAA:-WVWyv9NfA_83dsFCKLYjofLTVBEKehe0cG3a3na-7OQhSQrURDVGsjgeKwHSv6KI5jrXpmNV5Bog9A&#34;&gt;Keele, McConnaughy, and White&lt;/a&gt;). A &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-value is the probability that &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt; exceeds the test statistic calculated from your data, &lt;span class=&#34;math inline&#34;&gt;\(s^{*}\)&lt;/span&gt;, given the null distribution of &lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt;.
&lt;span class=&#34;math display&#34; id=&#34;eq:theoretical-p&#34;&gt;\[\begin{align}
  p &amp;amp;= \mathrm{Pr}\left(S ≥ s^{*} | H_{0}\right) %*
  \tag{1}
\end{align}\]&lt;/span&gt;
A permutation test finds this &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-value by calculating the test statistic for your sample of data, &lt;span class=&#34;math inline&#34;&gt;\(s^{*}\)&lt;/span&gt;, as well as test statistics &lt;span class=&#34;math inline&#34;&gt;\(s_{m}\)&lt;/span&gt; for &lt;span class=&#34;math inline&#34;&gt;\(m \in \mathcal{M}\)&lt;/span&gt;, treatment permutations from the set of possible treatment permutations. The &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-value in the permutation test is the proportion of permuted test statistics that exceed the in-sample test statistic.
&lt;span class=&#34;math display&#34; id=&#34;eq:permute-p&#34;&gt;\[\begin{align}
  p &amp;amp;= \frac{\sum\limits_{m = 1}^{M} I(s_{m} &amp;gt; s^{*})}{M}
  \tag{2}
\end{align}\]&lt;/span&gt;
where &lt;span class=&#34;math inline&#34;&gt;\(I(\cdot)\)&lt;/span&gt; is the indicator function and &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; is the number of permutations being considered. If &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; is equal to the total number of possible permutations, this &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-value is exact. If the set of permutations &lt;span class=&#34;math inline&#34;&gt;\(\mathcal{M}\)&lt;/span&gt; is too large to calculate every &lt;span class=&#34;math inline&#34;&gt;\(s_{m}\)&lt;/span&gt; (which is likely for even moderate samples sizes), sampling a subset of &lt;span class=&#34;math inline&#34;&gt;\(M &amp;lt; |\mathcal{M}|\)&lt;/span&gt; permutations lets you treat Equation &lt;a href=&#34;#eq:permute-p&#34;&gt;(2)&lt;/a&gt; as an approximation of the &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-value.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;TLDR&lt;/em&gt;&lt;/strong&gt;, how do we perform randomization inference?&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Estimate the treatment effect in our sample&lt;/li&gt;
&lt;li&gt;Compute or approximate the null distribution of the treatment effect estimate under repeated reallocations of treatment to units (conditional on the sample)&lt;/li&gt;
&lt;li&gt;Compare the in-sample estimate to its null distribution&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;randomization-inference-for-a-simple-experiment&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Randomization Inference for a Simple Experiment&lt;/h1&gt;
&lt;p&gt;This section shows how to implement permutation tests for a simple experiment with a binary treatment and binary outcome. First I describe the model used to generate data, and then we perform a permutation test using the generated data.&lt;/p&gt;
&lt;div id=&#34;data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data&lt;/h2&gt;
&lt;p&gt;We will use various tools in the &lt;code&gt;tidyverse&lt;/code&gt;, so for now that is the only package we will load.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;tidyverse&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I simulate a dataset of &lt;span class=&#34;math inline&#34;&gt;\(n = 500\)&lt;/span&gt; units with outcome variable &lt;span class=&#34;math inline&#34;&gt;\(y_{i} \in \left\{0, 1\right\}\)&lt;/span&gt;, treatment status &lt;span class=&#34;math inline&#34;&gt;\(z_{i} \in \left\{0, 1\right\}\)&lt;/span&gt;, treatment probability &lt;span class=&#34;math inline&#34;&gt;\(0.5\)&lt;/span&gt;. The generative model can be represented as follows:
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  y_{i} &amp;amp;\sim \mathrm{Bernoulli}\left(0.5 + \delta z_{i}\right) \\
  z_{i} &amp;amp;\sim \mathrm{Bernoulli}\left(0.5 \right)
\end{align}\]&lt;/span&gt;
where the treatment effect &lt;span class=&#34;math inline&#34;&gt;\(\delta\)&lt;/span&gt; has a true value of &lt;span class=&#34;math inline&#34;&gt;\(0.06\)&lt;/span&gt;. In R, I generate the data like so:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(90181)

n_obs &amp;lt;- 500
control_mean &amp;lt;- 0.5
treat_effect &amp;lt;- .06

d &amp;lt;- 
  tibble(id = 1:n_obs) %&amp;gt;%
  mutate(
    treatment = rbernoulli(n = n(), p = 0.5) %&amp;gt;% as.numeric(),
    y = rbernoulli(n = n(), p = control_mean + (treatment * treat_effect)) %&amp;gt;%
        as.numeric()
  ) %&amp;gt;%
  print()
## # A tibble: 500 x 3
##       id treatment     y
##    &amp;lt;int&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1     1         1     1
##  2     2         0     0
##  3     3         0     0
##  4     4         1     1
##  5     5         1     1
##  6     6         1     1
##  7     7         0     0
##  8     8         0     1
##  9     9         0     1
## 10    10         0     1
## # … with 490 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The data are a random draw from the generative model, so the treatment effect in the data won’t be exactly equal to the true effect. In these data, we estimate an in-sample treatment effect of about 0.05. We will want to save a data frame of in-sample estimates.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;observed_estimates &amp;lt;- d %&amp;gt;%
  summarize(
    mean_control = mean(y[treatment == 0]),
    mean_treatment = mean(y[treatment == 1]),
    diff_means = mean_treatment - mean_control
  ) %&amp;gt;%
  print()
## # A tibble: 1 x 3
##   mean_control mean_treatment diff_means
##          &amp;lt;dbl&amp;gt;          &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1        0.514          0.563     0.0495&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;permuting-treatment-assignments-tidily&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Permuting treatment assignments, tidily&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;tidyverse&lt;/code&gt; advantage comes in when we permute the treatment assignments. Ordinarily we might think about permuting treatment assignments using a for loop—for each iteration &lt;code&gt;m&lt;/code&gt; in &lt;code&gt;1:M&lt;/code&gt;, reshuffle the treatment assignments and calculate &lt;span class=&#34;math inline&#34;&gt;\(\hat{\delta}_{\mathtt{m}}\)&lt;/span&gt;. Except we want to avoid a for loop because…&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;For loops in R are famously slow.&lt;/li&gt;
&lt;li&gt;For loops in R are rarely necessary. For many common data wrangling problems, iteration &lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt; does not depend on iteration &lt;span class=&#34;math inline&#34;&gt;\(m-1\)&lt;/span&gt;, so a vectorized approach is usually more efficient.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A technical but important workflow point&lt;/strong&gt;: the data structure that results from a loop (usually a vector or a list) often throws away useful information, and it can be &lt;em&gt;organizationally idiosyncratic&lt;/em&gt; if the rest of our work is data frame-driven. If we can do this routine using a more capable data structure and extensible workflow, we have the potential to do more cool things while staying organized along the way.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We deal with points (1) and (2) by using functional programming: applying a function over groups of data (see &lt;a href=&#34;http://adv-r.had.co.nz/Functional-programming.html&#34;&gt;here&lt;/a&gt; for instance). In our case, a &lt;em&gt;group&lt;/em&gt; will be a data frame, and the &lt;em&gt;function&lt;/em&gt; is permuting the treatment assignments and estimating the treatment effect. We address point (3) by doing everything with a &lt;em&gt;nested data frame&lt;/em&gt; and applying functions to groups using &lt;code&gt;purrr::map()&lt;/code&gt;. I will describe the approach below one step at a time. After each step is explained, I will show how simple it is to combine them into a small, efficient block of readable code.&lt;/p&gt;
&lt;p&gt;The first step is to make a nested data frame: a data frame that itself contains data frames (see e.g. &lt;a href=&#34;https://blog.rstudio.com/2016/02/02/tidyr-0-4-0/&#34;&gt;[1]&lt;/a&gt;, &lt;a href=&#34;https://r4ds.had.co.nz/many-models.html&#34;&gt;[2]&lt;/a&gt;, &lt;a href=&#34;https://cran.r-project.org/web/packages/tidyr/vignettes/nest.html&#34;&gt;[3]&lt;/a&gt;). Here I create a data frame with two columns: an identifier &lt;code&gt;m&lt;/code&gt; that indexes our treatment permutations, and a data column that contains copies of our original dataset for each &lt;code&gt;m&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# total number of iterations
n_sims &amp;lt;- 2000

# nested data frame of all M iterations
sim_table &amp;lt;- d %&amp;gt;%
  crossing(m = 1:n_sims) %&amp;gt;%
  group_by(m) %&amp;gt;%
  nest() %&amp;gt;%
  print()
## # A tibble: 2,000 x 2
## # Groups:   m [2,000]
##        m data              
##    &amp;lt;int&amp;gt; &amp;lt;list&amp;gt;            
##  1     1 &amp;lt;tibble [500 × 3]&amp;gt;
##  2     2 &amp;lt;tibble [500 × 3]&amp;gt;
##  3     3 &amp;lt;tibble [500 × 3]&amp;gt;
##  4     4 &amp;lt;tibble [500 × 3]&amp;gt;
##  5     5 &amp;lt;tibble [500 × 3]&amp;gt;
##  6     6 &amp;lt;tibble [500 × 3]&amp;gt;
##  7     7 &amp;lt;tibble [500 × 3]&amp;gt;
##  8     8 &amp;lt;tibble [500 × 3]&amp;gt;
##  9     9 &amp;lt;tibble [500 × 3]&amp;gt;
## 10    10 &amp;lt;tibble [500 × 3]&amp;gt;
## # … with 1,990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;data&lt;/code&gt; column is a &lt;em&gt;list column&lt;/em&gt;, in this case a list of data frames for each row &lt;code&gt;m&lt;/code&gt; (but it could contain other object types if we wanted). List columns are powerful for large-scale data manipulation because we can apply functions over each element in the list, similar to the way &lt;code&gt;apply()&lt;/code&gt; functions work in base R. In our case, we want to apply a function that permutes the values in the &lt;code&gt;treatment&lt;/code&gt; variable. We map this function over the nested data using &lt;code&gt;purrr::map()&lt;/code&gt;, creating a new list column of data frames.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;perm_table &amp;lt;- sim_table %&amp;gt;%
  mutate(
    permuted_data = map(
      .x = data, 
      .f = mutate, 
      treatment = sample(treatment)
    )
  ) %&amp;gt;%
  print()
## # A tibble: 2,000 x 3
## # Groups:   m [2,000]
##        m data               permuted_data     
##    &amp;lt;int&amp;gt; &amp;lt;list&amp;gt;             &amp;lt;list&amp;gt;            
##  1     1 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt;
##  2     2 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt;
##  3     3 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt;
##  4     4 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt;
##  5     5 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt;
##  6     6 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt;
##  7     7 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt;
##  8     8 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt;
##  9     9 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt;
## 10    10 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt;
## # … with 1,990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are new to &lt;code&gt;purrr::map()&lt;/code&gt;, it needs to know two things: a vector or list column &lt;code&gt;.x&lt;/code&gt;, and a function &lt;code&gt;.f&lt;/code&gt; that is applied to each element in &lt;code&gt;.x&lt;/code&gt;. In this case, &lt;code&gt;.x&lt;/code&gt; is a list of data frames, and the function we apply is &lt;code&gt;mutate()&lt;/code&gt;, which creates/modifies variables. We supply the additional function argument saying that we are overwriting the &lt;code&gt;treatment&lt;/code&gt; variable by sampling its current values without replacement. This adds a list-column of 2,000 new data frames, each with a different permutation of treatment assignments. In case you need convincing, here is a table that glimpses the treatment assignments for a subset of &lt;code&gt;m&lt;/code&gt; values.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;perm_table %&amp;gt;%
  ungroup() %&amp;gt;%
  sample_n(5) %&amp;gt;%
  unnest(permuted_data) %&amp;gt;%
  select(m, id, treatment) %&amp;gt;%
  pivot_wider(
    names_from = m, 
    values_from = treatment,
    names_prefix = &amp;quot;trt, m = &amp;quot;
  )
## # A tibble: 500 x 6
##       id `trt, m = 561` `trt, m = 1471` `trt, m = 1325` `trt, m = 844`
##    &amp;lt;int&amp;gt;          &amp;lt;dbl&amp;gt;           &amp;lt;dbl&amp;gt;           &amp;lt;dbl&amp;gt;          &amp;lt;dbl&amp;gt;
##  1     1              0               0               0              1
##  2     2              0               1               1              0
##  3     3              1               0               1              1
##  4     4              0               1               1              1
##  5     5              1               0               1              1
##  6     6              0               0               1              0
##  7     7              0               0               1              1
##  8     8              1               0               1              1
##  9     9              1               1               0              1
## 10    10              0               0               1              1
## # … with 490 more rows, and 1 more variable: `trt, m = 943` &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have datasets with permuted treatments, we calculate some test statistic in each iteration. I will calculate the difference between the treatment and control means, but other statistics are possible as well.&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;
We again do this with &lt;code&gt;map()&lt;/code&gt;, this time applying the &lt;code&gt;summarize()&lt;/code&gt; function to calculate the treatment mean, the control mean, and the difference.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;est_table &amp;lt;- perm_table %&amp;gt;%
  mutate(
    estimates = map(
      .x = permuted_data,
      .f = summarize, 
      mean_treatment_m = mean(y[treatment == 1]),
      mean_control_m = mean(y[treatment == 0]),
      diff_means_m = mean_treatment_m - mean_control_m
    )
  ) %&amp;gt;%
  print()
## # A tibble: 2,000 x 4
## # Groups:   m [2,000]
##        m data               permuted_data      estimates       
##    &amp;lt;int&amp;gt; &amp;lt;list&amp;gt;             &amp;lt;list&amp;gt;             &amp;lt;list&amp;gt;          
##  1     1 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  2     2 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  3     3 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  4     4 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  5     5 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  6     6 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  7     7 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  8     8 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  9     9 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
## 10    10 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
## # … with 1,990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can view the estimates in each iteration by unnesting the &lt;code&gt;estimates&lt;/code&gt; column…&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;est_summary &amp;lt;- est_table %&amp;gt;%
  select(m, estimates) %&amp;gt;%
  unnest(cols = estimates) %&amp;gt;%
  ungroup() %&amp;gt;%
  print()
## # A tibble: 2,000 x 4
##        m mean_treatment_m mean_control_m diff_means_m
##    &amp;lt;int&amp;gt;            &amp;lt;dbl&amp;gt;          &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;
##  1     1            0.563          0.514      0.0495 
##  2     2            0.539          0.537      0.00152
##  3     3            0.563          0.514      0.0495 
##  4     4            0.535          0.541     -0.00648
##  5     5            0.551          0.525      0.0255 
##  6     6            0.567          0.510      0.0575 
##  7     7            0.490          0.584     -0.0945 
##  8     8            0.535          0.541     -0.00648
##  9     9            0.518          0.557     -0.0385 
## 10    10            0.588          0.490      0.0976 
## # … with 1,990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can calculate our &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-value by comparing our sample estimate to the null distribution…&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pval &amp;lt;- est_summary %&amp;gt;%
  summarize(
    p.value = mean(abs(diff_means_m) &amp;gt; abs(observed_estimates$diff_means))
  ) %&amp;gt;%
  pull(p.value) %&amp;gt;%
  print()
## [1] 0.2515&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and we can plot our estimate against the null distribution. In our case, 25% of estimates from the null distribution exceed our in-sample estimate in magnitude, so we would not reject a null hypothesis in this setting.&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/purrrmutation-tests/index_files/figure-html/compare-null-1.png&#34; width=&#34;80%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;putting-it-all-together&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Putting it all together&lt;/h2&gt;
&lt;p&gt;In practice, we would not tediously create lots of objects to trace our method every step of the way. Instead, we could build our nested data frame, permute the treatment assignments, and estimate null treatment effects in one continuous operation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# nested data, permute, estimate.
# bonus: permuted_data demos the &amp;quot;quosure-style lambda function&amp;quot; syntax 
ri_data &amp;lt;- d %&amp;gt;%
  crossing(m = 1:n_sims) %&amp;gt;%
  group_by(m) %&amp;gt;%
  nest() %&amp;gt;%
  mutate(
    permuted_data = map(
      .x = data, 
      .f = ~ mutate(.x, treatment = sample(treatment))
    ),
    estimates = map(
      .x = permuted_data,
      .f = summarize,
      mean_treatment_m = mean(y[treatment == 1]),
      mean_control_m = mean(y[treatment == 0]),
      diff_means_m = mean_treatment_m - mean_control_m
    )
  ) %&amp;gt;%
  print()
## # A tibble: 2,000 x 4
## # Groups:   m [2,000]
##        m data               permuted_data      estimates       
##    &amp;lt;int&amp;gt; &amp;lt;list&amp;gt;             &amp;lt;list&amp;gt;             &amp;lt;list&amp;gt;          
##  1     1 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  2     2 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  3     3 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  4     4 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  5     5 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  6     6 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  7     7 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  8     8 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
##  9     9 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
## 10    10 &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [500 × 3]&amp;gt; &amp;lt;tibble [1 × 3]&amp;gt;
## # … with 1,990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;extensibility-of-the-tidy-approach&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Extensibility of the Tidy Approach&lt;/h1&gt;
&lt;p&gt;We’ve seen that using &lt;code&gt;purrr::map()&lt;/code&gt; lets us push around a &lt;em&gt;lot&lt;/em&gt; of data with little code. Yet the &lt;code&gt;purrr&lt;/code&gt; approach is still more verbose than other approaches that we might have used (see Thomas Leeper’s use of &lt;code&gt;replicate()&lt;/code&gt; and &lt;code&gt;by()&lt;/code&gt; &lt;a href=&#34;https://thomasleeper.com/Rcourse/Tutorials/permutationtests.html&#34;&gt;here&lt;/a&gt;). Why would we use the tidy approach if slimmer methods exist? For one, it is eminently extensible. By keeping the fruits of your work together in one data frame, it is easy to adapt the workflow to incorporate other quantities of interest and research design features while keeping your work organized. This section will take a quick tour of how easy it is to (1) calculate confidence intervals and permute data from (2) multiple treatments, (3) cluster randomization, and (4) block-randomization.&lt;/p&gt;
&lt;div id=&#34;confidence-intervals&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Confidence Intervals&lt;/h3&gt;
&lt;p&gt;So far we have entertained a generative model where (1) treatment has a constant, additive effect &lt;span class=&#34;math inline&#34;&gt;\(\delta\)&lt;/span&gt; on unit-level response and (2) a null hypothesis that &lt;span class=&#34;math inline&#34;&gt;\(\delta = 0\)&lt;/span&gt;.&lt;a href=&#34;#fn4&#34; class=&#34;footnote-ref&#34; id=&#34;fnref4&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;
If we entertain null hypothesis values for &lt;span class=&#34;math inline&#34;&gt;\(\delta\)&lt;/span&gt; other than strictly zero, we can construct a &lt;span class=&#34;math inline&#34;&gt;\(100 - \alpha\)&lt;/span&gt; confidence region as &lt;em&gt;the values of &lt;span class=&#34;math inline&#34;&gt;\(\delta\)&lt;/span&gt; for which we cannot reject the null hypothesis&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We do this as follows. For a null value of &lt;span class=&#34;math inline&#34;&gt;\(\delta_{0}\)&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adjust the in-sample test statistic by subtracting &lt;span class=&#34;math inline&#34;&gt;\(\delta_{0}\)&lt;/span&gt; from the difference in means. This is similar to the way we would subtract the null value from a standard &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt;-test &lt;span class=&#34;math inline&#34;&gt;\(\left(\frac{\hat{\mu} - \mu_{0}}{\sigma}\right)\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Calculate the &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; value for this adjusted &lt;span class=&#34;math inline&#34;&gt;\(\hat{\delta}\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;If &lt;span class=&#34;math inline&#34;&gt;\(p &amp;lt; \frac{\alpha}{2}\)&lt;/span&gt;, we reject the null hypothesis that &lt;span class=&#34;math inline&#34;&gt;\(\delta = \delta_0\)&lt;/span&gt;, meaning the value &lt;span class=&#34;math inline&#34;&gt;\(\delta_{0}\)&lt;/span&gt; is &lt;em&gt;not&lt;/em&gt; contained in the confidence interval.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can implement this routine by augmenting our data structure with a sequence of null values and performing the appropriate adjustments.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# for each m x delta_0, adjust the test statistic
# for each delta_0, calculate p-value 
conf_table &amp;lt;- ri_data %&amp;gt;%
  select(m, estimates) %&amp;gt;%
  unnest(estimates) %&amp;gt;%
  crossing(null_value = seq(-0.2, 0.2, .01)) %&amp;gt;%
  mutate(test_value = observed_estimates$diff_means - null_value) %&amp;gt;%
  group_by(null_value) %&amp;gt;%
  summarize(
    p.value = mean(diff_means_m &amp;gt; abs(test_value))
  ) %&amp;gt;%
  print()
## # A tibble: 41 x 2
##    null_value p.value
##         &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
##  1      -0.2        0
##  2      -0.19       0
##  3      -0.18       0
##  4      -0.17       0
##  5      -0.16       0
##  6      -0.15       0
##  7      -0.14       0
##  8      -0.13       0
##  9      -0.12       0
## 10      -0.11       0
## # … with 31 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We saw above that our point estimate for the difference in means is roughly 0.05, but now that we found the &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-value under this sequence of hypothesis tests, we know the null values of &lt;span class=&#34;math inline&#34;&gt;\(\delta_0\)&lt;/span&gt; that cannot be rejected, giving us a 93% interval [-0.04, 0.13] inclusive.&lt;a href=&#34;#fn5&#34; class=&#34;footnote-ref&#34; id=&#34;fnref5&#34;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;
Below I plot the &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;-value at each null &lt;span class=&#34;math inline&#34;&gt;\(\delta_{0}\)&lt;/span&gt; as bars. Bars are colored red if they represent values of &lt;span class=&#34;math inline&#34;&gt;\(\delta_{0}\)&lt;/span&gt; that can be rejected at &lt;span class=&#34;math inline&#34;&gt;\(\alpha = .05\)&lt;/span&gt;. What remains is the values that cannot be rejected, which I use to draw the confidence interval below the bars. It’s important to remember that this is not a plot of a posterior distribution, so the height of the bar does not indicate the plausibility or credibility of a given &lt;span class=&#34;math inline&#34;&gt;\(\delta\)&lt;/span&gt; value.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/purrrmutation-tests/index_files/figure-html/plot-conf-1.png&#34; width=&#34;90%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;multiple-treatments&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Multiple treatments&lt;/h2&gt;
&lt;p&gt;Suppose that we had outcome data that were a function of multiple treatment conditions. Here is some fake data from an experiment where subjects rate potential candidates on a 0-10 scale, where the researcher manipulates the candidates party affiliation, occupation, and issue stances.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 500 x 7
##       id cand_rating party occupation issue_tax issue_abortion issue_environment
##    &amp;lt;int&amp;gt;       &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;      &amp;lt;int&amp;gt;     &amp;lt;int&amp;gt;          &amp;lt;int&amp;gt;             &amp;lt;int&amp;gt;
##  1     1           9     1          4         3              2                 3
##  2     2           2     2          2         1              3                 3
##  3     3           2     2          4         2              4                 1
##  4     4           7     2          3         2              3                 3
##  5     5           2     1          4         2              3                 1
##  6     6           5     2          2         1              2                 2
##  7     7           2     2          1         3              4                 3
##  8     8           8     2          3         3              2                 3
##  9     9          10     1          4         3              3                 2
## 10    10           6     1          2         2              1                 2
## # … with 490 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is easy to permute the values of multiple variables at once. The only thing that changes from the above workflow is that we map &lt;code&gt;mutate_at()&lt;/code&gt; to each iteration, specifying that we want to sample the values of an arbitrary set of treatment variables. Supposing that this data were called &lt;code&gt;multi_treat&lt;/code&gt;…&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;
# helpful but not necessary:
# save a vector of treatment names for easy access
treatments &amp;lt;- 
  c(&amp;quot;party&amp;quot;, &amp;quot;occupation&amp;quot;, &amp;quot;issue_tax&amp;quot;, &amp;quot;issue_abortion&amp;quot;, &amp;quot;issue_environment&amp;quot;)

# resample values for each var in `treatments`
multi_permuted &amp;lt;- multi_treat %&amp;gt;%
  crossing(m = 1:1000) %&amp;gt;%
  group_by(m) %&amp;gt;%
  nest() %&amp;gt;%
  mutate(
    permuted_data = map(
      .x = data, 
      .f = mutate_at,
      .vars = vars(one_of(treatments)),
      .funs = sample
    )
  ) %&amp;gt;%
  print()
## # A tibble: 1,000 x 3
## # Groups:   m [1,000]
##        m data               permuted_data     
##    &amp;lt;int&amp;gt; &amp;lt;list&amp;gt;             &amp;lt;list&amp;gt;            
##  1     1 &amp;lt;tibble [500 × 7]&amp;gt; &amp;lt;tibble [500 × 7]&amp;gt;
##  2     2 &amp;lt;tibble [500 × 7]&amp;gt; &amp;lt;tibble [500 × 7]&amp;gt;
##  3     3 &amp;lt;tibble [500 × 7]&amp;gt; &amp;lt;tibble [500 × 7]&amp;gt;
##  4     4 &amp;lt;tibble [500 × 7]&amp;gt; &amp;lt;tibble [500 × 7]&amp;gt;
##  5     5 &amp;lt;tibble [500 × 7]&amp;gt; &amp;lt;tibble [500 × 7]&amp;gt;
##  6     6 &amp;lt;tibble [500 × 7]&amp;gt; &amp;lt;tibble [500 × 7]&amp;gt;
##  7     7 &amp;lt;tibble [500 × 7]&amp;gt; &amp;lt;tibble [500 × 7]&amp;gt;
##  8     8 &amp;lt;tibble [500 × 7]&amp;gt; &amp;lt;tibble [500 × 7]&amp;gt;
##  9     9 &amp;lt;tibble [500 × 7]&amp;gt; &amp;lt;tibble [500 × 7]&amp;gt;
## 10    10 &amp;lt;tibble [500 × 7]&amp;gt; &amp;lt;tibble [500 × 7]&amp;gt;
## # … with 990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You would then be able to &lt;code&gt;map()&lt;/code&gt; whatever estimation model you wanted over the &lt;code&gt;permuted_data&lt;/code&gt; column, thereby estimating the model in each group &lt;code&gt;m&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;block-randomization&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Block Randomization&lt;/h2&gt;
&lt;p&gt;Suppose we had data that were randomized within blocks. The data below contain &lt;span class=&#34;math inline&#34;&gt;\(n = 500\)&lt;/span&gt; observations and 5 blocks, with each block containing 50 treated units and 50 control units.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 500 x 4
##       id block treatment     y
##    &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1     1     2         1     0
##  2     2     3         0     1
##  3     3     4         0     0
##  4     4     5         1     1
##  5     5     1         0     0
##  6     6     2         0     1
##  7     7     3         1     1
##  8     8     4         1     0
##  9     9     5         1     0
## 10    10     1         1     1
## # … with 490 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can’t naively permute the treatments over the whole data, since we want to respect the blocking structure. To permute treatments within blocks, we only require one additional step, which is to group the data by block during the permutation step.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;block_data %&amp;gt;%
  crossing(m = 1:1000) %&amp;gt;%
  group_by(m) %&amp;gt;%
  nest() %&amp;gt;%
  mutate(
    permuted_data = map(
      .x = data, 
      .f = ~ .x %&amp;gt;%
             group_by(block) %&amp;gt;%
             mutate(treatment = sample(treatment)) %&amp;gt;%
             ungroup()
    )
  ) %&amp;gt;%
  print()
## # A tibble: 1,000 x 3
## # Groups:   m [1,000]
##        m data               permuted_data     
##    &amp;lt;int&amp;gt; &amp;lt;list&amp;gt;             &amp;lt;list&amp;gt;            
##  1     1 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  2     2 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  3     3 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  4     4 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  5     5 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  6     6 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  7     7 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  8     8 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  9     9 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
## 10    10 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
## # … with 990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;cluster-randomization&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Cluster randomization&lt;/h2&gt;
&lt;p&gt;With cluster-randomized data, units are grouped within a cluster, and then every unit within a cluster gets the same treatment. Cluster-randomized data might look like so:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 500 x 4
##       id cluster treatment     y
##    &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1     1       1         0     1
##  2     2       1         0     0
##  3     3       1         0     0
##  4     4       1         0     1
##  5     5       1         0     0
##  6     6       2         1     1
##  7     7       2         1     0
##  8     8       2         1     1
##  9     9       2         1     1
## 10    10       2         1     0
## # … with 490 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to permute the treatment assignments, we have to reshuffle the treatment status for each cluster such that all units in the same cluster get the same treatment. This is possible, but it’s a bit abstract, since it requires a nest-within-a-nest (whoa…). When we &lt;code&gt;map()&lt;/code&gt; the function to permute the data, we do the following within each iteration &lt;code&gt;m&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nest the unit-level variables (&lt;code&gt;id&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;) into a list-column. What remains is a data frame that is one row per cluster.&lt;/li&gt;
&lt;li&gt;Permute the treatment assignments at the cluster level&lt;/li&gt;
&lt;li&gt;Unnest the unit-level data, at which point every unit inherits its cluster-level treatment assignment.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cluster_permuted &amp;lt;- cluster_data %&amp;gt;%
  crossing(m = 1:1000) %&amp;gt;%
  group_by(m) %&amp;gt;%
  nest() %&amp;gt;%
  mutate(
    permuted_data = map(
      .x = data,
      .f = ~ .x %&amp;gt;%
             nest(within_cluster = c(id, y)) %&amp;gt;%
             mutate(treatment = sample(treatment)) %&amp;gt;%
             unnest(within_cluster)
    )
  ) %&amp;gt;%
  print()
## # A tibble: 1,000 x 3
## # Groups:   m [1,000]
##        m data               permuted_data     
##    &amp;lt;int&amp;gt; &amp;lt;list&amp;gt;             &amp;lt;list&amp;gt;            
##  1     1 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  2     2 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  3     3 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  4     4 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  5     5 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  6     6 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  7     7 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  8     8 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
##  9     9 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
## 10    10 &amp;lt;tibble [500 × 4]&amp;gt; &amp;lt;tibble [500 × 4]&amp;gt;
## # … with 990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To assure you that this works, I will plot the treatment status of all units within 3 clusters across the first 10 permutations. We should see that all units in the same cluster share the same treatment status within the same treatment permutation &lt;code&gt;m&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/purrrmutation-tests/index_files/figure-html/plot-unit-clusters-1.png&#34; width=&#34;90%&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;
I’ll shout out &lt;a href=&#34;https://cran.r-project.org/web/packages/ri2/&#34;&gt;ri2&lt;/a&gt; in particular.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;
The paper by &lt;a href=&#34;https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.1540-5907.2011.00576.x?casa_token=YjkCBZcxieAAAAAA:-WVWyv9NfA_83dsFCKLYjofLTVBEKehe0cG3a3na-7OQhSQrURDVGsjgeKwHSv6KI5jrXpmNV5Bog9A&#34;&gt;Keele, McConnaughy, and White&lt;/a&gt; discusses and includes examples of other statistics such as rank-based tests, encouraging researchers to consider theory and the assumptions they are willing to make about the data, such as the choice of a “sharp” null hypothesis.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;
The estimated treatment effect is actually very close to the true effect, so what we’re seeing is a low-powered study.&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34;&gt;&lt;p&gt;
This arguably requires more (or at least “different”) assumptions compared to a pure “Fisherian” approach to randomization inference, which is possible under a sharp null hypothesis that &lt;em&gt;treatment has zero effect for all units&lt;/em&gt;.&lt;a href=&#34;#fnref4&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn5&#34;&gt;&lt;p&gt;
Due to the discrete nature of the &lt;span class=&#34;math inline&#34;&gt;\(\delta_{0}\)&lt;/span&gt; values, we do not obtain a perfect 95% interval.&lt;a href=&#34;#fnref5&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Git information in your open-source research paper (with Rmarkdown)
</title>
      <link>/post/git-in-papers/</link>
      <pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/git-in-papers/</guid>
      <description>


&lt;div id=&#34;motivation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;One benefit of open-source research is that it is possible to trace the history of a research product through its (potentially many) iterations using a versioning system such as Git. This is great for readers who encounter the project’s remote repository, but it’s more likely the case that readers will encounter only a PDF of your paper in an email or through a preprint archive. While services like ArXiv will watermark your paper, it (or so it seems) only includes information about the paper’s history in ArXiv specifically, rather its history in your Git repository. This post describes how you can use Rmarkdown to include Git information into a working draft of your research paper.&lt;/p&gt;
&lt;p&gt;What exactly do I mean? Your paper typically includes the date of compilation, but you could also include the current commit hash, the branch of the current commit, and so on. Why would you want to do this?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A compilation system like &lt;span class=&#34;math inline&#34;&gt;\(\mathrm{\LaTeX}\)&lt;/span&gt; can print the date of compilation, but it is often the case that documents are re-compiled without any real changes. This means the compilation date can be a deceiving signal about when the paper was most recently modified. You may want to “timestamp” a version of your paper in a way that is robust to re-compilation at an arbitrary future time.&lt;/li&gt;
&lt;li&gt;As you develop your paper locally, you may commit several small changes between major versions of your paper. To prevent your “in-development” copy from being confused for a major version of the paper, you may want to note which commit generated the current PDF and perhaps link to a more stable “for public eyes” version of the paper elsewhere.&lt;/li&gt;
&lt;li&gt;A more general case of the previous point: suppose you develop your project across multiple branches (e.g. as with &lt;a href=&#34;https://datasift.github.io/gitflow/IntroducingGitFlow.html&#34;&gt;“Git flow”&lt;/a&gt;). You may reserve your “master” branch for major versions of the project while iteratively developing the project (and compiling the document) on a non-master branch. In this case, you might want to know if a PDF was compiled from source code on the master branch (i.e. “Am I looking at a major version of the paper”) or on an in-development branch.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here is an example from one of my in-progress papers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;git-date.png&#34; width=&#34;732&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This setup prioritizes the commit hash over the compilation date as a method for “dating” your paper. The branch name is included in cases where the PDF is generated on a development branch instead of on the master/public branch. The footnote corresponding to the commit information contains the commit message (not shown). And lastly, the link to the public version takes you to the master branch PDF on Github—the most recent major version.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;how-to-do-it&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;How to do it&lt;/h2&gt;
&lt;p&gt;Setting this up consists of essentially two steps:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Learn to print Git commands to the console using R.&lt;/li&gt;
&lt;li&gt;Place that R code in your &lt;code&gt;.Rmd&lt;/code&gt; document’s YAML header.&lt;/li&gt;
&lt;/ol&gt;
&lt;div id=&#34;console-commands-with-r&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Console commands with R&lt;/h3&gt;
&lt;p&gt;We can run console commands within R using the &lt;code&gt;system()&lt;/code&gt; function. Ordinarily the results of the commands merely print to the console instead of being treated as objects, but we want to make these objects be accessible in the R environment using the &lt;code&gt;intern = TRUE&lt;/code&gt; argument.&lt;/p&gt;
&lt;p&gt;Here are some examples that will display Git information for my website repo (where this code is currently being evaluated).&lt;/p&gt;
&lt;p&gt;For instance, how can we print the branch name?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;system(&amp;quot;git symbolic-ref --short HEAD&amp;quot;, intern = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;master&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To print only the hashes in your Git log, you can supply &lt;code&gt;%t&lt;/code&gt; to the the &lt;code&gt;--pretty&lt;/code&gt; argument of &lt;code&gt;git log&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;system(&amp;quot;git log --pretty=%t&amp;quot;, intern = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   [1] &amp;quot;d3b381a&amp;quot; &amp;quot;ad7ee18&amp;quot; &amp;quot;c5fcaa0&amp;quot; &amp;quot;533e975&amp;quot; &amp;quot;2e7c7a8&amp;quot; &amp;quot;eaee307&amp;quot; &amp;quot;43bfc74&amp;quot;
##   [8] &amp;quot;1856a0b&amp;quot; &amp;quot;5823e01&amp;quot; &amp;quot;66e52d7&amp;quot; &amp;quot;0f043a4&amp;quot; &amp;quot;af6087c&amp;quot; &amp;quot;56bc096&amp;quot; &amp;quot;ebd98df&amp;quot;
##  [15] &amp;quot;3074778&amp;quot; &amp;quot;94bcada&amp;quot; &amp;quot;fa8f4fa&amp;quot; &amp;quot;1079fd7&amp;quot; &amp;quot;1a3553b&amp;quot; &amp;quot;f352285&amp;quot; &amp;quot;0e7c4b4&amp;quot;
##  [22] &amp;quot;3be8c27&amp;quot; &amp;quot;2a80372&amp;quot; &amp;quot;950065a&amp;quot; &amp;quot;b8d24f2&amp;quot; &amp;quot;9da4ece&amp;quot; &amp;quot;8cccbf9&amp;quot; &amp;quot;45d0315&amp;quot;
##  [29] &amp;quot;9d26ba5&amp;quot; &amp;quot;6ebb3b0&amp;quot; &amp;quot;af8a617&amp;quot; &amp;quot;2c6ec85&amp;quot; &amp;quot;22fea55&amp;quot; &amp;quot;3854af2&amp;quot; &amp;quot;93d13c4&amp;quot;
##  [36] &amp;quot;b297079&amp;quot; &amp;quot;f8b6836&amp;quot; &amp;quot;d988f5c&amp;quot; &amp;quot;6fc4555&amp;quot; &amp;quot;eabf878&amp;quot; &amp;quot;d6bf55f&amp;quot; &amp;quot;ecc0c17&amp;quot;
##  [43] &amp;quot;322d6d8&amp;quot; &amp;quot;b204b83&amp;quot; &amp;quot;604a055&amp;quot; &amp;quot;5b6cd16&amp;quot; &amp;quot;7f3d4e8&amp;quot; &amp;quot;3e3d9d1&amp;quot; &amp;quot;c5c2a6b&amp;quot;
##  [50] &amp;quot;72ecc5a&amp;quot; &amp;quot;bd25ad7&amp;quot; &amp;quot;2820840&amp;quot; &amp;quot;f8be89c&amp;quot; &amp;quot;5011495&amp;quot; &amp;quot;b4f159a&amp;quot; &amp;quot;471d45e&amp;quot;
##  [57] &amp;quot;32e03b8&amp;quot; &amp;quot;d55b641&amp;quot; &amp;quot;175df3e&amp;quot; &amp;quot;03985bd&amp;quot; &amp;quot;549e2f0&amp;quot; &amp;quot;8effeb6&amp;quot; &amp;quot;e7c1fc3&amp;quot;
##  [64] &amp;quot;19f3bcd&amp;quot; &amp;quot;0647521&amp;quot; &amp;quot;5913357&amp;quot; &amp;quot;b146ac2&amp;quot; &amp;quot;494f860&amp;quot; &amp;quot;557bf2a&amp;quot; &amp;quot;2b367c7&amp;quot;
##  [71] &amp;quot;734e099&amp;quot; &amp;quot;8ef25d4&amp;quot; &amp;quot;1d949ce&amp;quot; &amp;quot;ed14db3&amp;quot; &amp;quot;ba4694c&amp;quot; &amp;quot;57d5fc6&amp;quot; &amp;quot;1656482&amp;quot;
##  [78] &amp;quot;28d68d7&amp;quot; &amp;quot;5b8e92a&amp;quot; &amp;quot;a807aab&amp;quot; &amp;quot;359f06a&amp;quot; &amp;quot;78c3ee3&amp;quot; &amp;quot;defc14f&amp;quot; &amp;quot;ec7e081&amp;quot;
##  [85] &amp;quot;e4c9176&amp;quot; &amp;quot;ab502db&amp;quot; &amp;quot;7fe3ee6&amp;quot; &amp;quot;2f97534&amp;quot; &amp;quot;3259f27&amp;quot; &amp;quot;bec13bd&amp;quot; &amp;quot;f3142cc&amp;quot;
##  [92] &amp;quot;2959bf6&amp;quot; &amp;quot;b4754c2&amp;quot; &amp;quot;91fe96a&amp;quot; &amp;quot;91bba9b&amp;quot; &amp;quot;071d153&amp;quot; &amp;quot;8e4cce3&amp;quot; &amp;quot;ba09b95&amp;quot;
##  [99] &amp;quot;741632b&amp;quot; &amp;quot;3569cdc&amp;quot; &amp;quot;d99c163&amp;quot; &amp;quot;5c135e3&amp;quot; &amp;quot;2671a4b&amp;quot; &amp;quot;2b7d810&amp;quot; &amp;quot;ea7d44d&amp;quot;
## [106] &amp;quot;6c7656c&amp;quot; &amp;quot;e40d5d8&amp;quot; &amp;quot;bb9199d&amp;quot; &amp;quot;ca4e593&amp;quot; &amp;quot;c42c33f&amp;quot; &amp;quot;d17291e&amp;quot; &amp;quot;38d1910&amp;quot;
## [113] &amp;quot;6bc2299&amp;quot; &amp;quot;3131d9d&amp;quot; &amp;quot;5906234&amp;quot; &amp;quot;d355f02&amp;quot; &amp;quot;7a6e215&amp;quot; &amp;quot;c5befba&amp;quot; &amp;quot;b0dba1c&amp;quot;
## [120] &amp;quot;c1d6342&amp;quot; &amp;quot;87f3ceb&amp;quot; &amp;quot;83ca75b&amp;quot; &amp;quot;69e41cf&amp;quot; &amp;quot;f9278c7&amp;quot; &amp;quot;a3ee86e&amp;quot; &amp;quot;816ebb5&amp;quot;
## [127] &amp;quot;030278d&amp;quot; &amp;quot;2d9384b&amp;quot; &amp;quot;fec8391&amp;quot; &amp;quot;83dbb8c&amp;quot; &amp;quot;1210553&amp;quot; &amp;quot;ce35ec0&amp;quot; &amp;quot;ab3c776&amp;quot;
## [134] &amp;quot;c62ad9f&amp;quot; &amp;quot;3148687&amp;quot; &amp;quot;c3621d8&amp;quot; &amp;quot;943687e&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use indexing to isolate only the most recent hash from this vector of results.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;system(&amp;quot;git log --pretty=%t&amp;quot;, intern = TRUE)[1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;d3b381a&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To print the commit message, use &lt;code&gt;--pretty=%s&lt;/code&gt; instead.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;system(&amp;quot;git log --pretty=%s&amp;quot;, intern = TRUE)[1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;retry kathy date field&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;r-results-in-the-yaml&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;R results in the YAML&lt;/h3&gt;
&lt;p&gt;Now that we know which commands to run to get the Git info, how do we get this information into our YAML? We will do this using inline R code chunks. This code block shows what I’ve done for the above paper example, and I describe a few of the tricks I use below.&lt;/p&gt;
&lt;pre class=&#34;yaml&#34;&gt;&lt;code&gt;date: |
  | Commit \texttt{`r system(&amp;quot;git log --pretty=%t&amp;quot;, intern = TRUE)[1]`} on branch \texttt{`r system(&amp;quot;git symbolic-ref --short HEAD&amp;quot;, intern = TRUE)`}\footnote{Commit message: \texttt{`r system(&amp;quot;git log --pretty=%s&amp;quot;, intern = TRUE)[1]`}}
  | Compiled `r format(Sys.time(), &amp;#39;%B %d, %Y&amp;#39;)`
  | Most recent online version [here](https://github.com/mikedecr/causal-bayes/blob/master/writing/causal-bayes-paper.pdf).&lt;/code&gt;&lt;/pre&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;We use the &lt;code&gt;date&lt;/code&gt; variable, but we supply multiple lines of content. To do this, place a pipe &lt;code&gt;|&lt;/code&gt; after declaring the &lt;code&gt;date&lt;/code&gt; variable, and begin each line with a new pipe &lt;code&gt;|&lt;/code&gt;. This will line-break the content in your compiled PDF and let you supply &lt;span class=&#34;math inline&#34;&gt;\(\mathrm{\LaTeX}\)&lt;/span&gt; code directly to the variable.&lt;/li&gt;
&lt;li&gt;To use teletype/fixed-width font, type the &lt;code&gt;\texttt{}&lt;/code&gt; command for &lt;span class=&#34;math inline&#34;&gt;\(\mathrm{\LaTeX}\)&lt;/span&gt; directly in Rmarkdown.&lt;/li&gt;
&lt;li&gt;We can evaluate and print the results of inline R code by including the letter &lt;code&gt;r&lt;/code&gt; at the beginning of an inline code chunk (delimited by backticks). This code is evaluated before the document is compiled, so the information being passed to &lt;code&gt;\texttt{}&lt;/code&gt; is the &lt;em&gt;results&lt;/em&gt; of the R code rather than the text of the R code itself.&lt;/li&gt;
&lt;li&gt;Do the same basic setup for the commit hash, commit message (in a footnote), and the compilation date. Note that the formatting of the compilation date gives you prettier results than the Rmarkdown default.&lt;/li&gt;
&lt;li&gt;Lastly, you can link the reader to the most recent public PDF by linking to your remote master branch. By linking directly to Github (or wherever else you host the remote repository), any time you push an update to remote, your PDF will automatically be up to date. This will be true of any offline PDF, any previous PDF, and any PDF generated on any branch. This is because the URL to your master branch PDF will not change even if the PDF file itself changes!&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;caveat&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Caveat&lt;/h2&gt;
&lt;p&gt;When you push to Github, it creates new hashes that differ from your local machine.
As a result, you can’t use the hash in the PDF to cross-reference the same hash on Github.
This is a shortcoming of the approach, and if I think of a feasible way around it, I will update this post or write a new post altogether.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Causal Mediation, Bayesianly</title>
      <link>/post/bayes-mediation/</link>
      <pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/bayes-mediation/</guid>
      <description>


&lt;div id=&#34;motivation-for-this-post&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Motivation for this post&lt;/h1&gt;
&lt;p&gt;Over this summer, I have been organizing a reading group on causal inference for students in my department. As someone who sees data analysis problems primarily through Bayesian goggles, I have been doing extra work in my head to make sense of “Bayesian causal inference.” I’m hoping to write some articles about this for political scientists, but the dissertation (rightly) has more of my attention lately.&lt;/p&gt;
&lt;p&gt;We covered causal mediation this week (&lt;a href=&#34;https://imai.fas.harvard.edu/research/files/mediationP.pdf&#34;&gt;Imai et al. 2011 &lt;em&gt;APSR&lt;/em&gt;&lt;/a&gt;), which I thought would be a good opportunity to explain where my thoughts are going about this. So this post will briefly describe a Bayesian vantage point on causal inference and show how to use Bayesian tools to implement it.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;posterior-predictive-draws.-i-mean-unobserved-potential-outcomes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Posterior Predictive Draws. I mean, “Unobserved Potential Outcomes”&lt;/h1&gt;
&lt;p&gt;It should be noted up front that a Bayesian take on causal inference is not at all new (I will borrow plenty of intuition from, for example, &lt;a href=&#34;https://projecteuclid.org/download/pdf_1/euclid.aos/1176344064&#34;&gt;Rubin 1978&lt;/a&gt;), but it is pretty unfamiliar to the political science/econ folks I roll with.&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;
People often ask me, “How can you even have a Bayesian experiment; don’t you already have randomization?” as if the purpose of priors is to fix confounding somehow. In fairness to non-Bayesians, if this is how Bayesian analysis used priors, I would also be mistrusting of Bayes. Luckily, priors are less presumptuous than that. You get a Bayesian experiment (or any other credible research design) by specifying priors on the parameters and obtaining a posterior distribution. It is pretty unremarkable—no different than a Bayesian analysis of a non-causal design. Remember that the causal model (by which I mean, the definition of the potential outcomes) is distinct from the methods used to &lt;em&gt;estimate&lt;/em&gt; causal parameters. Bayesian analysis is positioned closer to the estimation end of things, whereas causal modeling is a series of assumptions about identifying variation in the data. In short, you fix confounding with the design, and priors are for improving the estimation.&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;While the Bayesian approach may not change the research design or the causal assumptions, it does provide a different—and intuitive, I assert—interpretation of potential outcomes. Ordinarily we write potential outcomes as &lt;span class=&#34;math inline&#34;&gt;\(Y_{i}(T_{i} = t)\)&lt;/span&gt;, the outcome value for unit &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; if it received treatment value &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;. Only one potential outcome per unit is ever observed, so can’t observe the &lt;em&gt;unit-level&lt;/em&gt; causal effect &lt;span class=&#34;math inline&#34;&gt;\(\tau_{i}\)&lt;/span&gt;, but we can use a causal identification analysis to lay out the assumptions required to estimate an average effect &lt;span class=&#34;math inline&#34;&gt;\(\bar{\tau}\)&lt;/span&gt; for at least some subset of units. If we knew this average effect, we would be able to state, for each observed outcome &lt;span class=&#34;math inline&#34;&gt;\(y_{i}\)&lt;/span&gt;, what the &lt;em&gt;expected value&lt;/em&gt; of that unit’s unobserved potential outcome would be if we could set &lt;span class=&#34;math inline&#34;&gt;\(T_{i}\)&lt;/span&gt; to some value &lt;span class=&#34;math inline&#34;&gt;\(t&amp;#39;\)&lt;/span&gt; other than what was observed. In this way, the unobserved potential outcome is missing data that we can predict with an estimated the model that generates (potential) outcomes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Maybe you can see where I’m going with this.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bayesian analysis begins with joint model &lt;span class=&#34;math inline&#34;&gt;\(p\left(y, \theta \right)\)&lt;/span&gt; for outcome data &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; and model parameters &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt;. This is equivalently expressed as &lt;span class=&#34;math inline&#34;&gt;\(p(y \mid \theta)p(\theta)\)&lt;/span&gt;, which is to say that the distribution of &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; depends on the value of &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt; and that &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt; has its own distribution. We fit the model by conditioning on the observed &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; to obtain the posterior distribution &lt;span class=&#34;math inline&#34;&gt;\(p\left(\theta \mid y \right)\)&lt;/span&gt;. It is this updated model that represents our state of information about the process that generates potential outcomes &lt;span class=&#34;math inline&#34;&gt;\(y_{i}(t)\)&lt;/span&gt;. If we wanted to make posterior inferences about what &lt;span class=&#34;math inline&#34;&gt;\(y_{i}(t)\)&lt;/span&gt; &lt;em&gt;would have been&lt;/em&gt; (in expectation) if we could arbitrarily change &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;, we would simulate the unobserved potential outcomes &lt;span class=&#34;math inline&#34;&gt;\(\tilde{y}\)&lt;/span&gt; from the model.
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  p(\tilde{y} \mid y) &amp;amp;= \int p(\tilde{y} \mid \theta) p(\theta \mid y)d\theta
\end{align}\]&lt;/span&gt;
The unobserved potential outcome is expressed as a probability distribution because we don’t know exactly what the unobserved data would be. Its distribution depends on &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt;, which itself is conditioned on &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;, and we average over our uncertainty about &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt; by integrating. This gives us a distribution for the unobserved potential outcomes that is marginal of our imperfectly estimated parameters.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Okay, so?&lt;/em&gt;&lt;/strong&gt; The Bayesian view of potential outcomes is appealing because our state of ignorance about the exact potential outcomes is an explicit feature of the model, rather than a point estimate with a post-hoc standard error. Which is to say, &lt;em&gt;we don’t know&lt;/em&gt; what the treatment effect is, and so we don’t know what the potential outcomes are, but we have a range of guesses that that we can directly evaluate using their probability distribution. This approach has a certain philosophical resonance before we get anywhere near the notion of prior information. And to whatever extent researchers already view point estimates and frequentist confidence intervals on treatment effects as “ranges of plausible values” with associated posterior probabilities, they are already doing Bayesian causal inference—just without the benefit of having formally set up the whole model. With the Bayesian approach we are actually allowed to say things like “the data suggest that this treatment effect is most likely positive” or what have you.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;causal-mediation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Causal Mediation&lt;/h1&gt;
&lt;p&gt;Causal mediation analysis is concerned with a causal graph where a treatment &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; affects an outcome &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;, and the effect flows at least partially through a mediator &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt;. Potential outcomes are expressed as &lt;span class=&#34;math inline&#34;&gt;\(Y_{i}(T_{i}, M_{i}(T_{i}))\)&lt;/span&gt;, where the value of &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; depends both on the treatment assignment &lt;span class=&#34;math inline&#34;&gt;\(T_{i} = t\)&lt;/span&gt; and the resulting value of the mediator &lt;span class=&#34;math inline&#34;&gt;\(M_{i}(t)\)&lt;/span&gt;, which is itself affected by the treatment. The causal effects are a decomposition of the total (average) treatment effect.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;total treatment effect&lt;/em&gt;: how much total change in &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; is owed to setting the value of &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt;? Written as &lt;span class=&#34;math inline&#34;&gt;\(Y(1, M(1)) - Y(0, M(0))\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;causal mediation effect&lt;/em&gt;: how much of the total change in &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; is attributed to &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt;’s effect on &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt;, which also affects &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;? Or, how much change in &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; is owed to the fact that &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; changed, as opposed to not changing? Written as &lt;span class=&#34;math inline&#34;&gt;\(Y(t, M(1)) - Y(t, M(0))\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;direct effect&lt;/em&gt;: how much of the change in &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; is not flowing through &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt;? In other words, how would &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; be different even if &lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt; had no effect on &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt;? Written as &lt;span class=&#34;math inline&#34;&gt;\(Y(1, M(t)) - Y(0, M(t))\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Imai et al. present an algorithm to estimate these quantities. We need models to describe how &lt;span class=&#34;math inline&#34;&gt;\(M(T)\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(Y(T, M(T))\)&lt;/span&gt; are generated, but the form of these models does not affect the intuition of the algorithm. It’s like this:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Estimate mediator as a function of treatment and pre-treatment covariates: &lt;span class=&#34;math inline&#34;&gt;\(M_{i} = f(T_{i}, X_{i})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Estimate the outcome as a function of the treatment, the observed mediator, and pre-treatment covariates. &lt;span class=&#34;math inline&#34;&gt;\(Y_{i} = g(T_{i}, M_{i}, X_{i})\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Using &lt;span class=&#34;math inline&#34;&gt;\(f()\)&lt;/span&gt;, generate predicted values &lt;span class=&#34;math inline&#34;&gt;\(\hat{M}\)&lt;/span&gt; for all &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Using &lt;span class=&#34;math inline&#34;&gt;\(g()\)&lt;/span&gt;, predicted values &lt;span class=&#34;math inline&#34;&gt;\(\hat{Y}\)&lt;/span&gt; for all potential outcomes &lt;span class=&#34;math inline&#34;&gt;\(y(t, M(t&amp;#39;))\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Use the appropriate &lt;span class=&#34;math inline&#34;&gt;\(\hat{Y}\)&lt;/span&gt; values to calculate average total, direct, and mediation effects.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;doing-it&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Doing it&lt;/h1&gt;
&lt;p&gt;Imai et al. demonstrate their method using (in part) an experimental study by &lt;a href=&#34;https://www.jstor.org/stable/25193860?seq=1#metadata_info_tab_contents&#34;&gt;Brader, Valentino, and Suhay 2008&lt;/a&gt; on the way news stories affect immigration attitudes through specific emotional mechanisms. Let’s do the outcome where &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; represents a participant’s decision to send an anti-immigrant message to their Congressperson (&lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;), which is affected by a cue in the story about a hypothetical immigrant’s ethnicity (&lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt;), and moderated by the emotion of anxiety (&lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt;).&lt;/p&gt;
&lt;p&gt;First, Imai et al. use an OLS model to predict respondent’s anxiety in response to treatment, with pre-treatment covariates &lt;span class=&#34;math inline&#34;&gt;\(X_{i}\)&lt;/span&gt; and coefficients &lt;span class=&#34;math inline&#34;&gt;\(\zeta_{1}\)&lt;/span&gt;. Parameters are subscripted &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt; for the “first stage” of the estimation.
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  M_{i} &amp;amp;= \alpha_{1} + T_{i}\beta_{1} + X_{i}\zeta{1} + \epsilon_{i}
\end{align}\]&lt;/span&gt;
They then use a probit model to estimate the outcome variable, the “second stage” (subscripted 2). This model includes the mediator with coefficient &lt;span class=&#34;math inline&#34;&gt;\(\gamma\)&lt;/span&gt;.
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  p(Y_{i} = 1) &amp;amp;= \Phi\left(\alpha_{2} + T_{i}\beta_{2} + M_{i}\gamma + X_{i}\zeta_{2}\right)
\end{align}\]&lt;/span&gt;
You should be able to code to implement this routine in R &lt;a href=&#34;https://github.com/mikedecr/site-leavit/blob/master/static/code-blogs/R/bayes-mediation.R&#34;&gt;here&lt;/a&gt;, which calls &lt;a href=&#34;https://github.com/mikedecr/site-leavit/blob/master/static/code-blogs/stan/mediation-bvs.stan&#34;&gt;this Stan file&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In Stan, it is easy to generate posterior quantities of interest in the &lt;code&gt;generated quantities&lt;/code&gt; block of a Stan file. For example, generating posterior predictions for mediator values at &lt;span class=&#34;math inline&#34;&gt;\(T \in \{0, 1\}\)&lt;/span&gt; is as easy as…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;m0 = alpha_m + (0 * beta_m) + (X * zeta_m);
m1 = alpha_m + (1 * beta_m) + (X * zeta_m);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because &lt;code&gt;alpha_m&lt;/code&gt;, &lt;code&gt;beta_m&lt;/code&gt;, and &lt;code&gt;zeta_m&lt;/code&gt; are all uncertain parameters, what we are actually doing is generating &lt;code&gt;m0&lt;/code&gt; and &lt;code&gt;m1&lt;/code&gt; in each iteration of the sampler, thus creating a distribution of predicted mediator values. In the integral notation from above, what we’re actually doing is generating a distribution &lt;span class=&#34;math inline&#34;&gt;\(p\left(M(t)\right)\)&lt;/span&gt; by marginalizing over all of the parameters (except for the error term, which is presumably fixed in the counterfactual case).
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  p\left(\tilde{M}(t)\right) &amp;amp;= \int p\left(\tilde{M}(t) \mid \alpha_{1}, \beta_{1}, \zeta_{1}\right) p(\alpha_1, \beta_1, \zeta_1 \mid M)d\alpha_1 d\beta_1 d\zeta_1
\end{align}\]&lt;/span&gt;
Hopefully I haven’t messed up the integral.&lt;/p&gt;
&lt;p&gt;Posterior predictions for new potential outcome observation &lt;span class=&#34;math inline&#34;&gt;\(\tilde{Y}(t, M(t&amp;#39;))\)&lt;/span&gt; would be…
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  p\left(\tilde{Y}(t, m(t&amp;#39;))\right) &amp;amp;= \int p\left(\tilde{Y}(t, M(t&amp;#39;)) \mid \alpha_2, \beta_2, \tilde{M}(t&amp;#39;), \gamma, \zeta_2 \right) \times \\[6pt]&amp;amp;\qquad p\left(\alpha_2, \beta_2, \tilde{M}(t&amp;#39;), \gamma, \zeta_2 \mid Y\right) d\alpha_2 d\beta_2 d\tilde{M}(t) d\gamma d\zeta_2.
\end{align}\]&lt;/span&gt;
This expression is also marginalizing over the simulated mediator value &lt;span class=&#34;math inline&#34;&gt;\(M(t&amp;#39;)\)&lt;/span&gt;. Because the simulated mediator is a function of random variables, it itself is also a random variable with a probability distribution.&lt;/p&gt;
&lt;p&gt;In order to get total, direct, and mediation effects, we calculate each comparison of potential outcomes using the posterior predictive draws, and then average over each observation in the data. Here are the posterior samples for each treatment effect component.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## Registered S3 method overwritten by &amp;#39;GGally&amp;#39;:
##   method from   
##   +.gg   ggplot2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: `tbl_df()` is deprecated as of dplyr 1.0.0.
## Please use `tibble::as_tibble()` instead.
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_warnings()` to see where this warning was generated.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/bayes-mediation/index_files/figure-html/post-hist-1.png&#34; width=&#34;100%&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And here is a comparison to the &lt;code&gt;{mediation}&lt;/code&gt; package by the Imai et al. team. We can see that, because the posterior distributions for the ACMEs are not symmetrical, there is some difference between the &lt;code&gt;{mediation}&lt;/code&gt; estimates (which come from an maximum likelihood model) and the Bayesian estimate, which is a posterior mean.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/bayes-mediation/index_files/figure-html/graph-1.png&#34; width=&#34;100%&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;other-things-to-think-about&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Other things to think about&lt;/h1&gt;
&lt;p&gt;Imai et al. propose a sensitivity analysis to measure “how much” post-treatment confounding among mediators would be enough to change your inference about causal mediation effects. While I won’t do this now, it would be possible to specify a prior on the sensitivity parameter. Such a move would let the researcher evaluate the mediation effect &lt;em&gt;marginal&lt;/em&gt; of a distribution of potential confounding, rather than merely conditional on one fixed level of confounding. This would let us make a probabilistic statement about the threat of confounding rather than a hypothetical statement. It’s of course subject to the prior, but most researchers substantively interpret their results assuming that confounding is zero, so we can think about the prior as actually relaxing an assumption of zero confounding rather than “adding a new assumption.”&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;
There are a few examples of it in political science, but the Bayesian component is used mostly for computation (MCMC) rather than for the Bayesian ideas themselves. Meanwhile Bayes-for-its-own-sake seems far more prevalent in fields like psychology, epidemiology, and biostatistics.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;
Ugh, caveating. It would be possible to represent identification assumptions as special cases of prior distributions, where the parameters of the prior can be manipulated to “relax” the assumption. For example, unconfoundedness or exclusion restrictions imply a model that contains additional covariates that each have priors that stack all probability density at exactly zero. This exercise is actually very similar to the specification of the “sensitivity parameter” in the Imai et al. mediation analysis routine.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Unrealistic Priors and the &#34;Illusion of Learning from Observational Research&#34;
</title>
      <link>/post/ggk-flat-priors/</link>
      <pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/ggk-flat-priors/</guid>
      <description>


&lt;p&gt;I’ve been reading about Bayesian causal inference for a paper I’m hoping to write, and this has led me to dig into the work by &lt;a href=&#34;https://books.google.com/books?hl=en&amp;amp;lr=&amp;amp;id=RDueAgAAQBAJ&amp;amp;oi=fnd&amp;amp;pg=PA9&amp;amp;dq=gerber+green+kaplan&amp;amp;ots=0I3f6Jfn33&amp;amp;sig=wVKOfRF39mkiT4vnMe8YecMMpeY#v=onepage&amp;amp;q=gerber%20green%20kaplan&amp;amp;f=false&#34;&gt;Gerber, Green, and Kaplan&lt;/a&gt; (hereafter “GGK”) about the “Illusion of Learning from Observational Research.” In it, they put forth a model to describe how much you “update” your information about causal effects from experimental vs. observational research.&lt;/p&gt;
&lt;p&gt;The intuition of the model? Suppose that we want to learn about some true causal effect &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt;. When we conduct a study, our estimate &lt;span class=&#34;math inline&#34;&gt;\(\hat{T}\)&lt;/span&gt; reflects the true effect &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt;, plus bias &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;, plus error &lt;span class=&#34;math inline&#34;&gt;\(\epsilon\)&lt;/span&gt;:
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  \hat{T} &amp;amp;= \tau + \beta + \epsilon,
\end{align}\]&lt;/span&gt;
What we want to do is update our information about &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt;. Under what conditions do we learn a lot about it?&lt;/p&gt;
&lt;p&gt;Suppose we collect a ton of data, so the variance of &lt;span class=&#34;math inline&#34;&gt;\(\hat{T}\)&lt;/span&gt; shrinks to be very small. This is similar to shrinking &lt;span class=&#34;math inline&#34;&gt;\(\epsilon\)&lt;/span&gt; toward zero, so we’re pretty certain what &lt;span class=&#34;math inline&#34;&gt;\(\tau + \beta\)&lt;/span&gt; is, but we’ve only identified their sum. We don’t know how much of &lt;span class=&#34;math inline&#34;&gt;\(\hat{T}\)&lt;/span&gt; is &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt; and how much is &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Here’s the thrust of their argument. If we want to update our priors about &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt; specifically, we need a study design where we have clear priors about &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;. If our study is experimental, we can assume &lt;em&gt;a priori&lt;/em&gt; that the size of the bias &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; is either zero or very small. This way, learning about &lt;span class=&#34;math inline&#34;&gt;\(\hat{T}\)&lt;/span&gt; allows us to learn a lot about &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt;. When we are in an observational study, we don’t know as much about the size of the bias &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;, and the data don’t allow us to update those priors independently of &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt;. As a result, the data can’t tell us as much about &lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt;, only &lt;span class=&#34;math inline&#34;&gt;\(\tau + \beta\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;This model makes a lot of sense. When you have vague priors about the bias in a study, you don’t know how to interpret its findings. Fair!&lt;/p&gt;
&lt;div id=&#34;but&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;But…&lt;/h1&gt;
&lt;p&gt;The namesake of GGK’s theoretical model, the &lt;strong&gt;Illusion of Learning from Observational Research&lt;/strong&gt;, is the model’s result where we have &lt;em&gt;flat priors&lt;/em&gt; about the bias &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;. Under a flat prior, we learn &lt;em&gt;nothing&lt;/em&gt; from having conducted an observational study because the bias could be &lt;em&gt;anything&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;What I want to assert is that the “flat priors” result is a degenerate case. It does not accurately characterize observational research, and it never really occurs in real life. As a result, we need to be careful interpreting the model to avoid overstating what it actually says about real-world observational research.&lt;/p&gt;
&lt;p&gt;Suppose we conduct an observational study and detect an effect of size &lt;span class=&#34;math inline&#34;&gt;\(1.0\)&lt;/span&gt;. If we are concerned about uncorrected bias in the study design, practically speaking we are mainly concerned with the possibility that the effect is &lt;em&gt;over-estimated&lt;/em&gt;—unobserved confounders drive self-selection into treatment, inflating the causal effect estimate. This would give us a prior that the true effect most likely falls somewhere between 0 and the observational effect size. Meaning, we actually have pretty specific priors about the bias. Would we put much probability on the possibility that the true effect is &lt;em&gt;double&lt;/em&gt; the estimated effect, or greater? Probably not, since most of the time we are worried about self-selection into treatment. Do we think that the true effect is just as big as the estimated effect, but in the exact opposite direction? Again, probably not, especially if we have theorized carefully about our expectations for the study.&lt;/p&gt;
&lt;p&gt;We can see it better by rearranging terms. Setting &lt;span class=&#34;math inline&#34;&gt;\(\epsilon\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt; for a moment…
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  \beta &amp;amp;= \hat{T} - \tau
\end{align}\]&lt;/span&gt;
The bias &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; is the difference between the true and observed effects, so our prior for &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; is the difference in our priors for the true and estimated effects. If we have some expectation about the true and estimated effects—and we normally do…—then we have reasonably clear priors about the size of the bias in observational studies.&lt;/p&gt;
&lt;p&gt;What does a Bayesian say? Our priors aren’t flat, but so the “Illusion” of learning in observational studies is an overstatement (or even “sleight of hand”). I worry how many people have read the original GGK piece and come away with the impression that flat priors about &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; is a fair or accurate representation of observational research. I don’t mean this as a defense of biased research—rather, it is a criticism of flat priors. I don’t know if GGK intended for the flat priors case to be interpreted as “realistic”—on the one hand, the flat-priors result is the namesake of the piece, but their numerical example uses a non-flat prior for the bias term—but if a reader isn’t already thinking hard about their priors, then it’s easy to see how they might not catch this.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;zooming-out&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Zooming out&lt;/h1&gt;
&lt;p&gt;There are a few mid-level lessons we could reinforce by thinking about our priors about bias in observational studies.&lt;/p&gt;
&lt;p&gt;First, there’s never a bad time to remember that (improper) flat priors are unrealistic. Inferences under flat priors can look like inferences under informed priors if the data are strong enough, but we should worry about any exercise where some theoretical result &lt;em&gt;necessarily depends&lt;/em&gt; on an assumption of flat priors. In thought experiments and in real data analysis, you can always do better than a flat prior.&lt;/p&gt;
&lt;p&gt;Relatedly, Bayesians are keen to highlight areas where informed priors provide important stability to some result that would have looked like nonsense under flat priors. This is one of those cases. Flat priors lead you in an unstable direction assessing the information conveyed by research. It’s only in a case where you have more informed priors about the terms in the GGK model where the results conform to how we actually think about research findings.&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lastly, I am increasingly preoccupied by the way Bayes’ theorem is routinely used in theoretical models to convey important intuitions about causal inference and yet there is so little formal incorporation of Bayesian priors in applied data analysis of credible research designs (in political science at least; other fields mix these things much more). I’m trying to write a paper about doing applied Bayesian analysis in causal inference, and I hope the causal inference crowd can be convinced to legalize it!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;
Furthermore, it is worth emphasizing that flat priors are only flat &lt;em&gt;with respect to a likelihood&lt;/em&gt;. As soon as you have a quantity that is a function of multiple parameters, the prior for this resulting quantity will &lt;em&gt;not&lt;/em&gt; be flat even if the priors for each parameter are flat. If you have ever demonstrated the Central Limit Theorem by summing a bunch of uniform random variables that results in a bell curve, you have already seen this in action!&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A Visualization of Partial Effects in Multiple Regression</title>
      <link>/post/viz-partials/</link>
      <pubDate>Fri, 19 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/viz-partials/</guid>
      <description>


&lt;div id=&#34;background&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Background&lt;/h1&gt;
&lt;p&gt;A few days ago, &lt;a href=&#34;https://www.andrewheiss.com/&#34;&gt;Andrew Heiss&lt;/a&gt; was &lt;a href=&#34;https://twitter.com/andrewheiss/status/1052232993723494400?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1052232993723494400&amp;amp;ref_url=http%3A%2F%2F127.0.0.1%3A4321%2F2018%2F2018-10-19-partialling-out%2F&#34;&gt;looking&lt;/a&gt; for a way to visualize multiple regression with an emphasis on one predictor, without 3(+)-dimensional plots. He works through a method and posts this cool animation, which shows the changing relationship between &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; when adding controls, superimposed over the scatterplot of the raw data. (He credits &lt;a href=&#34;https://twitter.com/petemohanty&#34;&gt;Pete Mohanty&lt;/a&gt; with the shifting abline idea.)&lt;/p&gt;
&lt;center&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;en&#34;&gt;
&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;
Helpful animated &lt;a href=&#34;https://twitter.com/hashtag/dataviz?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#dataviz&lt;/a&gt; showing what happens to the slope of one coefficient in a model when controlling for other variables in multiple regression&lt;br&gt;&lt;br&gt;(&lt;a href=&#34;https://twitter.com/hashtag/rstats?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#rstats&lt;/a&gt; code: &lt;a href=&#34;https://t.co/yhVLj325Oh&#34;&gt;https://t.co/yhVLj325Oh&lt;/a&gt;) &lt;a href=&#34;https://t.co/2foYfXDo28&#34;&gt;pic.twitter.com/2foYfXDo28&lt;/a&gt;
&lt;/p&gt;
— 🎃 Andrew Heiss, scary PhD 🦇 (&lt;span class=&#34;citation&#34;&gt;@andrewheiss&lt;/span&gt;) &lt;a href=&#34;https://twitter.com/andrewheiss/status/1052978108255498240?ref_src=twsrc%5Etfw&#34;&gt;October 18, 2018&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;This is cool, but based on Andrew’s initial question, I had something a little different come to mind. I thought we’d be seeing the impact of the regression in both the regression line &lt;em&gt;and&lt;/em&gt; in the data. So I tried to make that (starting with &lt;a href=&#34;https://t.co/yhVLj325Oh&#34;&gt;his code&lt;/a&gt;)…&lt;/p&gt;
&lt;center&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;en&#34;&gt;
&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;
Ok fixed. &lt;br&gt;&lt;br&gt;In this fig, y is (beta * humidity), plus the regression residual. This is equivalent to starting with the fully estimated regression and subtracting out terms for every other covariate &lt;a href=&#34;https://t.co/fLs4WxHTaK&#34;&gt;pic.twitter.com/fLs4WxHTaK&lt;/a&gt;
&lt;/p&gt;
— Michael DeCrescenzo (&lt;span class=&#34;citation&#34;&gt;@mikedecr&lt;/span&gt;) &lt;a href=&#34;https://twitter.com/mikedecr/status/1053028075170975744?ref_src=twsrc%5Etfw&#34;&gt;October 18, 2018&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/center&gt;
&lt;p&gt;which he &lt;a href=&#34;https://twitter.com/andrewheiss/status/1053031575770718208&#34;&gt;liked&lt;/a&gt; and asked to see the code for.&lt;/p&gt;
&lt;p&gt;So I will deliver. &lt;a href=&#34;https://gist.github.com/mikedecr/f6ffdb716d62af32e701f95231f00bee&#34;&gt;Here&lt;/a&gt; is a gist containing an example, and below is some explanation.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;intuition&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Intuition&lt;/h1&gt;
&lt;p&gt;Some math will help. Let’s start by writing the regression equation to suit the task at hand: although we include multiple predictors, we only want to highlight one of them, putting the other predictors into a black box “vector of controls.” Andrew’s example uses Dark Sky data on weather in Provo, UT, highlighting the relationship between humidity and a daily temperature high for each day &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;…
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  \mathit{HighTemp}_{i} &amp;amp;= \alpha + \beta\left(\mathit{Humidity}_{i}\right) + \mathbf{x}_{i}^{T}\gamma + \varepsilon_{i}
\end{align}\]&lt;/span&gt;
where &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; is the constant, &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{x}_{i}\)&lt;/span&gt; is a column-vector of covariate observations for unit &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; (everything but humidity), and &lt;span class=&#34;math inline&#34;&gt;\(\gamma\)&lt;/span&gt; is a vector of coefficients for all non-humidity predictors.&lt;/p&gt;
&lt;p&gt;Operationally, what we want to do is show how &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; changes with the inclusion of additional controls. Andrew’s example shows this by plotting different regressions overtop the raw data. If we run the code&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; from his &lt;a href=&#34;https://gist.github.com/andrewheiss/5e162c836575721d1dd53ec2af38753c&#34;&gt;Gist&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/partialling-out/index_files/figure-html/andrew-animate-1.gif&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;p&gt;The line being plotted starts with &lt;span class=&#34;math inline&#34;&gt;\(\hat{\mathit{High}}_{i} = {\alpha} + {\beta}(\mathit{Humidity}_{i})\)&lt;/span&gt; and adds additional covariates one at a time. The data remain intact.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;variation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Variation&lt;/h1&gt;
&lt;p&gt;But let’s say that we wanted to see the effect of controls in the data as well. This is, I think, where the real umph from this kind of visualization would be; after all, we have already told students that including other predictors will affect the line.&lt;/p&gt;
&lt;p&gt;Thinking about the math, this is as easy as doing to the raw data what we’ve already done to the regression line: subtract out the effect of the covariates. That is, purge the effect of other variables from the raw data. Start with the fully specified regression model…
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  \mathit{High}_{i} &amp;amp;= \alpha + \beta\left(\mathit{Humidity}_{i}\right) + \mathbf{x}_{i}^{T}\gamma + \varepsilon_{i}
\end{align}\]&lt;/span&gt;
…and then subtract out the influence of variables in &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{x}_{i}\)&lt;/span&gt;.
&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  \label{eq:sub} \mathit{High}_{i} - \mathbf{x}^{T}\gamma &amp;amp;= \alpha + \beta\left(\mathit{Humidity}_{i}\right) + \varepsilon_{i}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We still have to decide what to do with the constant. We could…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leave the constant there, which is probably undesirable because the value of the constant reflects the scaling of other covariates.&lt;/li&gt;
&lt;li&gt;Start by setting all covariates equal to their means. This would give us a prediction that is no longer subject to the &lt;em&gt;scaling&lt;/em&gt; of the covariates but the covariates still affect the mean of &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; overall. This works but I think we can make it simpler.&lt;/li&gt;
&lt;li&gt;Subtract the constant along with the covariates. This leaves us with only the predicted partial effect of humidity (plus error). This is what we’ll do, because it zooms in only on the predictor that we care about.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;implementation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Implementation&lt;/h1&gt;
&lt;p&gt;Now we will create the revised gif.&lt;/p&gt;
&lt;p&gt;First we start with the original Heiss data and code.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# ---- Heiss code -----------------------

library(&amp;quot;magrittr&amp;quot;)
library(&amp;quot;tidyverse&amp;quot;)
library(&amp;quot;lubridate&amp;quot;)
library(&amp;quot;broom&amp;quot;)
library(&amp;quot;scales&amp;quot;)
library(&amp;quot;gganimate&amp;quot;)

# Load and clean data
# This data comes from Dark Sky&amp;#39;s API
weather_provo_raw &amp;lt;- read_csv(&amp;quot;https://andhs.co/provoweather&amp;quot;)

# clean dates and precip
weather_provo_2017 &amp;lt;- weather_provo_raw %&amp;gt;% 
  mutate(
    month = month(date, label = TRUE, abbr = FALSE),
    month_number = month(date, label = FALSE),
    weekday = wday(date, label = TRUE, abbr = FALSE),
    weekday_number = wday(date, label = FALSE),
    precipType = ifelse(is.na(precipType), &amp;quot;none&amp;quot;, precipType)
  ) %&amp;gt;% 
  select(
    date, month, month_number, weekday, weekday_number,
    sunriseTime, sunsetTime, moonPhase, 
    precipProbability, precipType, temperatureHigh, temperatureLow, dewPoint, 
    humidity, pressure, windSpeed, cloudCover, visibility, uvIndex
  )

# keep winter and spring, scale vars
winter_spring &amp;lt;- weather_provo_2017 %&amp;gt;% 
  filter(month_number &amp;lt;= 5) %&amp;gt;% 
  mutate(month = factor(month, ordered = FALSE)) %&amp;gt;% 
  mutate(
    humidity = humidity * 100, 
    cloudCover = cloudCover * 100, 
    precipProbability = precipProbability * 100
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We combine several model formulas into a data frame and estimate each regression using &lt;code&gt;purrr::map()&lt;/code&gt;. We’ve added the results from &lt;code&gt;broom::augment()&lt;/code&gt; because we want the residuals from each model to create the “noise” in the data for the graphic.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# ---- mike decrescenzo modifications begin -----------------------

# Run all these models in one data frame (purrr::map)
# add the data as a list column because we&amp;#39;ll want it later
models &amp;lt;- 
  tribble(
    ~formula,
    &amp;quot;temperatureHigh ~ humidity&amp;quot;,
    &amp;quot;temperatureHigh ~ humidity + windSpeed&amp;quot;,
    &amp;quot;temperatureHigh ~ humidity + windSpeed + cloudCover&amp;quot;,
    &amp;quot;temperatureHigh ~ humidity + windSpeed + cloudCover + precipProbability&amp;quot;,
    &amp;quot;temperatureHigh ~ humidity + windSpeed + cloudCover + precipProbability + visibility&amp;quot;) %&amp;gt;%
  # data in a list column
  mutate(spring_data = list(winter_spring)) %&amp;gt;%
  # Run a model in each row
  mutate(model = map2(formula, spring_data, ~ lm(.x, data = .y))) %&amp;gt;%
  # Extract model elements
  mutate(
    model_tidy = map(model, tidy, conf.int = TRUE), 
    model_glance = map(model, glance), 
    model_fits = map(model, augment)
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We calculate the impact of humidity on the high temperature by extracting the humidity coefficient from each model and multiplying it by the raw humidity data (which comes in the &lt;code&gt;augment&lt;/code&gt; results). We will lazily refer to this as the humidity’s “partial prediction” of temperature (thanks to &lt;a href=&#34;https://twitter.com/EvaMaeRey&#34;&gt;Gina Reynolds&lt;/a&gt; for feedback on what this should be called). As a bonus, we will also save the upper and lower bounds of the humidity beta confidence interval.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# compute the partial effect of humidity: beta * humidity
model_partials &amp;lt;- models %&amp;gt;%
  # get the humidity beta and bounds
  mutate(
    humidity_beta = 
      map(model_tidy, ~ filter(.x, term == &amp;quot;humidity&amp;quot;)$estimate) %&amp;gt;% 
                        as.numeric(),
    beta_low = 
      map(model_tidy, ~ filter(.x, term == &amp;quot;humidity&amp;quot;)$conf.low) %&amp;gt;% 
                        as.numeric(),
    beta_high = 
      map(model_tidy, ~ filter(.x, term == &amp;quot;humidity&amp;quot;)$conf.high) %&amp;gt;%
                        as.numeric()
  ) %&amp;gt;% 
  # calculate partial effect of humidity and keep the residual
  unnest(model_fits) %&amp;gt;%
  mutate(partial = humidity * humidity_beta) %&amp;gt;%
  select(formula, humidity, contains(&amp;quot;beta&amp;quot;), partial, .resid) 

# get the beta for label plotting
model_beta &amp;lt;- model_partials %&amp;gt;%
  select(formula, contains(&amp;quot;beta&amp;quot;)) %&amp;gt;%
  distinct() &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we create the figure. The horizontal axis is the raw humidity data. The vertical axis is the humidity effect (&lt;span class=&#34;math inline&#34;&gt;\(\beta \times \mathit{Humidity}_{i}\)&lt;/span&gt;) plus the regression residual &lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_{i}\)&lt;/span&gt;. The regression line is simply &lt;span class=&#34;math inline&#34;&gt;\(\hat{\mathit{High}}_{i} = \hat{\beta}\mathit{Humidity}_{i}\)&lt;/span&gt; with a constant of zero. That is, on a given day, a humidity level of &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt; exerts a negative impact on temperature amounting to &lt;span class=&#34;math inline&#34;&gt;\(\beta z\)&lt;/span&gt;, setting other factors aside. Conveniently, we don’t have to manually subtract the other covariates because we already know how to calculate the vertical axis using the partial effect and the residual (thanks to the math above).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# animate 
ggplot(data = model_partials, aes(x = humidity, y = partial + .resid)) +
  geom_point(color = &amp;quot;gray&amp;quot;) +
  geom_abline(
    data = model_beta, 
    aes(intercept = 0, slope = humidity_beta, group = formula)
  ) +
  geom_abline(
    data = model_beta, 
    aes(intercept = 0, slope = beta_low, group = formula), 
    linetype = 3
  ) +
  geom_abline(
    data = model_beta, 
    aes(intercept = 0, slope = beta_high, group = formula), 
    linetype = 3
    ) +
  theme_minimal(base_family = &amp;quot;Fira Sans&amp;quot;) +
  geom_label(
    data = model_beta, 
    aes(x = 35, y = -70, 
        label = paste0(&amp;quot;beta: &amp;quot;, round(humidity_beta, 3)), 
        group = formula), 
    parse = TRUE, 
    family = &amp;quot;Fira Sans&amp;quot;, 
    size = 4) +
  labs(
    x = &amp;quot;Humidity&amp;quot;, 
    y = &amp;quot;Partial Predicted High Temperature (plus residual, °F)&amp;quot;, 
    subtitle = &amp;quot;{closest_state}&amp;quot;
  ) +
  transition_states(formula, transition_length = 0.25, state_length = 0.5) +
  enter_fade() +
  ease_aes(&amp;#39;sine-in-out&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/partialling-out/index_files/figure-html/animated-1.gif&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;p&gt;Two notes about the confidence interval&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;The confidence intervals here don’t look like the ordinary hourglass-shaped intervals in linear regression. This is because the hourglass shape comes from uncertainty in both the constant and coefficients. However, the constant has been subtracted out of these predictions, so uncertainty in this visualization only reflects uncertainty in the humidity effect.&lt;/li&gt;
&lt;li&gt;I would show confidence intervals with &lt;code&gt;geom_ribbon()&lt;/code&gt;, except I can’t get ribbons to animate because of some weird stuff that’s interfering with &lt;a href=&#34;https://github.com/thomasp85/transformr&#34;&gt;transformr&lt;/a&gt; during animation.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;thats-it&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;That’s it&lt;/h1&gt;
&lt;p&gt;I don’t have comments enabled on the website but get at me on &lt;a href=&#34;https://twitter.com/mikedecr&#34;&gt;Twitter&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;Maybe it’s a dev version thing, but &lt;code&gt;scales::degree_format()&lt;/code&gt; doesn’t work for me, so I removed it.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
