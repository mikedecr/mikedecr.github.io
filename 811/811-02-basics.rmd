---
title: Getting Started with R
description: "Getting R up and running"
author: "Michael DeCrescenzo"
date: '2018-02-08'
slug: "811-basics"
categories: ["Teaching"]
tags: ["ps811", "R"]
---


```{r setup, echo = FALSE}
knitr::opts_chunk$set(cache = TRUE)
```


# Schedule:

Read this before our first R lecture.


# How to follow along

Follow the instructions in this lesson in *your own* `.R` script.


# Objectives

This document describes how to get started with R and understand its basics. We discuss installing R, running simple commands, and some elementary programming concepts such as indexing, logic, and functions. We close with some higher-level discussion about the differences between R and Stata. 

**Note:** Although I promised concrete lessons, this one unfortunately has to be a little more "abstract" than others. This is because we exploring R's *general* behavior rather than a concrete application of R workflow. Luckily, this will be short, and we get much more concrete in future lessons. 

You should take this lesson slowly at first if you have not played with R before. Mess around with some of the code if it helps you understand what it's doing. Type it yourself bit by bit, so you can see what each component does. If you encounter material that does not make sense, please take note of it so we can review it in class before progressing too far.


# How to read these lessons

Pages in this series contain code blocks that you can paste into R. Some of the code blocks are included with their results.

```{r, eval = FALSE}
"Code appears in blocks like this."
"You can paste this code directly into R."
```

```{r, echo = FALSE}
"Results appear on this page with two '##' signs on the left"
```



# Installing R

If you have not set up R already, click [here](https://mirror.las.iastate.edu/CRAN/) to download R for your operating system (if you haven't already). 

A little bit about what's going on here: R is open source and is distributed from various ["mirrors,"](https://en.wikipedia.org/wiki/Mirror_website) which are clone websites that contain essentially identical information. The CRAN (Comprehensive R Archive Network) hosts these mirrors [all over the world](https://cran.r-project.org/mirrors.html). It is generally recommended that you install R (and related software like R packages) using mirrors in nearby locations. Any mirror in the U.S. should be fine for our purposes. The link at the top of this section uses the Iowa State University mirror.

Once R is downloaded, make sure that it is fully installed. You can run R using the GUI app (`R.app` on OSX or `Rgui.exe` on Windows), using the Rstudio application (which we discuss below), or as a program in your computer's command-line shell (which I do, for technical reasons).

If you have a Chromebook or some other computing machine that makes it impossible to install R, try the [Rstudio Cloud](https://rstudio.cloud/) platform.



# Using R

The most essential part of using R is the *console*. This is where results of all commands are displayed. There is a prompt at the bottom of the console where commands can be submitted directly. Yours won't be the same colors as mine, but it looks sort of like this:


```{r, echo = FALSE, out.width = "90%"}
knitr::include_graphics("/images/811/r-console.png")
```


Although you can type commands directly into the console, most commands should be written in a *script file*. Script files serve the same purpose as they do in Stata; they provide a record of all commands you want to run in your analysis. This lets you replicate your analysis the next day, the next week, the next year, or whenever (presuming your code does not become obsolete for some reason).



# Editing an R script file

Script files in R are similar to Stata. They are a place where your code should live, and you should execute code by sending it to the console to be evaluated. 

Use whatever program you desire to open a script file. 

- The basic R application has a script editor (accessed using the `File` menu or a keyboard shortcut). 
- Many newcomers enjoy [Rstudio](https://www.rstudio.com/products/rstudio/) an application that provides tons of tools for R. Rstudio has many advanced features as well, so it isn't only for newcomers. 
- You can also use third-party editors, but you will need to figure out how to send commands to the R console. I use [Sublime Text](https://www.sublimetext.com/) with the [R-Box package](https://packagecontrol.io/packages/R-Box) to send commands to R. 
- Windows users may find Notepad++ or TextMate to be useful text editors. 
- Advanced programmers may use Emacs or Vim with some package (such as ESS for Emacs) to speak to an R console.

I would recommend any external editor that can send commands to the R console and, as you become more comfortable with R, that contains some keyboard shortcuts for writing code quickly. Rstudio, it so happens, comes standard with many such shortcuts.


# What goes in an R file (code and comments)

Script files should begin with some description of the script's purpose. You can include comments (text that will not be executed as R commands) after the `#` symbol. For example, your script file for this lesson might contain some comments at the top like...

```{r}
# ------------------------------------------------------------
#  PS 811: statistical computing for political science
#  Lesson 1: Basics of R
# ------------------------------------------------------------
```

Comments are great for describing what code is doing, planning an analysis, writing notes to yourself, and so on. Comments are also great for *pseudocode*, which are notes to yourself that "translate" what code is doing into English. We will see some examples of this as the course progresses.

An R script file may begin with some common operations:

- Setting a working directory (see the next lesson)
- setting up a log file (if desired... I don't do this though!)
- Loading packages for extra functionality
- Setting other project-wide options (e.g. graphics options)

Although a script file can be imperfect while a project is being developed, a well-written script file for a finished project should be organized, easy to read, and run from top to bottom without any errors. This is important for ensuring that you can retrace the steps of your analysis.

We should save this file in a designated location for this course. Navigate to your `ps811` folder on your computer (which you should already have...), create a subfolder called `R`, and then within the R folder, create another `lessons` folder. Save this document in the `ps811/R/lessons/` folder. (This syntax represents folder pathways in your computer's file system. We'll be seeing more of this later.)




# Executing commands

Just like Stata, R processes commands one at a time. Commands are compiled while they are executed, so if something is wrong with your code, you may not realize it until you try to run it.

Just to demonstrate some basic R behavior, let's run a few commands.

First, R works as a calculator. It can handle mathematical expressions. Paste or type the following lines of code DIRECTLY into the console.

```{r, eval = FALSE}
1 + 1
2 + 2
100 * 2
500 / 4
```

Ignore the `[1]` that prints in the results for now. We will explain it later. 

Now take the above block of code and paste the commands into your script file. Try to run the commands from the script file using the appropriate keyboard shortcut. Most computers and interfaces use `super + enter`, where `super` refers to `Ctrl` on PCs or `Cmd` on Macs. Windows machines may use a different shortcut, such as `Ctrl + R`. Take this opportunity to look up the appropriate keyboard shortcut on your own, *before coming to lecture!* :-)




# Variables and assignment

Most of your R code will work with variables rather than raw numbers. Variables generally work the same way they do with math. The expression $x + 4$ can take different values, depending on the value of $x$.

Data must be "assigned" to a variable using the assignment operator `<-`. The `<-` is a combination of a less-than sign `<` and a hyphen `-`.

For example, assign the value of `5` to a variable called `x`.

```{r}
x <- 5
```

After this variable has been created, `x` and `5` mean the same thing as far as R is concerned. 

You can read the `<-` operator as "gets." A left-hand side object name "gets" the results of whatever operation is on the right-hand side. So in the above example, `x` "gets" the value of 5. 

# Printing the contents of an object

We can display the contents of any object in R by simply typing the object name.

```{r}
x
```

That is to say, R "evaluated" the statement `x`, and the result is 5. We could have written some more complex statement for R to evaluate, like a mathematical expression using `x`...

```{r}
x + 4
```




# Vectors: multi-element variables

Most of the variables you will work with in R (such as the variables in a data set) have multiple values. That is, they are *vectors*. 

We can create our own vectors with `c()`, which assigns a series of values to one variable. It can be helpful to think of `c()` as "combine."

```{r}
y <- c(2, 4, 6)
```

The `y` object now contains 2, 4, and 6. 

```{r}
y
```

If you wrap an assignment statement inside of parentheses, R will assign the values *and* print the result.

```{r}
(y <- c(2, 4, 6))
```

Vectors are useful for performing operations on every element in the vector. Just as we could do math with a vector...

$\begin{align} 2 \cdot \begin{bmatrix} 2 \\ 4 \\ 6 \end{bmatrix} = \begin{bmatrix} 4 \\ 8 \\ 12 \end{bmatrix} \end{align}$

we can also do similar things in R.

```{r}
2 * y
```

A note about multiplying vectors: by default, R does element-wise multiplication (the "Hadamard product"). To do matrix-style multiplication (dot product/inner product) with vectors, we have a different operator.

```{r}
# element-wise product:
y * y

# dot product
y %*% y
```




# Everything is an Object

In R, everything is an object. I can store any value as a variable, which is an object. A text string is an object. A dataset. A variable within a dataset is an object within an object. It's objects all the way down. This makes R very flexible. 





# Indexing

You can access individual elements in a vector using *indexing* notation with square brackets. Using the variable `y` from above, what are the first, second, and third elements?

```{r}
# entire y vector
y
# first element of y
y[1]
# second element of y
y[2]
# third element of y
y[3]
```

This is akin to indexing in math, where we could write $y_{1} = 2$, $y_{2} = 4$, and so on. 

This is why the console prints a little `[1]` next to all results. The `[1]` indicates that the adjacent element is the first element of the results. If we print a longer object, this becomes clearer. For example, 30 repetitions of the word `"hello"`. 

```{r}
# repeat "hello" 30 times
rep("hello", 30)
```

Indexing works with higher-dimensional data as well. Here is a two-dimensional array of numbers. 

```{r}
# row-bind separate vectors
m <- rbind(c(1, 2), 
           c(3, 4), 
           c(5, 6))
m
```

(Notice how `rbind()` binds vectors together as rows. The `cbind()` function would bind vectors as columns.)

To index a multi-dimensional object, use commas to separate the dimensions. The notation `object[a, b]` would reference the value in row `a` and column `b`.

```{r}
m[2, 2]
```

If we specify a row but don't specify a column, R returns every column from the specified row. 

```{r}
m[1, ]
```

If we specify a column but don't specify a row, R returns every row from the specified column. 

```{r}
m[ , 2]
```

Even though `m[ , 2]` is the second *column* of `m`, the results don't print as a vertical column. Why? Because once R evaluates `m[ , 2]`, it simply returns an object. R no longer remembers that it comes from `m`. The result is nothing more than a vector floating there. As far as R is concerned, `m[ , 2]` is exactly equivalent to a vector `c(2, 4, 6)`. *This is actually good*; it's exactly the kind of flexibility that will be valuable in the future. 

## R is one-indexed

R is one-indexed, meaning the first element of a vector is element `1`. Some languages (like `C`) are zero-indexed. Even though R is one-indexed, calling the 0'th element of a variable does not throw an error, so be careful.

## Indexing in practice

The code we use in this course (heavily derived from the `tidyverse` suite of packages) does not require much explicit indexing. However, you should understand the intuition of indexing for a few reasons. 

- It has useful mathematical parallels, where $y_{i}$ is analogous to `y[i]`. This sometimes comes in handy for dealing with the results from statistical models. 
- You will encounter it when searching through message boards for R help. 


# Logic

Logic as a concept in programming is less daunting than it sounds. At it's core, we're working with statements that evaluate to either `TRUE` or `FALSE`. 

Example: is 1 greater than 0?

```{r}
1 > 0
```

Let's make a new vector, a sequence of values from 1 to 10. 

```{r}
(g <- 1:10)
```

Now that we have this vector, we can derive logical statements about it. Which elements are greater than 5?

```{r}
g > 5
```

The statement `g > 5` is a "logical vector," meaning that its a vector whose values are either `TRUE` or `FALSE`. `TRUE` and `FALSE` are keywords in R (and must be capital). R asks if `g` is greater than 5, and since `g` is a vector, R returns a vector of logicals with each element corresponding to the original elements in `g`. 

There are many logical operators. Here are some: 


```{r}
# g "is equal to" 5 (DOUBLE EQUALS)
g == 5

# g "is greater than" 5
g > 5

# g "is less than" 5
g < 5

# g "is greater than or equal to" 5
g >= 5

# g "is less than or equal to" 5
g <= 5
```

This seems a little abstract right now, but here's how you may see others use logic for indexing. Let's say that I have some data from countries around the world, and I want to look only at the European data. You might see someone online limit the data like so.

```{r, eval = FALSE}
world_data[region == "Europe", ]
```

Translated: retrieve the `world_data` object, but only the rows (notice the comma in the indexing) where `region` is equal to `"Europe"`. 

More literally, the statement `region == "Europe"` is either `TRUE` or `FALSE` for every observation in the data. The above statement returns the rows from `world_data` where `region == "Europe"` evaluates to `TRUE`. 

As mentioned above, we will perform this kind of case selection with a more intuitive syntax that is easier to wrap your brain around.


# Data types

There are a few different types of data in R. 

- Logical: `TRUE`s and `FALSE`s.
- Numeric: including integers and doubles
- Strings: text strings that are contained in `"quotes"`. R calls these "character" type variables.
- Factors: ordered categories with text labels

Factors are akin to labelled variables in Stata. They are somewhat like numbers, somewhat like text strings. They are like strings because they havea  text label, and you can't do math with them. They are like numbers because you can put them in order. Put another way, factors are *ordered categories* that have textual metadata. 

It is possible to coerce data from type to another. We cover this in our final lesson.

Note: data types are different from *object classes*. Data type describes the values, but object classes describes the organization of values. Classes include vectors, matrices, data frames, tables, lists, and so on.


# Missing data

Vectors might contain missing data. The missing data code in R is capital `NA`, without quotes. 

Missing data take the same data type as the vector in which they are located. For example:

```{r}
h <- c(1, 2, NA, 4)
# what data type is h?
str(h)
```

By placing `NA` inside a numeric vector, what we've told R is that we know that the missing data is numeric, we just don't know what the number is. If some function requires that we know every value, it will probably fail. Try the following.

```{r}
mean(h)
```

This doesn't cause an *error*. Instead, the result is a missing value. What this means is, we know that there *should* be a numeric mean (which is why there is no error), we just don't know what the mean is because we don't know what all of `h` is. When we want to calculate this value irrespective of the missing values, we often need to tell R to skip over missing values.

```{r}
mean(h, na.rm = TRUE)
```

Many functions have `na.rm` ("remove `NA`") arguments that can be flipped on, such as `sum()`, `sd()`, and so on. 



# Functions

In math, you can manipulate a variable with a function, $f(x)$. There are tons of functions that you can use in R. 

There are three things you need to use a function.

1. The function name itself. Self-explanatory. 
2. Parentheses. This tells R that the object name is meant to be a function.
3. Arguments inside the parentheses. These may be optional, depending on the function and its default behaviors. Arguments can be data that you pass to the function (as inputs), settings that you modify, and so on.

Some easy, common functions.

```{r}
# 10 thousand random samples from a normal distribution
x <- rnorm(n = 10000, mean = 0, sd = 1)

# sum
sum(x) 
# number of elements in an object
length(x) 
# mean
mean(x) 
# variance
var(x) 
# standard deviation
sd(x) 
```

It is easy to write your own functions in R. We will cover this in the final lesson.

# Help files

Get help on any function using `?function_name` or `help(function_name)`.


# External Packages (for non-base functions)

Base R only contains a small number of functions. Most analyses require more complicated tools that are not standard with R. For these tasks, there are hundreds of packages available for download. 

Official R packages are hosted on CRAN and can be installed with code. For example, the following code will install the `tidyverse` package. Because the package depends on other packages, all required packages will be downloaded if not already on your system. As a result, this command would take a while to execute (but you should execute it...we will use this package in class).

```{r, eval = FALSE}
install.packages("tidyverse")
```

Install multiple packages using `c()` to combine package names. Run this command as well. We will use all of these packages throughout our lessons.

```{r, eval = FALSE}
install.packages(c("magrittr", "haven", "labelled", "broom", "ggplot2", "stargazer", "texreg", "xtable", "Rmisc", "mvtnorm"))
```





# Moving on

If you have made it this far, take a break! 

I want to remind you that future lessons will be far less abstract than this one. Many concepts in this lesson are *important* in the sense that you will see them again during your R career, but they are not all *essential* for surviving this course. Future lessons will be far more concrete and dataset-driven.

Continue with the next lesson: [Data Manipulation](811/811-data)








