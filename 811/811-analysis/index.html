<!DOCTYPE html>
<html lang="en-us">
  <head>

  

  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Michael DeCrescenzo">
  <meta name="description" content="Ph.D. Candidate, Political Science, University of Wisconsin–Madison">
  <meta name="keywords" content="political science, university of wisconsin madison, uw madison">
  
  <link rel="prev" href="/811/811-graphics/" />
  
  <link rel="canonical" href="/811/811-analysis/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/site/apple-touch-icon.png">
  <link rel="icon" href="/images/site/favicon-area-chart.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/images/site/favicon-area-chart.ico" type="image/x-icon">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Lecture 3: Analysis | Michael DeCrescenzo
       
  </title>
  <meta name="title" content="Lecture 3: Analysis | Michael DeCrescenzo">
    

  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "/"
    },
    "articleSection" : "811",
    "name" : "Lecture 3: Analysis",
    "headline" : "Lecture 3: Analysis",
    "description" : "Statistical analysis, model output, and workflow integration",
    "inLanguage" : "en-us",
    "author" : "Michael DeCrescenzo",
    "creator" : "Michael DeCrescenzo",
    "publisher": "Michael DeCrescenzo",
    "accountablePerson" : "Michael DeCrescenzo",
    "copyrightHolder" : "Michael DeCrescenzo",
    "copyrightYear" : "2018",
    "datePublished": "2018-02-23 00:00:00 &#43;0000 UTC",
    "dateModified" : "2018-02-23 00:00:00 &#43;0000 UTC",
    "url" : "/811/811-analysis/",
    "wordCount" : "11161",
    "keywords" : [ "ps811","R", "Michael DeCrescenzo"]
}
</script>

  <script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        

<nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
         <a href="/">Home</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/about/" title="">About</a>
                
                <a class="menu-item" href="/research/" title="">Research</a>
                
                <a class="menu-item" href="/teaching/" title="">Teaching</a>
                
                <a class="menu-item" href="/code/" title="">Code</a>
                
                <a class="menu-item" href="/contact/" title="">Contact</a>
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="/">Michael DeCrescenzo</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/about/" title="">About</a>
                
                <a class="menu-item" href="/research/" title="">Research</a>
                
                <a class="menu-item" href="/teaching/" title="">Teaching</a>
                
                <a class="menu-item" href="/code/" title="">Code</a>
                
                <a class="menu-item" href="/contact/" title="">Contact</a>
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
        </div>
    </div>
</nav>


    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Lecture 3: Analysis</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="/" rel="author">Michael DeCrescenzo</a>
                <span class="post-time">
                on <time datetime=2018-02-23 itemprop="datePublished">February 23, 2018</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="/categories/teaching/"> Teaching </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <pre class="r"><code>knitr::opts_chunk$set(cache = TRUE)</code></pre>
<div id="schedule" class="section level1">
<h1>Schedule</h1>
<p>Read this before our final lecture, after the <a href="811/811-graphics">graphics lesson</a>.</p>
</div>
<div id="how-to-follow-along" class="section level1">
<h1>How to follow along</h1>
<p>A script file walking through some of these commands is available <a href="https://uwmadison.box.com/s/r224nk4rjll638dhndigeksvhwjuaq3q">here</a>.</p>
</div>
<div id="objectives" class="section level1">
<h1>Objectives</h1>
<p>In this lesson, we will introduce how to do statistical analysis using R. Topics that you should cover to prepare for the take-home exercise include…</p>
<ul>
<li>Means, confidence intervals, and simple significance tests</li>
<li>Estimating regression models</li>
<li>Generating model output</li>
<li>Model diagnostics and fit statistics</li>
<li>Post-estimation graphics (model predictions)</li>
</ul>
<p>This page also contains some content on more advanced topics, but these won’t be necessary for the take-home exercise. These include…</p>
<ul>
<li>intermediate R tools and routines</li>
<li>lists</li>
<li><code>apply()</code> functions</li>
<li>mapping functions to nested data frames</li>
<li>custom functions</li>
<li>type coercion</li>
<li>a reference list of tools for advanced analysis</li>
<li>time series</li>
<li>panel models</li>
<li>multilevel models</li>
<li>Bayesian models</li>
<li>etc.</li>
</ul>
<p>Since we should be getting used to R, I will sprinkle some more interesting data manipulation tricks into the analysis. Pay careful attention, as some of these tricks may come in handy in the future! As always, I recommend you run pipe chains chunk by chunk so you can see how each function in the chain contributes to the final result.</p>
</div>
<div id="data-and-packages" class="section level1">
<h1>Data and packages</h1>
<p>Load packages.</p>
<pre class="r"><code>library(&quot;Rmisc&quot;)
library(&quot;magrittr&quot;)
library(&quot;tidyverse&quot;)
library(&quot;ggplot2&quot;)
library(&quot;broom&quot;)</code></pre>
<p>Set the default <code>ggplot</code> theme.</p>
<pre class="r"><code>theme_set(theme_bw())</code></pre>
<p>Set your directory and read data from that we saved at the end of the previous lesson.</p>
<pre class="r"><code>setwd(&quot;~/path/to/wherever&quot;)
anes &lt;- readRDS(&quot;data/anes-modified-2.RDS&quot;) %&gt;% print()</code></pre>
</div>
<div id="non-regression-analysis" class="section level1">
<h1>Non-regression analysis</h1>
<p>Previous lessons covered two major types of non-statistical analysis. We saw how to create some simple tables of variables in your data (using either the <code>table()</code> function or the <code>count()</code> function). We also saw how to create graphics, which are a major arena of non-statistical analysis.</p>
<div id="estimates-and-confidence-intervals" class="section level2">
<h2>Estimates and confidence intervals</h2>
<p>When we generate estimates from data, we are usually interested in the point estimate and the uncertainty in that estimate.</p>
<p>The <code>Rmisc</code> package has <code>CI</code> and <code>group.CI</code> functions for estimating means with confidence intervals. The <code>group.CI()</code> function is better than <code>CI()</code> for several reasons, so we’ll use for subgroup estimates and ungrouped estimates.</p>
<p>For ungrouped estimates, we use the following syntax.</p>
<pre class="r"><code># CIs for no groups
#   place a `1` where you&#39;d otherwise put a group variable
group.CI(libcon_self ~ 1, data = anes)</code></pre>
<pre><code>##   libcon_self.upper libcon_self.mean libcon_self.lower
## 1          4.254325         4.238207          4.222089</code></pre>
<p>Remember that every confidence interval has associated assumptions. This interval assumes that the sampling distribution of the mean is normally distributed. This is often a fine assumption, but the fact that we have only seven valid values makes this variable slightly problematic. (You would probably not get pushback for doing this though, because most people don’t think about these assumptions).</p>
<p>You can add a grouping variable like so. We’ll estimate the mean ideological self-placement within each party ID on the 7-point partisanship index.</p>
<pre class="r"><code>group.CI(libcon_self ~ pid7, data = anes)</code></pre>
<pre><code>##   pid7 libcon_self.upper libcon_self.mean libcon_self.lower
## 1    1          3.475202         3.435936          3.396670
## 2    2          3.887528         3.854468          3.821408
## 3    3          3.669637         3.630272          3.590906
## 4    4          4.231836         4.190113          4.148389
## 5    5          4.779278         4.740784          4.702289
## 6    6          4.804295         4.771926          4.739557
## 7    7          5.502972         5.468599          5.434226</code></pre>
<p>The <code>group.CI()</code> function returns a data frame, so you could plot this pretty easily. We’ll add a dividing line at “moderate.”</p>
<pre class="r"><code># calculate mean self-placement, by party ID
# since 2000 only

mean_ideo &lt;- anes %&gt;%
  filter(cycle &gt;= 2000) %&gt;% 
  group.CI(libcon_self ~ pid7, data = .) %&gt;%
  print()</code></pre>
<pre><code>##   pid7 libcon_self.upper libcon_self.mean libcon_self.lower
## 1    1          3.289021         3.227399          3.165776
## 2    2          3.703974         3.641940          3.579906
## 3    3          3.625136         3.561119          3.497103
## 4    4          4.247556         4.181102          4.114649
## 5    5          4.963396         4.895777          4.828159
## 6    6          5.002320         4.943096          4.883872
## 7    7          5.759156         5.706492          5.653827</code></pre>
<pre class="r"><code># plot self-placement over party ID
# modifying axis scales
# confidence intervals are there, just small

ggplot(mean_ideo, aes(x = as.factor(pid7), y = libcon_self.mean)) + 
  geom_hline(yintercept = 4, color = &quot;gray50&quot;) +
  geom_pointrange(aes(ymin = libcon_self.lower, ymax = libcon_self.upper)) +
  labs(y = &quot;Ideological Self-Placement&quot;,
       x = &quot;Party ID&quot;) +
  scale_x_discrete(labels = c(&quot;Strong\nDem&quot;, &quot;Weak\nDem&quot;, &quot;Lean\nDem&quot;, &quot;Independent&quot;, &quot;Lean\nRep&quot;, &quot;Weak\nRep&quot;, &quot;Strong\nRep&quot;)) +
  scale_y_continuous(breaks = 1:7,
                     labels = c(&quot;Very Lib&quot;, &quot;Lib&quot;, &quot;Slight Lib&quot;, 
                                &quot;Moderate&quot;, 
                                &quot;Slight Con&quot;, &quot;Con&quot;, &quot;Very Con&quot;)) +
  coord_cartesian(ylim = c(1, 7)) +
  theme(panel.grid.minor = element_blank())</code></pre>
<p><img src="/811/811-05-analysis_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<p>Be warned. Because the <code>group.CI()</code> function returns a data frame and not just a single value, it will make <code>dplyr::summarize()</code> upset if you try to group a data frame and estimate that way. We can show an advanced way of dealing with this later (nesting and mapping).</p>
<p>Let’s do one more example where we try to detect some evidence of ideological polarization/sorting over time. We’ll track how the mean ideology among Democrats and Republicans changes over time. We use the <code>as_data_frame()</code> function to convert the table to a tibble (for nicer printing).</p>
<pre class="r"><code># collapse party into Ds and Rs, else NA
# Find mean self-placement in each party, in each cycle
# convert to data_frame for prettier printing

sorting &lt;- anes %&gt;%
  mutate(party = case_when(pid7 %in% 1:3 ~ &quot;Democrat&quot;,
                           pid7 %in% 5:7 ~ &quot;Republicans&quot;)) %&gt;%
  group.CI(libcon_self ~ party + cycle, data = .) %&gt;%
  as_data_frame() %&gt;%
  print()</code></pre>
<pre><code>## # A tibble: 38 x 5
##    party       cycle libcon_self.upper libcon_self.mean libcon_self.lower
##    &lt;chr&gt;       &lt;dbl&gt;             &lt;dbl&gt;            &lt;dbl&gt;             &lt;dbl&gt;
##  1 Democrat     1972              3.86             3.77              3.68
##  2 Republicans  1972              4.73             4.64              4.55
##  3 Democrat     1974              3.84             3.73              3.63
##  4 Republicans  1974              4.85             4.74              4.62
##  5 Democrat     1976              3.89             3.79              3.70
##  6 Republicans  1976              4.98             4.88              4.79
##  7 Democrat     1978              3.85             3.76              3.67
##  8 Republicans  1978              4.96             4.86              4.76
##  9 Democrat     1980              3.95             3.83              3.70
## 10 Republicans  1980              5.09             4.98              4.86
## # ... with 28 more rows</code></pre>
<pre class="r"><code># plot ideological self-placement
# Democrats and Republicans across time

ggplot(sorting, aes(x = cycle, y = libcon_self.mean, color = party)) +
  geom_line(show.legend = FALSE) +
  geom_point(show.legend = FALSE) +
  geom_ribbon(aes(ymin = libcon_self.lower, ymax = libcon_self.upper, 
                  fill = party),
              alpha = 0.3,
              color = NA,
              show.legend = FALSE) +
  coord_cartesian(ylim = c(1, 7)) +
  annotate(&quot;text&quot;, x = 2000, y = 2.5, label = &quot;Democrats&quot;) +
  annotate(&quot;text&quot;, x = 2000, y = 6.25, label = &quot;Republicans&quot;) +
  scale_y_continuous(breaks = 1:7,
                     labels = c(&quot;Very\nLiberal&quot;, &quot;Liberal&quot;, &quot;Slightly\nLiberal&quot;, 
                                &quot;Moderate&quot;, 
                                &quot;Slightly\nConservative&quot;, &quot;Conservative&quot;, &quot;Very\nConservative&quot;)) +
  scale_x_continuous(breaks = seq(1972, 2012, 8)) +
  scale_color_manual(values = c(&quot;dodgerblue&quot;, &quot;maroon&quot;)) +
  scale_fill_manual(values = c(&quot;dodgerblue&quot;, &quot;maroon&quot;)) +
  labs(x = &quot;Election Cycle&quot;,
       y = &quot;Mean Ideological Self-Placement&quot;,
       color = NULL, fill = NULL) +
  theme(panel.grid.minor = element_blank())</code></pre>
<p><img src="/811/811-05-analysis_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
</div>
<div id="proportions" class="section level2">
<h2>Proportions</h2>
<p>For proportions, one could use <code>prop.test()</code> for the normal approximation method (which most people learn in school), or <code>binom.test()</code> for “exact” Clopper-Pearson intervals, which have better boundary assumptions and small-sample properties (they are estimated using quantiles of the beta distribution), but they can be conservative (a little wide, more than 95% coverage in some cases). They both work in R basically the same way though.</p>
<pre class="r"><code># find the number of democratic voters in 2012, say. Sum the TRUEs
dem_voters &lt;- anes %&gt;%
  filter(cycle == 2012) %$% 
  sum(vote == &quot;Democratic Candidate&quot;, na.rm = TRUE) %&gt;%
  print()</code></pre>
<pre><code>## [1] 2496</code></pre>
<pre class="r"><code># find the num. of major party voters in 2012
twoparty_voters &lt;- anes %&gt;%
  filter(cycle == 2012) %$% 
  sum(vote %in% c(&quot;Democratic Candidate&quot;, &quot;Republican Candidate&quot;), 
      na.rm = TRUE) %&gt;%
  print()</code></pre>
<pre><code>## [1] 4188</code></pre>
<pre class="r"><code># estimate demvoters / majorparty voters, with CI
results &lt;- anes %$% 
  prop.test(dem_voters, twoparty_voters)

# view results
results</code></pre>
<pre><code>## 
##  1-sample proportions test with continuity correction
## 
## data:  dem_voters out of twoparty_voters, null probability 0.5
## X-squared = 153.97, df = 1, p-value &lt; 2.2e-16
## alternative hypothesis: true p is not equal to 0.5
## 95 percent confidence interval:
##  0.5809257 0.6108740
## sample estimates:
##         p 
## 0.5959885</code></pre>
<pre class="r"><code># this is a complex object. See what&#39;s inside of it
attributes(results)</code></pre>
<pre><code>## $names
## [1] &quot;statistic&quot;   &quot;parameter&quot;   &quot;p.value&quot;     &quot;estimate&quot;    &quot;null.value&quot; 
## [6] &quot;conf.int&quot;    &quot;alternative&quot; &quot;method&quot;      &quot;data.name&quot;  
## 
## $class
## [1] &quot;htest&quot;</code></pre>
<pre class="r"><code># let&#39;s grab the point estimate. 
# We can use $ to go &quot;inside&quot; this object
results$estimate</code></pre>
<pre><code>##         p 
## 0.5959885</code></pre>
<pre class="r"><code># grab the confidence interval in the same way
# it is a two-element vector (with some metadata)
results$conf.int</code></pre>
<pre><code>## [1] 0.5809257 0.6108740
## attr(,&quot;conf.level&quot;)
## [1] 0.95</code></pre>
<p>As you can see, these old hypothesis testing functions produce weird objects as output, making them feel ancient and complex. It gets tougher to organize mentally if you need to estimate proportions for multiple groups. I’ll show you how, but it’s a little complicated.</p>
<pre class="r"><code># Objective
# a numerator and a denominator in every row
# group the data and apply the test function to each row

# groups = party ID
# find num of dem voters (numerator) and major party voters (denominator)

# In this chain, we take the sum of a logical variable
#   in arithmetic, logical variables are like dummy variables
#   (TRUE is treated as a 1, FALSE as a 0)

grp_raw &lt;- anes %&gt;%
  filter(cycle == 2012) %&gt;%
  filter(!is.na(pid7)) %&gt;% 
  group_by(pid7) %&gt;%
  summarize(dem_voters = 
              sum(vote == &quot;Democratic Candidate&quot;, na.rm = TRUE),
            twoparty_voters = 
              sum(vote %in% c(&quot;Democratic Candidate&quot;, &quot;Republican Candidate&quot;),
                  na.rm = TRUE)) %&gt;%
  print()</code></pre>
<pre><code>## # A tibble: 7 x 3
##    pid7 dem_voters twoparty_voters
##   &lt;dbl&gt;      &lt;int&gt;           &lt;int&gt;
## 1     1       1219            1234
## 2     2        519             605
## 3     3        451             486
## 4     4        174             331
## 5     5         47             428
## 6     6         61             448
## 7     7         18             645</code></pre>
<pre class="r"><code># think of binom.test() as being run separately for each row (group)
# since each row is a group in this case
# separately save mean, lower and upper bounds
grp_prop &lt;- grp_raw %&gt;%
  group_by(pid7) %&gt;%  
  mutate(prop = binom.test(dem_voters, twoparty_voters)$estimate,
         lower = binom.test(dem_voters, twoparty_voters)$conf.int[1],
         upper = binom.test(dem_voters, twoparty_voters)$conf.int[2]) %&gt;%
  print()</code></pre>
<pre><code>## # A tibble: 7 x 6
## # Groups:   pid7 [7]
##    pid7 dem_voters twoparty_voters   prop  lower  upper
##   &lt;dbl&gt;      &lt;int&gt;           &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1     1       1219            1234 0.988  0.980  0.993 
## 2     2        519             605 0.858  0.827  0.885 
## 3     3        451             486 0.928  0.901  0.949 
## 4     4        174             331 0.526  0.470  0.581 
## 5     5         47             428 0.110  0.0818 0.143 
## 6     6         61             448 0.136  0.106  0.171 
## 7     7         18             645 0.0279 0.0166 0.0437</code></pre>
<pre class="r"><code># plot estimates with CIs as pointranges (points plus error bars)

ggplot(grp_prop, aes(x = as.factor(pid7), y = prop)) +
  geom_pointrange(aes(ymin = lower, ymax = upper)) +
  labs(x = &quot;Party ID&quot;,
       y = &quot;Democratic share of two-party vote&quot;,
       caption = &quot;ANES 2012 data&quot;)</code></pre>
<p><img src="/811/811-05-analysis_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<p>Some people have developed tools to make it easier to work with these old functions. The <code>broom</code> package is amazing one. Let’s use the <code>broom::tidy</code> function to clean up the output from the <code>prop.test()</code> function from above.</p>
<pre class="r"><code># results object from before
results </code></pre>
<pre><code>## 
##  1-sample proportions test with continuity correction
## 
## data:  dem_voters out of twoparty_voters, null probability 0.5
## X-squared = 153.97, df = 1, p-value &lt; 2.2e-16
## alternative hypothesis: true p is not equal to 0.5
## 95 percent confidence interval:
##  0.5809257 0.6108740
## sample estimates:
##         p 
## 0.5959885</code></pre>
<pre class="r"><code># tidy results
tidy(results)</code></pre>
<pre><code>##    estimate statistic      p.value parameter  conf.low conf.high
## 1 0.5959885  153.9659 2.356085e-35         1 0.5809257  0.610874
##                                                 method alternative
## 1 1-sample proportions test with continuity correction   two.sided</code></pre>
<p>The <code>tidy()</code> function returns a tidy frame with columns for estimates, test statistics, <span class="math inline">\(p\)</span>-values, confidence interval bounds, and so on. You could run <code>tidy()</code> on lots of different proportions tests, stack them into one data frame, and then plot the results in cool ways. We’ll do something like that later when we cover regression models.</p>
<p>For formal hypothesis testing of means, the <code>t.test()</code> function works a lot like <code>prop.test()</code> and <code>binom.test()</code>. I won’t beat this lesson to death though.</p>
</div>
</div>
<div id="regression" class="section level1">
<h1>Regression</h1>
<p>And now, the good stuff.</p>
<p>R has functions for linear and generalized linear models. They work pretty similarly, with some important exceptions. First, we’ll review regression in general.</p>
<p>A linear model estimates a “predicted value of <span class="math inline">\(y\)</span>” (that is, the <em>mean of <span class="math inline">\(y\)</span>, conditional on <span class="math inline">\(x\)</span></em>) assuming that the observed data are the conditional mean plus a (normally distributed) residual. We could write that a few ways, but let’s start with a familiar way from PS-813.</p>
<p><span class="math inline">\(\begin{align} y_{i} &amp;= \alpha + \beta x_{i} + \varepsilon_{i} \\[6pt] \varepsilon_{i} &amp;\sim \mathrm{Normal} \left( 0, \, \sigma \right) \end{align}\)</span></p>
<p>Each predicted value of the dependent variable (<span class="math inline">\(\hat{y}_{i}\)</span>) is a regression on a set of <span class="math inline">\(x\)</span> variables and coefficients <span class="math inline">\(\beta\)</span> and a constant <span class="math inline">\(\alpha\)</span>, and residuals are normally distributed with mean of <span class="math inline">\(0\)</span> and some estimated standard deviation <span class="math inline">\(\sigma\)</span>.</p>
<p>Here’s how we estimate regression equations in R, generically, using the <code>lm()</code> function.</p>
<pre class="r"><code># this is an example with multiple x variables
# to show that you use the `+` to specify the additive equation form
model_results &lt;- lm(y ~ x1 + x2 + x3, data = dataset_name)</code></pre>
<p>The syntax can read that <code>y</code> is a function of <code>x1</code>, <code>x2</code>, and so on. We also must specify the data set where these data come from with <code>data =</code>.</p>
<p>After estimating, we usually look at detailed results using the <code>summary()</code> function.</p>
<pre class="r"><code>summary(model_results)</code></pre>
<p>Here’s a real example, predicting relative thermometer ratings (<span class="math inline">\(y\)</span>) using ideological self-placement (<span class="math inline">\(x\)</span>), with data from the 2000 election only (note the use of <code>filter()</code> in the <code>data =</code> argument). It seems reasonable that individuals who are more conservative are more likely to feel warmer toward the Republican candidate than they are toward the Democratic candidate.</p>
<pre class="r"><code># relative feeling thermometer as a function of ideology

therm_mod &lt;- lm(reltherm_cand ~ libcon_self, 
                data = filter(anes, cycle == 2000))

# regression summary

summary(therm_mod)</code></pre>
<pre><code>## 
## Call:
## lm(formula = reltherm_cand ~ libcon_self, data = filter(anes, 
##     cycle == 2000))
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -104.115  -22.115    0.922   20.922   75.922 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -56.1059     4.2143  -13.31   &lt;2e-16 ***
## libcon_self  13.0368     0.9446   13.80   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 32.24 on 598 degrees of freedom
##   (1207 observations deleted due to missingness)
## Multiple R-squared:  0.2416, Adjusted R-squared:  0.2403 
## F-statistic: 190.5 on 1 and 598 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>The <code>summary</code> function shows us the estimated coefficients (for the intercept and predictor), standard errors, test statistics, p-values, and significance levels. We also get some information about the F test and explained variance.</p>
<div id="regression-tricks" class="section level2">
<h2>Regression tricks</h2>
<p>Let’s do a multiple regression example. How about we just do this ideological scale as a series of dummy variables instead of as a continuous predictor. We can coerce any variable to series of dummy variables by inputting the variable as a factor in the regression equation.</p>
<pre class="r"><code># &quot;dummy mod&quot;: ideology as a set of dummies using as.factor()

dummy_mod &lt;- lm(reltherm_cand ~ as.factor(libcon_self), 
                data = filter(anes, cycle == 2000))

# each effect is an offset relative to the constant

summary(dummy_mod)</code></pre>
<pre><code>## 
## Call:
## lm(formula = reltherm_cand ~ as.factor(libcon_self), data = filter(anes, 
##     cycle == 2000))
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -106.992  -22.320    0.462   20.462   77.462 
## 
## Coefficients:
##                         Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)              -33.583      9.292  -3.614 0.000327 ***
## as.factor(libcon_self)2    6.888     10.067   0.684 0.494140    
## as.factor(libcon_self)3   13.122      9.981   1.315 0.189122    
## as.factor(libcon_self)4   26.888      9.566   2.811 0.005107 ** 
## as.factor(libcon_self)5   45.276      9.813   4.614 4.85e-06 ***
## as.factor(libcon_self)6   58.575      9.745   6.011 3.23e-09 ***
## as.factor(libcon_self)7   60.289     12.136   4.968 8.87e-07 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 32.19 on 593 degrees of freedom
##   (1207 observations deleted due to missingness)
## Multiple R-squared:  0.2504, Adjusted R-squared:  0.2428 
## F-statistic: 33.01 on 6 and 593 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>The <code>as.factor()</code> coerced the <code>libcon_self</code> variable, which is originally numeric (integers), to be treated as a factor variable. Whenever <code>lm()</code> encounters a factor as an independent variable, R interprets the factor as a set of dummy variables automatically, treating the “first” level as the omitted category. It’s important to remember that when we have dummy variables, each coefficient should be interpret as an <em>offset</em> relative to the intercept. Ordinarily you want to take great care to specify which category should be omitted, because significance testing for the dummy variables will be relative to that baseline category.</p>
<p>If we want, we could rewrite this model by suppressing the intercept entirely with <code>-1</code>. In that case, we would have no omitted category, so each estimated coefficient would essentially represent the mean for each group.</p>
<pre class="r"><code># all-intercepts model (no omitted category =&gt; no constant)

int_mod &lt;- lm(reltherm_cand ~ -1 + as.factor(libcon_self), 
                data = filter(anes, cycle == 2000))

# each estimate is a group mean

summary(int_mod)</code></pre>
<pre><code>## 
## Call:
## lm(formula = reltherm_cand ~ -1 + as.factor(libcon_self), data = filter(anes, 
##     cycle == 2000))
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -106.992  -22.320    0.462   20.462   77.462 
## 
## Coefficients:
##                         Estimate Std. Error t value Pr(&gt;|t|)    
## as.factor(libcon_self)1  -33.583      9.292  -3.614 0.000327 ***
## as.factor(libcon_self)2  -26.696      3.875  -6.889 1.43e-11 ***
## as.factor(libcon_self)3  -20.462      3.645  -5.614 3.03e-08 ***
## as.factor(libcon_self)4   -6.695      2.276  -2.942 0.003393 ** 
## as.factor(libcon_self)5   11.692      3.156   3.705 0.000232 ***
## as.factor(libcon_self)6   24.992      2.938   8.505  &lt; 2e-16 ***
## as.factor(libcon_self)7   26.706      7.807   3.421 0.000667 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 32.19 on 593 degrees of freedom
##   (1207 observations deleted due to missingness)
## Multiple R-squared:  0.2508, Adjusted R-squared:  0.2419 
## F-statistic: 28.35 on 7 and 593 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>This model makes a great deal of sense just looking at it. Each intercept is the estimated mean response for each level of party ID. When respondents are more liberal, they like the Democratic candidate more than the Republican candidate, and vice versa for more conservative respondents. Watch out for significance testing though: right now, p-values are only testing against the null hypothesis that each coefficient is different from zero. You’d have to do some extra work to determine whether one intercept is statistically different from another.</p>
<p>We could, if we want, estimate an intercept-only model (no predictors) of the following form:</p>
<p><span class="math inline">\(\begin{align} y_{i} &amp;= \alpha + \varepsilon_{i} \end{align}\)</span></p>
<p>by writing the formula as <code>y ~ 1</code>. This is also how we used the <code>group.CI()</code> to estimate means without any groups.</p>
<pre class="r"><code># intercept-only model

alpha_mod &lt;- lm(reltherm_cand ~ 1, 
                data = filter(anes, cycle == 2000))

# this makes sense in the math, if you think about it
# the right hand data is a &quot;1&quot;
# y = alpha*1 is equivalent to y = alpha

# (if you&#39;ve seen regression in matrix before, 
#  this is why the first column in the X matrix is a set of 1s)

summary(alpha_mod)</code></pre>
<pre><code>## 
## Call:
## lm(formula = reltherm_cand ~ 1, data = filter(anes, cycle == 
##     2000))
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -94.366 -28.366   1.634  26.634  97.634 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)  
## (Intercept)  -1.6339     0.9131  -1.789   0.0738 .
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 36.47 on 1594 degrees of freedom
##   (212 observations deleted due to missingness)</code></pre>
</div>
</div>
<div id="model-output-tables" class="section level1">
<h1>Model output: tables</h1>
<p>Like Stata, R can produce regression tables for you to insert into your writing. You should use these functions.</p>
<p>In fact, my advice is that you should never, never, <strong><em>NEVER</em></strong> write up a regression table by hand. Not in <span class="math inline">\(\mathrm{\LaTeX}\)</span>, not in Word, not ever.</p>
<ul>
<li>You are likely to make some kind of transcription error by hand-typing numbers into the table</li>
<li>If your analysis ever changes, even slightly, you need to modify your table or create a brand-new one</li>
<li>Spend your time researching and doing stats, not punching tables into the computer</li>
</ul>
<p>R provides several packages for formatting the output of an analysis into tables. This output could be formatted as <span class="math inline">\(\mathrm{\LaTeX}\)</span> code, as HTML code, as plain text, and so on. We’ll play with some table packages using the models we just estimated.</p>
<p>The <code>stargazer</code> package is solid and highly customizable. Its tables look good, but I find that it requires a lot of customization to make the tables look <em>great</em>.</p>
<pre class="r"><code>library(&quot;stargazer&quot;)
# latex by default
stargazer(therm_mod, dummy_mod, int_mod)
# as plain text
stargazer(therm_mod, dummy_mod, int_mod, type = &quot;text&quot;)</code></pre>
<p>I think I like <code>texreg</code> a little better. I’m fairly sure it supports more model types than <code>stargazer</code>, and its defaults are a bit more sensible than <code>stargazer</code>’s are, at least for my uses (your uses may be different).</p>
<pre class="r"><code>library(&quot;texreg&quot;)
texreg(list(therm_mod, dummy_mod, int_mod))</code></pre>
<p>I love <code>xtable</code> for <em>non-regression tables</em> such as marginals and summary statistics. The tables are clean, slick, and you can get them to do what you want. (See the tables at the end of <a href="https://elections.wisc.edu/news/Voter-ID-Study/Voter-ID-Study-Supporting-Info.pdf">this document</a>, for example.) However, <code>xtable</code> is weirder for regression, and it’s strange in general because it often requires you to place more arguments into the <code>print()</code> function, which is counter-intuitive. But these tables look great when you can make it work.</p>
<pre class="r"><code>library(&quot;xtable&quot;)
print(xtable(therm_mod))</code></pre>
<p>These aren’t the only tools for making tables in R. Check <a href="https://stackoverflow.com/questions/5465314/tools-for-making-latex-tables-in-r">here</a> for more info.</p>
<p>My general practice is to rely <em>only</em> on code to make tables. This ensures that you don’t make any transcription errors. It also ensures that when you export these tables to an external file (next section), any update to the model in R is automatically updated in your paper (if using <span class="math inline">\(\mathrm{\LaTeX}\)</span>).</p>
<p>Here’s how I advise you learn about tables:</p>
<ul>
<li>Experiment with the packages to figure out which package you like best</li>
<li>Figure out which modifications to the default tables you tend to use the most</li>
<li>Save these modifications somewhere (in a file, or as a keyboard shortcut), to save yourself some time whenever you write regression tables into a paper</li>
</ul>
</div>
<div id="exporting-regression-tables" class="section level1">
<h1>Exporting regression tables</h1>
<p>This is not that difficult, but it requires some thinking about your project directory.</p>
<p>Whenever you have some project, your directory should contain separate folders for <code>R/</code>, <code>data/</code>, and your writing (which I call <code>tex/</code> or <code>paper/</code>). Let’s assume that we’re writing a <span class="math inline">\(\mathrm{\LaTeX}\)</span> document inside a folder called <code>tex/</code>, and we want to save a regression table from R. We should also assume that our directory in R is set to the <em>project root</em>, i.e. the top of the project folder (for example, <code>&quot;users/michaeldecrescenzo/box sync/research/thesis&quot;</code>).</p>
<p>We can use R to create a subfolder inside of the <code>tex/</code> folder dedicated to tables, if we don’t already have one.</p>
<pre class="r"><code># makes a &quot;tex&quot; folder
dir.create(&quot;tex&quot;)


# make a tables/ folder inside of tex/
# requires a tex/ folder to exist already

dir.create(&quot;tex/tables&quot;)</code></pre>
<p>We can then save model output as a <code>.tex</code> file in this folder location. Table-creating functions allow to you specify where you want the table to save. Specify the name of the <code>.tex</code> file you want to save. (You can also save tables as plain text and HTML files, depending on the package, but you get the most direct utility by learning to use <span class="math inline">\(\mathrm{\LaTeX}\)</span> and saving tables as <span class="math inline">\(\mathrm{\TeX}\)</span> files).</p>
<pre class="r"><code># save texreg table (with caption) as a .tex file, in specified location

texreg(list(therm_mod, dummy_mod, int_mod),
       caption = &quot;Estimated regression results, various specifications&quot;,
       file = &quot;tex/tables/reg-table.tex&quot;)</code></pre>
<p>And then in your <code>research-paper.tex</code> file, you can include a code to insert code from another <code>.tex</code> file somewhere else.</p>
<pre><code>... blah blah blah. See the regression table for results.

\input{tables/reg-table}

The regression table shows that...</code></pre>
</div>
<div id="model-output-graphics" class="section level1">
<h1>Model output: graphics</h1>
<p>New tools in R make it very easy to produce graphical model output.</p>
<p>We’ll talk about the <code>broom</code> package, which we’ve already introduced somewhat. We can turn model output into a tidy data frame using <code>tidy()</code>.</p>
<pre class="r"><code># Tidy the all-intercepts model
# separate columns for variable names, coefficients, std err, p-val...

tidy(int_mod)</code></pre>
<pre><code>##                      term  estimate std.error statistic      p.value
## 1 as.factor(libcon_self)1 -33.58333  9.291709 -3.614333 3.267050e-04
## 2 as.factor(libcon_self)2 -26.69565  3.874911 -6.889360 1.434794e-11
## 3 as.factor(libcon_self)3 -20.46154  3.644508 -5.614348 3.033553e-08
## 4 as.factor(libcon_self)4  -6.69500  2.275995 -2.941571 3.392997e-03
## 5 as.factor(libcon_self)5  11.69231  3.156237  3.704509 2.316008e-04
## 6 as.factor(libcon_self)6  24.99167  2.938296  8.505495 1.475278e-16
## 7 as.factor(libcon_self)7  26.70588  7.806597  3.420938 6.669782e-04</code></pre>
<p>Combine tidy model data frames using <code>bind_rows()</code>, which binds data frame rows together. We do this while also adding a variable for the model name (using <code>mutate()</code>).</p>
<pre class="r"><code>mods &lt;- bind_rows(mutate(tidy(therm_mod, conf.int = TRUE), 
                           model = &quot;Continuous Predictor&quot;), 
                  mutate(tidy(dummy_mod, conf.int = TRUE), 
                           model = &quot;Constant and Dummies&quot;), 
                  mutate(tidy(int_mod, conf.int = TRUE), 
                           model = &quot;All Intercepts&quot;)) %&gt;%
  as_data_frame() %&gt;%
  print() </code></pre>
<pre><code>## # A tibble: 16 x 8
##    term    estimate std.error statistic  p.value conf.low conf.high model 
##    &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt; 
##  1 (Inter…   -56.1      4.21    -13.3   1.33e-35   -64.4     -47.8  Conti…
##  2 libcon…    13.0      0.945    13.8   8.18e-38    11.2      14.9  Conti…
##  3 (Inter…   -33.6      9.29     -3.61  3.27e- 4   -51.8     -15.3  Const…
##  4 as.fac…     6.89    10.1       0.684 4.94e- 1   -12.9      26.7  Const…
##  5 as.fac…    13.1      9.98      1.31  1.89e- 1    -6.48     32.7  Const…
##  6 as.fac…    26.9      9.57      2.81  5.11e- 3     8.10     45.7  Const…
##  7 as.fac…    45.3      9.81      4.61  4.85e- 6    26.0      64.5  Const…
##  8 as.fac…    58.6      9.75      6.01  3.23e- 9    39.4      77.7  Const…
##  9 as.fac…    60.3     12.1       4.97  8.87e- 7    36.5      84.1  Const…
## 10 as.fac…   -33.6      9.29     -3.61  3.27e- 4   -51.8     -15.3  All I…
## 11 as.fac…   -26.7      3.87     -6.89  1.43e-11   -34.3     -19.1  All I…
## 12 as.fac…   -20.5      3.64     -5.61  3.03e- 8   -27.6     -13.3  All I…
## 13 as.fac…    -6.69     2.28     -2.94  3.39e- 3   -11.2      -2.23 All I…
## 14 as.fac…    11.7      3.16      3.70  2.32e- 4     5.49     17.9  All I…
## 15 as.fac…    25.0      2.94      8.51  1.48e-16    19.2      30.8  All I…
## 16 as.fac…    26.7      7.81      3.42  6.67e- 4    11.4      42.0  All I…</code></pre>
<p>We can then plot coefficients straight away. Use the variable name as the <code>x</code> and the coefficient as the <code>y</code></p>
<pre class="r"><code># we flip the x and y coordinates 
#   to imitate the typical look of a coefficient plot
# Notice how not every model has the same variable names...

ggplot(mods, aes(x = term, y = estimate)) +
  geom_hline(yintercept = 0, color = &quot;gray50&quot;) +
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high,
                      color = model),
                  position = position_dodge(width = -1)) +
  scale_color_brewer(palette = &quot;Set2&quot;) +
  coord_flip() +
  labs(x = NULL, y = &quot;Estimated Coefficient&quot;, color = &quot;Specification&quot;)</code></pre>
<pre><code>## Warning: position_dodge requires non-overlapping x intervals</code></pre>
<p><img src="/811/811-05-analysis_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<p>So easy! You could then save this plot…</p>
<pre class="r"><code># creates a graphics folder, if one doesn&#39;t already exist
dir.create(&quot;tex/graphics&quot;)

# save the plot in the graphics folder, setting height and width
# saves as PDF
ggsave(&quot;tex/graphics/coefplot.pdf&quot;, height = 5, width = 5)</code></pre>
<p>Some other tools create these sorts of plots for you. Some folks enjoy using <a href="http://www.strengejacke.de/sjPlot/sjp.lm/"><code>sjPlot</code></a>, but I have never bothered to use it. (I ordinarily don’t like packages to make plots for me. I prefer to create <em>data</em> and decide for myself how they should be plotted. This is my personal preference, though—you do you.)</p>
<div id="related-saving-other-quantities-from-r-to-mathrmlatex" class="section level2">
<h2>Related: saving other quantities (from R to <span class="math inline">\(\mathrm{\LaTeX}\)</span>)</h2>
<p>Just like with tables, you can save many other quantities to <code>tex</code> files. This way, the quantities in your paper reflect quantities in the analysis <em>perfectly</em>.</p>
<p>For example, let’s calculate the mean GOP candidate thermometer in (say) 2012, and save it.</p>
<pre class="r"><code># create a subdirectory for referenced values from R
# I call this folder location &quot;refs&quot; but you can call it whatever you want
dir.create(&quot;tex/refs&quot;)

# in the 2012 cycle, 
# what is the mean thermometer rating of GOP candidate?
# round it to the nearest whole number
# print the value to see what it looks like
# save the value in a .tex file for later use

anes %&gt;% 
  filter(cycle == 2012) %$% # &lt;--- note the pipe!
  mean(therm_gopcand, na.rm = TRUE) %&gt;%
  round() %&gt;%
  print() %&gt;% 
  write(&quot;tex/refs/mean-gop-therm-2012.tex&quot;) </code></pre>
<p>Then, in your <code>.tex</code> file, import this quantity directly from file…</p>
<pre><code>...the mean rating for Mitt Romney was $\input{refs/mean-gop-therm}$</code></pre>
<p>…which would automatically grab the contents of that saved <code>tex</code> file and place it into your paper when you compile the <code>tex</code> document! This practice cuts down human error, saves time (you no longer have to update everything in your <code>.tex</code> file by hand every time you slightly change an analysis), and enhances the <em>reproducibility</em> of your work. I highly recommend it!</p>
</div>
</div>
<div id="predicted-values" class="section level1">
<h1>Predicted values</h1>
<p>You can generate predicted values from the data used to model using <code>predict()</code>.</p>
<pre class="r"><code># try it out
predict(therm_mod)</code></pre>
<p>We can also use <code>predict()</code> to generate predictions for new datasets. This is good for visualizing the effect of one variable, holding others constant. You can do this by creating a “counterfactual dataset” and generating model predicts for the observations in the counterfactual data.</p>
<pre class="r"><code># we only need one variable
# be sure it has the same name as the regression variable

id_frame &lt;- data_frame(libcon_self = 1:7)

# use the estimated model to predict for the new data

predict(therm_mod, newdata = id_frame)</code></pre>
<pre><code>##          1          2          3          4          5          6 
## -43.069118 -30.032334 -16.995550  -3.958767   9.078017  22.114801 
##          7 
##  35.151584</code></pre>
<p>We can also add intervals of various kinds (confidence intervals for means, prediction intervals, and so on). Let’s generate predictions for the linear model and the “all intercepts” model, and then plot them side by side for comparison.</p>
<pre class="r"><code># predictions from linear model, using the new id_frame data

lin_preds &lt;- 
  predict(therm_mod, newdata = id_frame, interval = &quot;confidence&quot;) %&gt;%
  as_data_frame() %&gt;%
  print() </code></pre>
<pre><code>## # A tibble: 7 x 3
##      fit    lwr    upr
##    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1 -43.1  -49.6  -36.5 
## 2 -30.0  -34.9  -25.1 
## 3 -17.0  -20.5  -13.5 
## 4  -3.96  -6.58  -1.34
## 5   9.08   6.13  12.0 
## 6  22.1   17.9   26.3 
## 7  35.2   29.4   40.9</code></pre>
<pre class="r"><code># predictions from intercepts model
# predict() is smart enough to factorize your predictor variable
#   if you factorized it in the model

int_preds &lt;- 
  predict(int_mod, newdata = id_frame, interval = &quot;confidence&quot;) %&gt;%
  as_data_frame() %&gt;%
  print()</code></pre>
<pre><code>## # A tibble: 7 x 3
##      fit    lwr    upr
##    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1 -33.6  -51.8  -15.3 
## 2 -26.7  -34.3  -19.1 
## 3 -20.5  -27.6  -13.3 
## 4  -6.69 -11.2   -2.23
## 5  11.7    5.49  17.9 
## 6  25.0   19.2   30.8 
## 7  26.7   11.4   42.0</code></pre>
<pre class="r"><code># combine!
compare_mods &lt;- 
  bind_rows(mutate(lin_preds, libcon_self = id_frame$libcon_self, 
                              mod = &quot;linear&quot;), 
            mutate(int_preds, libcon_self = id_frame$libcon_self, 
                              mod = &quot;intercepts&quot;)) %&gt;%
  print()</code></pre>
<pre><code>## # A tibble: 14 x 5
##       fit    lwr    upr libcon_self mod       
##     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;       &lt;int&gt; &lt;chr&gt;     
##  1 -43.1  -49.6  -36.5            1 linear    
##  2 -30.0  -34.9  -25.1            2 linear    
##  3 -17.0  -20.5  -13.5            3 linear    
##  4  -3.96  -6.58  -1.34           4 linear    
##  5   9.08   6.13  12.0            5 linear    
##  6  22.1   17.9   26.3            6 linear    
##  7  35.2   29.4   40.9            7 linear    
##  8 -33.6  -51.8  -15.3            1 intercepts
##  9 -26.7  -34.3  -19.1            2 intercepts
## 10 -20.5  -27.6  -13.3            3 intercepts
## 11  -6.69 -11.2   -2.23           4 intercepts
## 12  11.7    5.49  17.9            5 intercepts
## 13  25.0   19.2   30.8            6 intercepts
## 14  26.7   11.4   42.0            7 intercepts</code></pre>
<p>When you have these predictions as a data frame, you could plot!</p>
<pre class="r"><code># plot points with dodging
# suppress minor grid

ggplot(data = compare_mods, aes(x = libcon_self, y = fit)) +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(ymin = lwr, ymax = upr, shape = mod),
                  position = position_dodge(width = 0.25),
                  fill = &quot;white&quot;) +
  scale_x_continuous(breaks = 1:7) +
  scale_shape_manual(values = c(16, 21)) +
  coord_cartesian(ylim = c(-50, 50)) +
  labs(x = &quot;Ideological Self-Placement&quot;,
       y = &quot;Relative Candidate Thermometer\n(Republican minus Democrat)&quot;,
       shape = &quot;Model&quot;) +
  theme(panel.grid.minor = element_blank())</code></pre>
<p><img src="/811/811-05-analysis_files/figure-html/unnamed-chunk-32-1.png" width="672" /></p>
<p>I’ll leave it to you to interpret these models and assess the pros and cons of each.</p>
<div id="packages-for-model-predictions" class="section level2">
<h2>Packages for model predictions</h2>
<p>For more complex post-estimation graphics (e.g. first differences, marginal effects), there are some packages that make your job a little easier. I won’t cover them all (because not everyone engages in these types of predictions), but I’ll lay some out:</p>
<ul>
<li>The <code>broom</code> package (where <code>tidy()</code> comes from) provides the <code>augment</code> function, for augmenting a data frame with predictions from an accompanying model. This works a bit like <code>predict()</code>, but it returns tidy data frames. <code>augment</code> gives you a “standard error of the fit” variable rather than separate variables for upper and lower boundaries, but you can use the standard error to calculate however wide a confidence interval you desire.</li>
<li>The <code>margins</code> package by Thomas Leeper is meant to imitate the workflow of Stata’s <code>margins</code> and <code>marginsplot</code> workflow.</li>
<li><code>sjPlot</code></li>
<li><code>Zelig</code>, a Gary King project, tries to standardize model evaluation and visualization across model types</li>
<li><code>effects</code>, which is a little older but still commonly advocated</li>
</ul>
<p>I prefer using <code>broom</code> because it is meant to work in a “tidy” workflow, but you have to do the work to generate your own critical value for generating a confidence interval. I don’t find this to be an onerous task, since I believe you should be actively thinking about your critical values anyway. I don’t use this kind of stuff much, however, because I tend to do uncertainty by simulation or with a Bayesian model. Needless to say, however, there are plenty of documents and examples on the web for these packages.</p>
</div>
</div>
<div id="generalized-linear-models" class="section level1">
<h1>Generalized linear models</h1>
<p>Generalized linear models (GLMs, such as logit, poisson regression, negative binomial regression, and so on) are similar to linear models, but they are designed for nonlinear relationships. GLMs and LMs are similar, but the following key differences distinguish the two.</p>
<div id="distribution-of-the-dependent-variable" class="section level2">
<h2>Distribution of the dependent variable</h2>
<p>In a linear model, residuals are assumed to be normally distributed. Another way to write this is that <span class="math inline">\(y_{i}\)</span> itself is normally distributed around the expected value of <span class="math inline">\(y\)</span>, conditional on <span class="math inline">\(x\)</span>. Call this conditional mean <span class="math inline">\(\mu_{i}\)</span>.</p>
<p><span class="math inline">\(\begin{align} y_{i} &amp;\sim \mathrm{Normal}\left( \mu_{i}, \sigma \right) \\[6pt] \mu_{i} &amp;= \alpha + \beta x_{i} \end{align}\)</span></p>
<p>This is how you write a linear model as a normally distributed <span class="math inline">\(y\)</span>. For generalized linear models, it’s the same basic idea, except the outcome distribution is non-normal (we’ll use <span class="math inline">\(\tau\)</span> to indicate a dispersion parameter).</p>
<p><span class="math inline">\(\begin{align} y_{i} &amp;\sim \mathrm{Some \, Distribution}\left( \mu_{i}, \tau \right) \end{align}\)</span></p>
</div>
<div id="linearity" class="section level2">
<h2>Linearity</h2>
<p>The other component that sets GLMS apart is the linearity of the relationship between <span class="math inline">\(x\)</span> and <span class="math inline">\(y.\)</span></p>
<ul>
<li>In a linear model: <span class="math inline">\(x\)</span> is assumed to have a linear effect on <span class="math inline">\(\mu_{i}\)</span>. Coefficients describe how <span class="math inline">\(x\)</span> impacts <span class="math inline">\(\mu_{i}\)</span>.</li>
<li>In a GLM: <span class="math inline">\(x\)</span> has a linear impact on a <em>transformation</em> of <span class="math inline">\(\mu_{i}\)</span>, which implies that <span class="math inline">\(x\)</span> is non-linearly related to <span class="math inline">\(y\)</span>. Coefficients describe how <span class="math inline">\(x\)</span> impacts the transformed <span class="math inline">\(\mu_{i}\)</span>.</li>
</ul>
<p>So the full GLM is like the Normal model, but we use a different distribution, and <span class="math inline">\(\mu_{i}\)</span> isn’t linearly related to <span class="math inline">\(x\)</span>.</p>
<p><span class="math inline">\(\begin{align} y_{i} &amp;\sim \mathrm{Some \, Distribution}\left( \mu_{i}, \tau \right) \\[6pt] \mathcal{f}\left( \mu_{i} \right) &amp;= \alpha + \beta x_{i} \\[6pt] \mu_{i} &amp;= f^{-1}\left( \alpha + \beta x_{i} \right) \end{align}\)</span></p>
<p>The transformation of <span class="math inline">\(\mu_{i}\)</span> is called a <em>link function</em>. We call these “generalized linear models” because there <em>is</em> a linear component, but it’s a linear relationship between <span class="math inline">\(x\)</span> and <span class="math inline">\(\mathrm{link}(\mu_{i})\)</span>. And it’s <em>generalized</em> because a linear model fits into this framework as well, but the link function is simply <span class="math inline">\(1 \times \mu_{i}\)</span>.</p>
</div>
<div id="an-example-using-logit" class="section level2">
<h2>An example using logit</h2>
<p>We’ll use logistic regression to predict a vote for the Republican presidential candidate using ideological self-placement and gender as covariates.</p>
<p>Fitting this into the GLM framework…</p>
<ul>
<li>The outcome distribution is Bernoulli. The dependent variable <span class="math inline">\(y\)</span> is a 1 or a 0, “success” or “failure”.</li>
<li>We don’t model <span class="math inline">\(y\)</span> directly. Instead, we want to model <span class="math inline">\(\pi_{i}\)</span>, which is the <em>expected value</em> of <span class="math inline">\(y_{i}\)</span>.</li>
<li>The link function connecting <span class="math inline">\(\pi_{i}\)</span> to the regression equation is called the <em>logit</em> function, a.k.a. the “log odds” of <span class="math inline">\(\y_{i}\)</span>.</li>
</ul>
<p>Here’s the math. We’ll use <span class="math inline">\(y_{i}\)</span> to indicate the observed vote for voter <span class="math inline">\(i\)</span>, <span class="math inline">\(\pi_{i}\)</span> is the probability that <span class="math inline">\(i\)</span> votes for the Republican.</p>
<p><span class="math inline">\(\begin{align} y_{i} &amp;\sim \mathrm{Bernoulli}(\pi_{i}) \\[6pt] \ln \left( \frac{\pi_{i}}{1 - \pi_{i}} \right) &amp;= \alpha + \beta_{1} x_{1i} + \beta_{2} x_{2i} + \ldots \end{align}\)</span></p>
<p>As we can see, neither our data <span class="math inline">\(y_{i}\)</span> nor the expected value <span class="math inline">\(\pi_{i}\)</span> are linearly related to our predictors. Instead, the transformation of <span class="math inline">\(\pi_{i}\)</span> (the log odds) is linearly related to the predictors.</p>
</div>
<div id="lets-do-this-in-r." class="section level2">
<h2>Let’s do this in R.</h2>
<p>Here are the data from 1996 only.</p>
<pre class="r"><code># vote, ideology, and gender data from 1996

logit_data &lt;- anes %&gt;%
  filter(cycle == 1996) %&gt;%
  select(vote, libcon_self, gender) %&gt;%
  print()</code></pre>
<pre><code>## # A tibble: 1,714 x 3
##    vote                 libcon_self gender
##    &lt;chr&gt;                      &lt;dbl&gt; &lt;chr&gt; 
##  1 &lt;NA&gt;                           4 Women 
##  2 Democratic Candidate           4 Women 
##  3 &lt;NA&gt;                          NA Men   
##  4 Democratic Candidate           4 Men   
##  5 Republican Candidate           4 Women 
##  6 &lt;NA&gt;                          NA Men   
##  7 Republican Candidate           7 Men   
##  8 Democratic Candidate          NA Men   
##  9 Democratic Candidate           4 Women 
## 10 &lt;NA&gt;                           7 Men   
## # ... with 1,704 more rows</code></pre>
<p>Let’s transform this data to make it play nicely with modeling math.</p>
<pre class="r"><code># convert rvote to a dummy (treat a logical as a number, 0 or 1)
# same with gender
# center the ideology scale on 4, so the constant (x = 0) represents moderates

logit_data &lt;- logit_data %&gt;%
  mutate(rvote = as.numeric(vote == &quot;Republican Candidate&quot;),
         woman = as.numeric(gender == &quot;Women&quot;),
         ideo = libcon_self - 4) %&gt;%
  print()</code></pre>
<pre><code>## # A tibble: 1,714 x 6
##    vote                 libcon_self gender rvote woman  ideo
##    &lt;chr&gt;                      &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 &lt;NA&gt;                           4 Women     NA     1     0
##  2 Democratic Candidate           4 Women      0     1     0
##  3 &lt;NA&gt;                          NA Men       NA     0    NA
##  4 Democratic Candidate           4 Men        0     0     0
##  5 Republican Candidate           4 Women      1     1     0
##  6 &lt;NA&gt;                          NA Men       NA     0    NA
##  7 Republican Candidate           7 Men        1     0     3
##  8 Democratic Candidate          NA Men        0     0    NA
##  9 Democratic Candidate           4 Women      0     1     0
## 10 &lt;NA&gt;                           7 Men       NA     0     3
## # ... with 1,704 more rows</code></pre>
<p>You’ll see <code>NA</code>s in the data. Cases with missing values are automatically dropped during estimation. You may cover missing data imputation in your maximum likelihood course.</p>
<p>The estimation formula in R looks like <code>lm()</code>, but we specify a family of probability distributions. We use “binomial,” which is how you do logit. (Binomial is a Bernoulli for multiple observations).</p>
<pre class="r"><code># estimate the model with glm() and binomial distribution

vote_logit &lt;- glm(rvote ~ ideo + woman + ideo*woman,
                  family = binomial(link = &quot;logit&quot;),
                  data = logit_data)

summary(vote_logit)</code></pre>
<pre><code>## 
## Call:
## glm(formula = rvote ~ ideo + woman + ideo * woman, family = binomial(link = &quot;logit&quot;), 
##     data = logit_data)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -2.3949  -0.8651  -0.2842   0.6189   2.5415  
## 
## Coefficients:
##             Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept) -0.78991    0.15241  -5.183 2.18e-07 ***
## ideo         1.19970    0.12051   9.955  &lt; 2e-16 ***
## woman        0.01939    0.20222   0.096    0.924    
## ideo:woman  -0.03668    0.16285  -0.225    0.822    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 1185.24  on 857  degrees of freedom
## Residual deviance:  833.29  on 854  degrees of freedom
##   (856 observations deleted due to missingness)
## AIC: 841.29
## 
## Number of Fisher Scoring iterations: 5</code></pre>
<p>We can create coefficient plots and tables as before, so I won’t demonstrate those. I will say that when you want to compare GLMs to one another, it is usually smarter to compare predictions or model fit statistics than it is to compare coefficients themselves. Because coefficients are on unintuitive scales (the “link scale”) and sometimes involve ancillary parameters that help adjust the fit (such as cutoff parameters in ordinal logit), small changes to the model may change coefficients in ways that <em>look</em> large, but the effects on the actual predicted value may be negligible.</p>
<p>Visualizing the predictions from a GLM is similar to linear modeling, but we add one step.</p>
<ul>
<li>Create counterfactual data for simulated predictions</li>
<li>Generate linear predictions using model coefficients</li>
<li><em>Transform linear predictions with inverse link function</em></li>
<li>Plot as desired</li>
</ul>
<p>Here we only use coefficients to generate the linear predictions from the model. The predictions and bounds are on the link scale (log odds ratios).</p>
<pre class="r"><code># new data frame of values -3 through 3, 
#   which is the rescaled ideology scale

# for GLMs, the critical value is always 1.96 
#   (assumes normal coefficients on the link scale)

# here are predictions on the link scale (for logit: the log-odds scale)
# using the augment() function from the broom package

logit_preds &lt;- data_frame(ideo = rep(-3:3, 2),
                          woman = c(rep(1, 7), rep(0, 7)),
                          `ideo:woman` = ideo * woman) %&gt;%
  augment(vote_logit, newdata = .) %&gt;%
  mutate(lower = .fitted - (1.96 * .se.fit),
         upper = .fitted + (1.96 * .se.fit)) %&gt;% 
  print()</code></pre>
<pre><code>##    ideo woman ideo.woman    .fitted   .se.fit      lower      upper
## 1    -3     1         -3 -4.2595782 0.4024584 -5.0483967 -3.4707596
## 2    -2     1         -2 -3.0965603 0.2997848 -3.6841384 -2.5089821
## 3    -1     1         -1 -1.9335424 0.2043722 -2.3341119 -1.5329728
## 4     0     1          0 -0.7705245 0.1329063 -1.0310208 -0.5100281
## 5     1     1          1  0.3924935 0.1325109  0.1327721  0.6522149
## 6     2     1          2  1.5555114 0.2036006  1.1564543  1.9545685
## 7     3     1          3  2.7185293 0.2989084  2.1326689  3.3043897
## 8    -3     0          0 -4.3890098 0.4698294 -5.3098755 -3.4681441
## 9    -2     0          0 -3.1893107 0.3547655 -3.8846511 -2.4939703
## 10   -1     0          0 -1.9896116 0.2449925 -2.4697968 -1.5094264
## 11    0     0          0 -0.7899125 0.1524070 -1.0886302 -0.4911947
## 12    1     0          0  0.4097866 0.1244120  0.1659392  0.6536340
## 13    2     0          0  1.6094857 0.1917619  1.2336324  1.9853390
## 14    3     0          0  2.8091848 0.2951453  2.2307000  3.3876696</code></pre>
<p>If we don’t transform the linear predictions, then we get predictions on the link scale (the log odds scale in a logit model). That’s how we can have negative predicted values, for example. We could plot them, and they’d look like straight lines (just like OLS), but log odd ratios are hard to interpret. Instead, we will transform the log odds to <em>predicted probabilities</em> using the <code>plogis()</code> function, which is the inverse of the logit link function (a.k.a. the “logistic function,” which happens to be the cumulative distribution function of the logistic distribution).</p>
<pre class="r"><code># transform log odds to probabilities

logit_preds &lt;- logit_preds %&gt;%
  select(-.se.fit) %&gt;%
  # mutate only the selected variables
  mutate_at(vars(.fitted, upper, lower), plogis) %&gt;%
  print()</code></pre>
<pre><code>##    ideo woman ideo.woman    .fitted       lower      upper
## 1    -3     1         -3 0.01393143 0.006378669 0.03015576
## 2    -2     1         -2 0.04324936 0.024503313 0.07523089
## 3    -1     1         -1 0.12635901 0.088336955 0.17755914
## 4     0     1          0 0.31636567 0.262886251 0.37518693
## 5     1     1          1 0.59688280 0.533144341 0.65750940
## 6     2     1          2 0.82570832 0.760687844 0.87594393
## 7     3     1          3 0.93811120 0.894038109 0.96457910
## 8    -3     0          0 0.01226082 0.004918234 0.03023234
## 9    -2     0          0 0.03956997 0.020141001 0.07628197
## 10   -1     0          0 0.12029796 0.078002845 0.18102382
## 11    0     0          0 0.31218746 0.251876301 0.37961216
## 12    1     0          0 0.60103671 0.541389862 0.65782892
## 13    2     0          0 0.83333997 0.774453699 0.87924916
## 14    3     0          0 0.94317014 0.902972705 0.96731695</code></pre>
<pre class="r"><code># modify data and plot

 
ggplot(logit_preds, aes(x = ideo, y = .fitted)) +
  geom_pointrange(aes(ymin = lower, ymax = upper, 
                    color = as.factor(woman)),
                position = position_dodge(width = 0.5),
                show.legend = FALSE) +
  annotate(&quot;text&quot;, x = 0.5, y = .59, label = &quot;Men&quot;) +
  annotate(&quot;text&quot;, x = 1.7, y = .59, label = &quot;Women&quot;) +
  scale_x_continuous(breaks = -3:3,
                  labels = c(&quot;Very\nLiberal&quot;, 
                             &quot;Liberal&quot;, 
                             &quot;Slightly\nLiberal&quot;, 
                             &quot;Moderate&quot;, 
                             &quot;Slightly\nConservative&quot;, 
                             &quot;Conservative&quot;, 
                             &quot;Very\nConservative&quot;)) +
  labs(color = NULL,
     x = &quot;Ideological Self-Placement&quot;,
     y = &quot;Probability of Republican Vote&quot;) +
  theme(panel.grid.minor = element_blank())</code></pre>
<p><img src="/811/811-05-analysis_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
<p>Note how the predictions are non-linear. The predictions approach 0% and 100% but never exceed them. GLMs are useful because they accurately capture these sorts of ceiling and floor effects.</p>
<p>There are <em>loads</em> of GLMs out there, because there are loads of ways your data aren’t perfectly normal and linearly related. But they all fit the same basic framework: <span class="math inline">\(y\)</span> follows some distribution, and you need some link function to describe how <span class="math inline">\(y\)</span> is related to <span class="math inline">\(x\)</span>.</p>
</div>
</div>
<div id="model-diagnostics" class="section level1">
<h1>Model diagnostics</h1>
<p>The model objects created by <code>lm()</code> and <code>glm()</code> do include some model diagnosis tools, such as F-statistics, <span class="math inline">\(R^{2}\)</span> values, deviance, AIC, so on. We’ll walk through some here.</p>
<p>Some diagnostics for linear models can be easily visualized using <code>plot()</code>, including quantile plots, and analyses of residuals.</p>
<pre class="r"><code>plot(therm_mod)</code></pre>
<p><img src="/811/811-05-analysis_files/figure-html/unnamed-chunk-38-1.png" width="672" /><img src="/811/811-05-analysis_files/figure-html/unnamed-chunk-38-2.png" width="672" /><img src="/811/811-05-analysis_files/figure-html/unnamed-chunk-38-3.png" width="672" /><img src="/811/811-05-analysis_files/figure-html/unnamed-chunk-38-4.png" width="672" /></p>
<p>There are certain functions and packages that can be used to generate model fit statistics. I think the easiest tool for comparing models is <code>broom::glance()</code>. Just like <code>broom::tidy()</code>, you can stack the data frames created by <code>glance()</code> to compare models easily or plot the statistics.</p>
<pre class="r"><code>bind_rows(mutate(glance(therm_mod), mod = &quot;LibCon&quot;), 
          mutate(glance(dummy_mod), mod = &quot;Dummies&quot;),
          mutate(glance(int_mod), mod = &quot;Intercepts&quot;))</code></pre>
<pre><code>##   r.squared adj.r.squared    sigma statistic      p.value df    logLik
## 1 0.2415795     0.2403112 32.23982 190.48075 8.179967e-38  2 -2934.283
## 2 0.2503635     0.2427786 32.18742  33.00834 2.220915e-34  7 -2930.788
## 3 0.2507613     0.2419170 32.18742  28.35287 9.973339e-34  7 -2930.788
##        AIC      BIC deviance df.residual        mod
## 1 5874.566 5887.757 621564.9         598     LibCon
## 2 5877.576 5912.752 614366.0         593    Dummies
## 3 5877.576 5912.752 614366.0         593 Intercepts</code></pre>
<p>This works for GLMs as well, but maximum likelihood models have some different fit statistics than least-squares models. If you want to compare linear and nonlinear models, you could estimate the linear model as a GLM model of Gaussian family with an “identity” link.</p>
<pre class="r"><code>glance(vote_logit)</code></pre>
<pre><code>##   null.deviance df.null    logLik      AIC      BIC deviance df.residual
## 1      1185.241     857 -416.6439 841.2877 860.3061 833.2877         854</code></pre>
<p>Some additional tips and tools.</p>
<ul>
<li>Some of these diagnostics will show an improvement in model fit even if the improvement comes from fitting noise (such as <span class="math inline">\(R^{2}\)</span>). These diagnostics are statistics that take a distribution, so you want to compare models using a statistical comparison—i.e. is the fit improvement <em>enough</em> given that you’ve added an extra variable to the model. Examples include F-tests and likelihood-ratio tests. If you go down this route, you might check out tools such as <code>epicalc::lrtest()</code> or the <code>lmtest</code> package. Other packages for model assistance (such as <code>arm</code> or <code>rms</code>) may have similar tools as well. Other diagnostic measures will penalize you for adding variables on the front-end, such as BIC, so they don’t require formal statistical tests.</li>
<li>My advice is that if you want to be doing this kind of intense model comparison, make sure you know what these statistics are checking and that the use is appropriate for your task at hand. There really are no hard and fast rules here, so you want to do what makes sense for your use case.</li>
<li>Out-of-sample prediction is a good test for model over-fitting. This can be evaluated using cross-validation. The <code>loo</code> package provides tools for easier CV performance. (Also, the AIC is intended to estimate out-of-sample model accuracy).</li>
<li>Simulating artificial data can be a useful face-validity check. If you are estimating a generative model of your data (and you are…), the model should generate data that look like your data.</li>
</ul>
</div>
<div id="intermediate-r-tricks" class="section level1">
<h1>Intermediate R tricks</h1>
<p>Now we will quickly introduce some more nitty-gritty R tricks. These may not be essential for the problem set, but over the long run, you will be a much more efficient R user if you take these concepts seriously.</p>
<div id="type-coercion" class="section level2">
<h2>Type coercion</h2>
<p>As we covered early in the course, there are a few different data types in R: logical, numeric, factor, and character. Data can be <em>coerced</em> from one type to another with <code>as.type()</code> functions, where <code>type</code> refers to the resulting data type.</p>
<p>Let’s start as broad as possible with characters. As the broadest of these data types, anything can be coerced to a character.</p>
<pre class="r"><code># logical to character
as.character(TRUE)</code></pre>
<pre><code>## [1] &quot;TRUE&quot;</code></pre>
<pre class="r"><code># numeric to character
as.character(c(1, 2, 3))</code></pre>
<pre><code>## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot;</code></pre>
<pre class="r"><code># factor to character
F &lt;- factor(c(&quot;hello&quot;, &quot;world&quot;))
as.character(F)</code></pre>
<pre><code>## [1] &quot;hello&quot; &quot;world&quot;</code></pre>
<p>Converting to factor is similar. Each unique value is given its own factor level, and the order of levels is assigned alphabetically unless specified with <code>factor(..., levels = c(...))</code>.</p>
<pre class="r"><code>as.factor(c(TRUE, FALSE))</code></pre>
<pre><code>## [1] TRUE  FALSE
## Levels: FALSE TRUE</code></pre>
<pre class="r"><code>as.factor(c(1, 2, 3))</code></pre>
<pre><code>## [1] 1 2 3
## Levels: 1 2 3</code></pre>
<pre class="r"><code># note the level order
factor(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;), levels = c(&quot;3&quot;, &quot;2&quot;, &quot;1&quot;))</code></pre>
<pre><code>## [1] 1 2 3
## Levels: 3 2 1</code></pre>
<p>Converting to numeric is slightly more confusing. Logical variables are easy and can be converted to <code>1</code>a and <code>0</code>s.</p>
<pre class="r"><code>as.numeric(c(TRUE, FALSE))</code></pre>
<pre><code>## [1] 1 0</code></pre>
<p>Factors also work, but the coercion gives numeric meaning to the underlying factor labels.</p>
<pre class="r"><code># levels assigned in reverse order
(F &lt;- factor(c(&quot;hello&quot;, &quot;world&quot;), levels = c(&quot;world&quot;, &quot;hello&quot;)))</code></pre>
<pre><code>## [1] hello world
## Levels: world hello</code></pre>
<pre class="r"><code># note the mapping to numeric...
# Making a data frame to visualize
data_frame(factor = F, 
           numeric = as.numeric(F))</code></pre>
<pre><code>## # A tibble: 2 x 2
##   factor numeric
##   &lt;fct&gt;    &lt;dbl&gt;
## 1 hello        2
## 2 world        1</code></pre>
<p>Character vectors cannot be directly mapped to numeric. They need to be converted to factor first.</p>
<pre class="r"><code>char &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;z&quot;)
# direct coercion leads to NAs
as.numeric(char)</code></pre>
<pre><code>## Warning: NAs introduced by coercion</code></pre>
<pre><code>## [1] NA NA NA</code></pre>
<pre class="r"><code># coercion through factor works
as.numeric(as.factor(char))</code></pre>
<pre><code>## [1] 1 2 3</code></pre>
<p>Here’s where you typically see these forms of coercion.</p>
<ul>
<li>using logicals to convert categorical variables into dummy variables</li>
<li>using <code>as.factor()</code> to convert a numeric index into a set of dummy variables in a regression function</li>
<li>converting numeric caseID variables to character in order to fix any problems with leading zeroes. This is common with geocodes like FIPS codes.</li>
<li>Converting character vectors to factors for plotting (placing categories in order for legends or panel titles).</li>
</ul>
</div>
<div id="user-defined-functions" class="section level2">
<h2>User-defined functions</h2>
<p>In R, we can write our own functions to perform repetitive tasks. Let’s demonstrate the a task for finding a mean.</p>
<pre class="r"><code>my_mean &lt;- function(x) {
  
  the_sum &lt;- sum(x) 
  n &lt;- length(x)
  the_mean &lt;- the_sum / n 
  
  return(the_mean)

}

z &lt;- 1:5
my_mean(z)</code></pre>
<pre><code>## [1] 3</code></pre>
<p>User-defined functions have three components.</p>
<ul>
<li>The function name, which is what we assign the function to.</li>
<li>Arguments, passed to the function, manipulated within the function</li>
<li>The definition, which details how arguments are manipulated and what the function returns</li>
</ul>
<p>It is important to note that the variables inside the function definition are called <em>local variables</em>. This means they only exist in the world of that function. They are not accessible elsewhere in R. In the above example, <code>x</code>, <code>the_sum</code>, <code>n</code>, and <code>the_mean</code> are manipulated by the function but are not available to you to play with. Furthermore, if there are other objects currently in R memory that share those same names, they have no bearing on how the function works. Local variables help define a function and perform its intended purpose, but they do not affect and are not affected by the other objects in your current R workspace.</p>
</div>
<div id="lists" class="section level2">
<h2>Lists</h2>
<p>There is one data structure that we have not yet discussed: lists. Lists are like vectors, but unlike vectors, their elements can be of any data type. Let’s demonstrate.</p>
<pre class="r"><code># create a list of named elements
el &lt;- list(num = 1, 
           fact = factor(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)),
           char = c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;))
# check it out
el</code></pre>
<pre><code>## $num
## [1] 1
## 
## $fact
## [1] a b c
## Levels: a b c
## 
## $char
## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot;</code></pre>
<pre class="r"><code># numeric indexing gives you the named element (including the name)
el[1]</code></pre>
<pre><code>## $num
## [1] 1</code></pre>
<pre class="r"><code># to get all the way down to the data...
el$num</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>el[[2]]</code></pre>
<pre><code>## [1] a b c
## Levels: a b c</code></pre>
<pre class="r"><code>el[[&quot;char&quot;]]</code></pre>
<pre><code>## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot;</code></pre>
<p>This can be handy for stacks of data frames. For example, the <code>anes</code> dataset, but element is a data frame corresponding to each survey year.</p>
<pre class="r"><code># This will print a big monstrosity, 
# but you should see what it looks like
anes_list &lt;- split(anes, anes$cycle)</code></pre>
</div>
<div id="functional-programming-with-apply-functions." class="section level2">
<h2>Functional programming with <code>apply()</code> functions.</h2>
<p>You’ll see stuff about <code>apply()</code> functions online. They are scary at first, but they make sense if you give them a chance.</p>
<p>Let’s see what we mean. Let’s create a two-D object.</p>
<pre class="r"><code>df &lt;- data_frame(a = 1:5, b = a, c = a) %&gt;%
  print()</code></pre>
<pre><code>## # A tibble: 5 x 3
##       a     b     c
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     1     1     1
## 2     2     2     2
## 3     3     3     3
## 4     4     4     4
## 5     5     5     5</code></pre>
<p>An <code>apply()</code> function takes an object, and applies a function across its dimension(s). This is easier to explain using an example: here, we will apply the <code>mean</code> function to the rows and columns of this <code>df</code> object.</p>
<pre class="r"><code># 1 = row
# get the mean of every row
apply(df, 1, mean)</code></pre>
<pre><code>## [1] 1 2 3 4 5</code></pre>
<p>It returns an object the same length as the number of rows in the object, containing the result of the <code>mean()</code> function for each row.</p>
<p>Here it is for each column.</p>
<pre class="r"><code># 2 = columns
# get the mean of every column
apply(df, 2, mean)</code></pre>
<pre><code>## a b c 
## 3 3 3</code></pre>
<p>You could pass a user-defined function to <code>apply()</code>, or you could define a function within <code>apply()</code> using “anonymous functions.” Example:</p>
<pre class="r"><code>df </code></pre>
<pre><code>## # A tibble: 5 x 3
##       a     b     c
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     1     1     1
## 2     2     2     2
## 3     3     3     3
## 4     4     4     4
## 5     5     5     5</code></pre>
<pre class="r"><code># apply x * x to every column
apply(df, 2, function(x) {x * x})</code></pre>
<pre><code>##       a  b  c
## [1,]  1  1  1
## [2,]  4  4  4
## [3,]  9  9  9
## [4,] 16 16 16
## [5,] 25 25 25</code></pre>
<p>This anonymous function applies the function <code>x^2</code> to each column in <code>df</code>.</p>
<p>There are a few types of apply functions, but you’re only likely to use a few of them.</p>
<ul>
<li><code>apply</code>: apply a function over the margins of an object</li>
<li><code>sapply</code>: simplify the <code>apply()</code> results to a one-D vector, if possible</li>
<li><code>lapply</code>: apply for each element in a list</li>
</ul>
<p>Here is an <code>lapply</code> example, using the <code>anes_list</code> object we created above. We’ll use an anonymous function to find the mean <code>party_distance</code> in each election cycle.</p>
<pre class="r"><code># &#39;x&#39; refers to each element of the list
# each element being a data frame
# so x$var finds &#39;var&#39; in the x data frame

lapply(anes_list, function(x) mean(x$party_distance, na.rm = TRUE))</code></pre>
<p>From there, you can do cool things like “melt” the list into a data frame using <code>reshape2::melt()</code>.</p>
<pre class="r"><code>lapply(anes_list, function(x) mean(x$party_distance, na.rm = TRUE)) %&gt;%
  reshape2::melt()</code></pre>
</div>
<div id="nesting-superpowered-lists" class="section level2">
<h2>Nesting: superpowered lists</h2>
<p>When you get <em>really</em> comfortable with function programming, you can do crazy stuff like nest a data frame. What is that?</p>
<pre class="r"><code>anes %&gt;%
  group_by(cycle) %&gt;%
  nest() </code></pre>
<pre><code>## # A tibble: 30 x 2
##    cycle data                  
##    &lt;dbl&gt; &lt;list&gt;                
##  1  1948 &lt;tibble [662 × 961]&gt;  
##  2  1952 &lt;tibble [1,899 × 961]&gt;
##  3  1954 &lt;tibble [1,139 × 961]&gt;
##  4  1956 &lt;tibble [1,762 × 961]&gt;
##  5  1958 &lt;tibble [1,450 × 961]&gt;
##  6  1960 &lt;tibble [1,181 × 961]&gt;
##  7  1962 &lt;tibble [1,297 × 961]&gt;
##  8  1964 &lt;tibble [1,571 × 961]&gt;
##  9  1966 &lt;tibble [1,291 × 961]&gt;
## 10  1968 &lt;tibble [1,557 × 961]&gt;
## # ... with 20 more rows</code></pre>
<p>A nested data frame is a data frame where columns can themselves be a list of data frames (a.k.a. a “list column”). In this data frame, the <code>data</code> column isn’t really a variable; it contains a list of data frames, each corresponding to the grouping variable (<code>cycle</code>).</p>
<p>Unnest a list column from a data frame like so:</p>
<pre class="r"><code>anes %&gt;%
  group_by(cycle) %&gt;%
  nest() %&gt;%
  # unnest the `data` column
  unnest(data)</code></pre>
<p>Why is this useful? Well…</p>
</div>
<div id="mapping-a-function-over-a-list-column" class="section level2">
<h2>Mapping a function over a list column</h2>
<p>This is another functional programming trick, like apply, but applied to a list column in a nested data frame.</p>
<p>Let’s say we had the above nested frame (a data frame for each survey wave), but we wanted to estimate a regression for separate data frames.</p>
<p>Here, we estimate the effect of gender on Republican voting using <code>purrr::map()</code>, which is like <code>apply()</code> but it works across a list column in nested data frame.</p>
<pre class="r"><code># nesting the data
#   get indicator for R vote
#   removing NAs
#   group by cycle and nest
# Apply function over the list column
#   use every data frame in the list column
#   run glm() using an intercepts model for comparisons (no constant)
#   tidy the model output
# Unnest the data
#   unnest the results of map()
#   create a gender label

gender_gaps &lt;- anes %&gt;%
  mutate(rvote = as.numeric(vote == &quot;Republican Candidate&quot;)) %&gt;% 
  filter(!is.na(rvote) &amp; !is.na(gender)) %&gt;%
  group_by(cycle) %&gt;%
  nest() %&gt;% 
  mutate(model = map(data, 
                     ~ glm(rvote ~ -1 + as.factor(gender), 
                           data = ., family = &quot;binomial&quot;) %&gt;%
                       tidy(conf.int = TRUE))) %&gt;%
  unnest(model) %&gt;%
  mutate(term = case_when(str_detect(term, &quot;Men&quot;) ~ &quot;Man&quot;,
                          TRUE ~ &quot;Woman&quot;)) %&gt;% 
  print()</code></pre>
<pre><code>## # A tibble: 34 x 8
##    cycle term  estimate std.error statistic  p.value conf.low conf.high
##    &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;
##  1  1948 Man     -0.228    0.145     -1.58  1.15e- 1  -0.513     0.0544
##  2  1948 Woman   -0.113    0.143     -0.787 4.31e- 1  -0.395     0.168 
##  3  1952 Man      0.286    0.0840     3.40  6.76e- 4   0.121     0.451 
##  4  1952 Woman    0.372    0.0829     4.49  6.98e- 6   0.211     0.536 
##  5  1956 Man      0.259    0.0815     3.18  1.46e- 3   0.1000    0.419 
##  6  1956 Woman    0.517    0.0809     6.39  1.71e-10   0.359     0.676 
##  7  1960 Man     -0.107    0.0967    -1.11  2.67e- 1  -0.297     0.0820
##  8  1960 Woman    0.124    0.0925     1.34  1.81e- 1  -0.0573    0.306 
##  9  1964 Man     -0.640    0.0934    -6.85  7.14e-12  -0.825    -0.459 
## 10  1964 Woman   -0.810    0.0881    -9.19  4.04e-20  -0.985    -0.639 
## # ... with 24 more rows</code></pre>
<pre class="r"><code># # plot coefficients over time
# # map pt shape, solid and empty points, generic white fill
ggplot(gender_gaps, aes(x = cycle, y = estimate, color = term)) +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high,
                      shape = term),
                  fill = &quot;white&quot;,
                  position = position_dodge(width = 0.5)) +
  scale_shape_manual(values = c(16, 21)) +
  scale_x_continuous(breaks = seq(1948, 2012, 8)) +
  labs(y = &quot;Effect on Republican Voting (Log Odds Scale)&quot;,
       x = &quot;Election Cycle&quot;,
       color = NULL, shape = NULL)</code></pre>
<p><img src="/811/811-05-analysis_files/figure-html/unnamed-chunk-57-1.png" width="672" /></p>
<p>Mapping is a tool that takes some getting used to at first. In particular, you have to get a feel for the formula syntax where a function follows a <code>~</code> symbol, and you use <code>.</code> to represent element names in the <code>data</code> column. Once you get this down, however, mapping is an extremely powerful tool for scaling up analysis because not only can you do a lot of repetitive work with very little code, the code is executed using parallel processing when possible. This makes it much faster because it distributes tasks across processing cores on your computer (nice!).</p>
</div>
</div>
<div id="references-for-advanced-topics" class="section level1">
<h1>References for advanced topics</h1>
<p>As you develop your substantive scholarly interests, it is likely that you will develop a methodological expertise to fit your topic of study. Luckily, many others have come before you and have developed R tools for doing these analyses. Better yet, these computational tools are being increasingly folded into a <code>tidyverse</code>-style tools. We’ll quickly point out a few of these resources. You will <em>NOT</em> be required to use these tools for any take-home exercises.</p>
<p>Some higher-level advice for navigating these packages:</p>
<ul>
<li>My philosophy is that I like to rely on external packages for computation and estimation, but not for graphics. If there is a tool that estimates a model for me, or performs a particular statistical test, then that’s great. But I tend not to like the graphics that these tools produce. <em>As a result</em>, I look for tools that make it easy for me to extract the data that I want to plot.</li>
<li>Sometimes it is tedious to extract the data from these objects. In these situations, I tend to write my own functions to process the output from these packages into a tidy format for plotting or tabulating.</li>
<li>If you want a quick and easy way to learn about packages, make a Twitter for your “academic self” and follow some researchers and R developers.</li>
</ul>
<div id="survey-analysis" class="section level2">
<h2>Survey analysis</h2>
<p>The statistics that we learn apply to data collected from simple random samples. In the real world, however, survey data often require some kind of clustered sample design and contain accompanying sample weights. Analyzing surveys requires (or, should require) accounting for weights and design as separate elements of the analysis.</p>
<p>If you have a non-clustered sample design but some degree of oversampling, you might handle weights analytically—calculating weighted means and weighted sample sizes. If you have a more advanced sample design, you should incorporate elements of the design into the estimation. To that end, I’d recommend Thomas Lumley’s <a href="https://cran.r-project.org/web/packages/survey/"><code>survey</code></a> package. You use your dataset to create a new object that contains metadata about the cluster structure of the sample. Functions in the <code>survey</code> package then use the metadata about the sample design to estimate things properly. This is similar to the way you can declare survey design information using <code>svy</code>-based commands in Stata.</p>
</div>
<div id="time-series" class="section level2">
<h2>Time series</h2>
<p>For time series, you will want some special tools to deal with the accompanying statistical pitfalls: functional forms for autocorrelated errors, standard errors for autocorrelation, and the estimation of ancillary parameters for models designed for certain temporal interventions.</p>
<p>First, for data manipulation, you will want some kind of data structure that contains metadata about which variable defines the time period. This structure will allow you to properly calculate differenced variables, lags, and leads. To create tidy, time-aware tibble datasets, you could use <a href="https://github.com/business-science/tibbletime"><code>tibbletime</code></a> or the more recent (and supposedly more capable) <a href="http://pkg.earo.me/tsibble/index.html"><code>tsibble</code></a>. You could also check out the <code>lubridate</code>, <code>zoo</code>, and <code>hms</code> (Tidyverse!) packages for manipulating data-time variables, since the baked in R tools for dealing with <code>POSIXct</code> and <code>POSIXlt</code> data are very difficult to figure out. If you read that sentence and were like “wtf are <code>POSIXct</code> and <code>POSIXlt</code>?”, that’s exactly what I mean.</p>
<p>For time series <em>modeling</em>, you will want tools that perform a variety of functions.</p>
<ul>
<li>ARIMA modeling</li>
<li>Unit root and (fractional) integration testing</li>
<li>modeling for interventions, autoregressive distributed lag (ADL), error-correction (ECOM) vector autoregression (VAR), granger causality tests, impulse-response functions, and so on</li>
</ul>
<p>I don’t have expert-level advice here, but when I took our time series ITV course, I found the following packages useful for several of these needs: <code>TSA</code>, <code>fUnitRoots</code>, <code>egcm</code>, <code>fracdiff</code>, <code>forecast</code>.</p>
</div>
<div id="panel-data" class="section level2">
<h2>Panel data</h2>
<p>Panel data tends to be the realm of “fixed-effects” modeling, meaning that when you measure features over time, time-invariant predictors are absorbed into fixed unit-level averages, and time-varying features have coefficients that are constant across time. I don’t typically do this kind of analysis, but those who do often use the <code>plm</code> package for these types of models.</p>
<p>Alternatives to <code>plm</code> include hierarchical modeling approaches, which we’ll cover in a separate subsection.</p>
</div>
<div id="hierarchicalmultilevel-models" class="section level2">
<h2>Hierarchical/multilevel models</h2>
<p>For complex hierarchical data structures (individuals within time periods, individuals within geographic groups, observations within countries within regions within time periods…), hierarchical models may more be a more direct modeling approach to attributing variation in the data to covariates at different levels of analysis without as much scrutiny about clustered variance estimators and so on. This is because hierarchical modeling allows you to directly model parameter estimates as functions of covariates at other levels of the data. For example, the probability that an individual votes Republican may be a function of their demographic characteristics but also the context of state the state in which they live.</p>
<p><span class="math inline">\(\begin{align} y_{i} &amp;\sim \mathrm{Bernoulli}\left( \pi_{i} \right) \\[6pt] \mathrm{logit} \left( \pi_{i} \right) &amp;= \alpha + \gamma^{\mathtt{demographics}}_{j[i]} + \delta^{\mathtt{state}}_{s[i]} \end{align}\)</span></p>
<p>The state effect applies to every individual in that state and could itself be a regression on state-level features such as the presidential vote in the state, state-level economics, and so on.</p>
<p><span class="math inline">\(\begin{align} \delta^{\mathtt{state}}_{s} &amp;\sim \mathrm{Normal}\left( \beta_{1} \mathrm{pvote}_{s} + \beta_{2} \mathrm{GDP}_{s} + \ldots , \, \sigma^{\mathtt{state}} \right)\end{align}\)</span></p>
<p>This kind of modeling is useful because it allows estimates for small groups to “borrow strength” from larger groups. If we don’t have a lot of data for Alabama, for example, we can say that Alabama is probably like other states that have similar state-level characteristics, and it shrinks Alabama’s estimate toward the state regression trend. In other words, for small-<span class="math inline">\(n\)</span> groups, we assume that the group-level effect looks like the other group-level effects <em>unless</em> the data give us a strong signal to the contrary. This is a key example of the bias-variance trade-off you heard about in stats courses.</p>
<p>Although hierarchical models are “essentially Bayesian” because of the partial pooling setup, there are packages for fitting approximate maximum-likelihood versions. The most common would be <code>lme4</code>, which provides <a href="https://stats.stackexchange.com/questions/18428/formula-symbols-for-mixed-model-using-lme4">syntax</a> similar to <code>nlme</code> for varying (“random”) effects, but it is more updated than <code>nlme</code>. What I’m saying is, don’t use <code>nlme</code>. The <code>arm</code> package provides additional tools for interacting with <code>lme4</code> hierarchical models, including the <code>bayesglm</code> function that just says “screw-it” and fits the fully Bayesian version of the model. On that subject…</p>
</div>
<div id="bayesian-analysis" class="section level2">
<h2>Bayesian analysis</h2>
<p>Bayesian analysis varies from “frequentist” statistics in a few fundamental ways. The main source of difference is philosophical, where uncertainty estimates are understood as your uncertainty about the actual value of the parameter, and not uncertainty about the <em>data</em>. Stated differently, frequentism measures the <em>probability of the data</em> given an assumed model of null parameter values and infinitely repeated sampling. Bayesian statistics rejects the idea of the null model entirely and instead measures the <em>probability parameter values</em> after having observed the data, which requires prior information over the parameter values. When it comes to the actual parameter estimates, you can think about maximum likelihood models as being <em>special cases of Bayesian models</em> where the researcher inserts no prior information about the parameter values.</p>
<p>There are a few ways to fit Bayesian models. For reduced-form regression models (like <code>lm</code> and <code>glm</code> functional forms), you can use packages such as <code>arm</code>, <code>brms</code>, and <code>rethinking</code> to write Bayesian models using a <a href="https://stats.stackexchange.com/questions/18428/formula-symbols-for-mixed-model-using-lme4">syntax</a> similar to <code>glm</code> and <code>lme4</code> models.</p>
<p>For complicated structural models that are not easily expressed in a single regression equation (e.g. when you have a complex multi-level structure), you can may want to set up a fully Bayesian model using external Bayesian modeling software that can be accessed by R. For simpler models, one could use <code>JAGS</code>, which samples a posterior distribution using a Gibbs sampling algorithm. You would use the <code>rjags</code> package to talk to JAGS using R. For more complex hierarhical models, randomly-walking algorithms for Gibbs sampling (like <code>JAGS</code>) do a poor job, so I recommend using <code>Stan</code> (and talking to it with R using the <code>rstan</code> package). Stan fits the model using a version of Hamiltonian Monte Carlo, both of which drastically increase the speed and quality of posterior sampling. The <code>Stan</code> syntax is more complicated than <code>JAGS</code>, but the payoff of using <code>Stan</code> is worth it.</p>
<p>For diagnosing and visualizing Bayesian model results, <code>rstan</code> has some tools baked in. The <code>ggmcmc</code> package turns posterior samples into a tidy data frame (good for ggplot!), and <code>bayesplot</code> provides other tools for easy Bayes graphics.</p>
</div>
<div id="r-as-front-end" class="section level2">
<h2>R as front-end</h2>
<p>As the Bayes packages indicate, R can serve as a front-end interface to other programs and syntaxes. Some further examples include the following packages…</p>
<ul>
<li><code>rsql</code> and <code>RSQLite</code> for SQL and SQLite</li>
<li><code>Rcpp</code> for C++</li>
<li><code>rPython</code> for Python</li>
</ul>
<p>…and so on</p>
</div>
<div id="more-materials-from-past-years" class="section level2">
<h2>More materials from past years</h2>
<p>Sarah Bouchat (former instructor for this course) has online materials for some additional topics, including text analysis, Regular Expressions (RegEx), base graphics, loops, and so on. (I purposefully don’t teach loops because <code>apply()</code> functions are better!)</p>
<p>View Sarah’s site <a href="https://bouchat.github.io/553">here</a>.</p>
</div>
</div>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Michael DeCrescenzo </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=/811/811-analysis/>/811/811-analysis/</span>
            </p>
            
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="/tags/ps811/">
                    #ps811</a></span>
            
            <span class="tag"><a href="/tags/r/">
                    #R</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="/811/811-graphics/" class="prev" rel="prev" title="Lecture 2: Graphics"><i class="iconfont icon-left"></i>&nbsp;Lecture 2: Graphics</a>
         
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2016–2018</span>
        
         
            <span class="author" itemprop="copyrightHolder"><a href="/">Michael DeCrescenzo</a> | </span> 
         

         
    <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
