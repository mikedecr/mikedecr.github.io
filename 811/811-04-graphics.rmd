---
title: "Lecture 2: Graphics"
author: "Michael DeCrescenzo"
description: "Graphics in R using ggplot2"
date: '2018-01-04'
slug: 811-graphics
categories: ["R", "ps811", "Teaching"]
tags: []
---


# Objective 

The goal of this lesson is to provide an introduction to graphics in R, by way of `ggplot2` in particular. We will cover:

- The "grammar of graphics"---the "gg" in `ggplot`
- How `ggplot2` works
- Common geoms for social science data
- Customizing the appearance of ggplot graphic
- Saving graphics
- Some (not too much) discussion of the ways base graphics and `ggplot2` are different

Some notes to get us started:

- Some introductions to ggplot begin with an overview of the `qplot()`  (quick plot) function from the `ggplot2` package. We will not start there; `qplot` is a midway point between base and ggplot graphics, but we have covered neither yet, so we have no need to "transition" out of base graphics. Moreover, I think the differences between `qplot` and the workhorse `ggplot` function confuse new users and distract from a deeper exploration of `ggplot`. So we'll jump right in. 
- Plots created using `ggplot` generally look good by default. As we get started, however, they may look a little awkward. This is because we're making plots that demonstrate ggplot functionality (which we don't want to rush though), not create the prettiest plot imaginable. As we introduce more and more ggplot concepts, plots will begin to look more publication-ready.
- If you want more help with `ggplot`, I'd recommend that you consult resources I list in the syllabus, in other lessons, and Hadley Wickham's `ggplot2` book (which you can build into a PDF on your own computer [after installing some other tools]).




# Get started

The `ggplot2` package is loaded whenever you load the `tidyverse` package (but I sometimes load the `ggplot2` package anyway because it gives my code editor has better auto-complete behavior).

```{r}
library("magrittr")
library("tidyverse")
library("ggplot2")
```

We'll also install `labelled`, which we'll use to remove Stata's labels from the data. 

```{r}
# If labelled isn't installed, install it
if (!require("labelled"))
  install.packages("labelled")
```

Set your directory where it was last lesson and load the modified ANES dataset from the previous lesson:

```{r, eval = FALSE}
setwd("~/path/to/wherever")
anes <- readRDS("data/anes-modified.RDS") %>% 
        mutate_all(labelled::remove_labels) 
        # remove Stata labels from the data
        # pkg::function lets us use functions without loading the full package
```

```{r, include = FALSE, cache = TRUE}
anes <- readRDS(here::here("static/data/anes-modified.RDS")) %>%
        mutate_all(labelled::remove_labels)
```

Notice the use of `mutate_all()`. It= applies a function to every column in the data (in this case, the `remove_labels()` function). If you're familiar with R's `apply()` functions or functional programming in general, this is a similar idea. We'll cover those things more at the end of the next lesson.

You can verify that you imported the correct dataset when you notice the modified variable names.

```{r, eval = FALSE}
names(anes)
```





# The grammar of graphics

The [grammar of graphics](https://www.springer.com/us/book/9780387245447) is a set of independent components that compose graphics. `ggplot2` is an R package that implements the grammar [in a layered fashion](http://byrneslab.net/classes/biol607/readings/wickham_layered-grammar.pdf) by iteratively adding grammatical components to a figure. By providing a set of interchangeable tools with a shared syntax and carefully chosen defaults, `ggplot2` allows R users to create complex graphics with relatively little hassle. 

It is not essential for you to memorize the components of the grammar of graphics. In fact, thinking too hard about it is confusing at first. You will get an intuition for them as you use ggplot without being able to recite the tenets, but for the sake of exposition, here are the principles of the grammer. There is *no need* to memorize this list:

- **data** to be visualized
- **aesthetic mappings** that describe how variables are mapped to aesthetic attributes (such as axes and colors)
- **geometric representations of the data**, "geoms" for short, such as lines, points, etc., that control how the cells in your data are presented on the page
- **scales**  which modify how aesthetic mappings are presented. You can use scales to modify how variables are presented along axes, as colors, and so on.
- a **coordinate system** that defines the plane on which you're plotting. Most plots use a Cartesian plane but could use e.g. polar coordinates.
- **faceting system** for breaking the data into subsets
- a **theme** that controls other display details, such as fonts

Our examples today will build increasingly complex graphics that touch on all of these components.

The fact that `ggplot` is rooted in an underlying model allows is advantageous because it allows users to create many different types of plots that share an underlying philosophy. This has enabled developers to create tons of extensions to `ggplot2` to provide support for additional `geoms` and aesthetic features that all follow the same basic rules, making it easier for a users to learn and incorporate new tools into their graphics arsenals. For this course, we like ggplot because it allows us to do a lot with a little. We will be making very interesting graphics in a very short amount of time.

Having said that, there is some effort we need to expend getting mentally used to the *gg* model and how it works. Base graphics are more direct: put a line here, put points there. But base graphics requires a ton of work and wonky code to do the same kind of stuff that `ggplot` does with its hands tied behind its back. For that reason, I think we'll like how quickly we can do cool stuff using `ggplot`.



# Getting `ggplot` to work

The `ggplot2` package contains tons of functions for plotting, but they begin with the titular `ggplot()` function. It works generically like so:

```{r, eval = FALSE}
ggplot(dataset, aes(x = xvariable, y = yvariable))
```

where `dataset` is the name of a tidy data frame, `xvariable` is the variable you want to plot on the horizontal axis, and `yvariable` is the variable you want to plot on the vertical axis. The `aes()` function maps variables in your data to an aesthetic feature of the plot. We use `aes()` when we want to modify the plot's according to *features of the dataset*. (We'll come back to this.) This function is how nearly every graphic begins.

Let's see this with real data. We will first recode two variables, "feeling thermometer" scores for the Democratic and Republican presidential candidates. 

Consult the codebook for information on the "feeling thermometer." You'll notice that values 97-100 are represented with the number 97 in the codebook, while 98 and 99 are special codes for "don't know" and missing responses. So we'll want to remove those. We'll also take the difference between the thermometer scores and create a *relative* thermometer score, where positive values indicate that an individual feels more warmly to the Republican candidate than to the Democratic candidate.

```{r}
# feeling thermometers
summary(anes$VCF0424)  # democratic candidate
summary(anes$VCF0426)  # republican candidate

anes <- anes %>% 
  mutate(therm_demcand = case_when(VCF0424 > 0 & VCF0424 <= 97 ~ VCF0424),
         therm_gopcand = case_when(VCF0426 > 0 & VCF0426 <= 97 ~ VCF0426),
         reltherm_cand = therm_gopcand - therm_demcand)
```

We'll plot the Republican candidate thermometer over the 7-point index of party ID.

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand))
```


# Geoms

You'll notice that the plot is blank. That is because we have not added any geoms to the plot, only a mapping of variables to $x$ and $y$ axes. It is important to note that we could visualize the data using a variety of geoms. It happens to be the cases that points make intuitive sense here. 

You can layer on grammatical components to a plot using the plus sign `+` after the `ggplot()` function.

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_point()
```

We have a lot of data printing overtop one another because we have so many observations. We could jitter point using a jitter geom. We will specify the width of the jittering (the standard deviation), make the points empty circles, and reduce the opacity (alpha) of the points. You can learn more about the available point shapes [here](http://www.sthda.com/english/wiki/r-plot-pch-symbols-the-different-point-shapes-available-in-r).

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, shape = 1, alpha = 0.3)
```

We could add a quick regression line. The regression line won't be biased by the jittering because it is estimated using the data from the original aesthetic mapping (`x = pid7, y = reltherm_cand`), not the jittered data geom from `geom_jitter()`. The geom affects only the way the data are *displayed*, not the underlying values. This is why you should jitter the points as they appear in the plot (using the geom) rather than jittering the underlying data before plotting. (It is part of `ggplot` philosophy to provide tools that modify the way things appear in the plot without needing to modify the underlying data in problematic ways. Neat!)

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, shape = 1, alpha = 0.3) +
  geom_smooth(method = "lm")
```

`geom_smooth()` fits a loess estimate (`method = loess`) by default or, for large datasets, a polynomial estimate (`method = "gam"`). We can specify a linear model pretty easily (that is what the "lm" is for: the `lm()` function for linear regression, which we discuss more next week.). We can add more complex formulas to `geom_smooth()` using the `formula = ` argument. Adding a smooth also adds a confidence interval to the plot by default, but we can't see this one because it is so narrow. 



# More aesthetics

As we said above, aesthetic mappings apply features of the data to some aesthetic property in the plot. So far, we have mapped two variables to $x$ and $y$ axes. We can also map colors, fill colors, point/line sizes, and so on. 

Instead of one regression line, we'll add separate regression lines for two different groups in the data. Let's use gender, so first we need to recode it.

```{r}
anes %$% table(VCF0104)

# 0 is NA/missing, implicitly recoded
anes <- anes %>%
  mutate(gender = case_when(VCF0104 == 1 ~ "Men",
                            VCF0104 == 2 ~ "Women")) 
```

Now that we have this variable, we can map color using it as so.

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, shape = 1, alpha = 0.3) +
  geom_smooth(method = "lm",
              aes(color = gender))
```

That was easy. These colors are automatically added to a legend. (If you're ever created a legend using base graphics, you know how awesome it is that you no longer have to struggle with that).

When you map a variable to an aesthetic, ggplot automatically picks some default values. You can do this for colors, fills (e.g. the color of the confidence interval shading), point sizes, line widths, and so on. You can change defaults using scales.

If you desire, you can add these aesthetic mappings to the first `aes()` call in the `ggplot()` function. This will automatically apply the aesthetic mapping to every `geom()` you call in the plot. In the current example, this would add color to both the smooth line and the points.

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand, color = gender)) +
  geom_jitter(width = 0.2, shape = 1, alpha = 0.3) +
  geom_smooth(method = "lm")
```

If you add overall plot aesthetics to `ggplot()`, you can always override them in any specific geom function. Here we map color inside the `ggplot()` function, but we override that coloring in `geom_jitter()` to make all the points the same color. 

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand, color = gender)) +
  geom_jitter(width = 0.2, shape = 1, alpha = 0.3, size = 0.25,
              color = "slategray") +
  geom_smooth(method = "lm")
```

Note this general behavior. You can always add color to a geom, and it it applies to the entire geom. However, if you want the color to be responsive to be conditioned on some other grouping variable in the data, you must use `aes()`. This is also true for fill, size, alpha, and so on.


# Scales

Scales are used to modify the defaults of any aesthetic mapping. First we'll use it to control gender's mapping by selecting our own colors.

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, shape = 1, alpha = 0.3, size = 0.25) +
  geom_smooth(method = "lm",
              aes(color = gender)) +
  scale_color_brewer(palette = "Set2")
```

Scale functions follow a format of `scale_aesthetic_xyz()`, where `aesthetic` is color, size, and so on. You can control color using color palettes with `scale_color_brewer()`. If you want to specify colors manually, use `scale_color_manual()`. Learn about the stock colors available in R [here](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf).

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, shape = 1, alpha = 0.3, size = 0.25,) +
  geom_smooth(method = "lm",
              aes(color = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon"))
```

Here we also map the confidence interval's fill color and the linetype of the smooth using gender.

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid"))
```

Again, pardon the ugliness of the graphic as we demonstrate ggplot behaviors.

Because `x` and `y` are also aesthetics, we can also modify them using `scale` functions.

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7)
```

I can also add text labels to the tick positions.

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7, 
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Independent", "Lean\nRep", "Weak\nRep", "Strong\nRep"))
```

The `\n` character inserts a line break.


## Aesthetics, scales, and labels

Related to aesthetics and scales is the labels we give these aesthetics. Notice that when we map variables to `x` and `y`, axis titles are created, and as we map variables to color, fill, and so on, a legend title was created. These can be modified with the `labs()` function.

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7, 
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Independent", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  labs(x = "Party ID Index", y = "Relative Candidate Thermometer Score",
       color = "Gender")
```

Notice how if I don't specify every aesthetic name, the legend only changes the names that I specified. I should specify the name for color, fill, and linetype.

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7, 
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Independent", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  labs(x = "Party ID Index", y = "Relative Candidate Thermometer Score",
       color = "Gender", fill = "Gender", linetype = "Gender")
```

I could also remove labels by feeding them a `NULL` value. In this case, we're pretty sure what men and women signify, so maybe including the "Gender" label is redundant. So we can suppress the legend title.

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7, 
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Independent", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  labs(x = "Party ID Index", y = "Relative Candidate Thermometer Score",
       color = NULL, fill = NULL, linetype = NULL)
```



# Coordinate systems

Coordinates are not very complicated. Most of the time you will use a Cartesian grid, so you'll probably do one of two things. 

First, set the axis limits. This is an unrealistic application just to demonstrate the functionality.

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7, 
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Independent", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  labs(x = "Party ID Index", y = "Relative Candidate Thermometer Score",
       color = NULL, fill = NULL, linetype = NULL) +
  coord_cartesian(xlim = c(0, 8), ylim = c(-125, 125))
```

Remember, because the underlying values in the `x` aesthetic are 1 to 7, setting the `xlim` to 0 through 8 will pad each side by one unit. We use the `c()` function to pass a two-element vector of limits (minimum and maximum).

Second is flipping `x` and `y`, which is handy for dot plots and coefficient plots (which we'll see later). This is going to look strange in this example, of course, but again we're just demonstrating the functionality.

```{r}
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7, 
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Independent", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  labs(x = "Party ID Index", y = "Relative Candidate Thermometer Score",
       color = NULL, fill = NULL, linetype = NULL) +
  coord_flip(xlim = c(0.5, 7.5))
```

What's important to remember here is that the `x` and `y` aesthetics have not changed, only the way they are *displayed* in the graphic. The `scale_x_continuous()` function, therefore, still modifies the party ID variable scale even though it's now the vertical axis. That's because `scale_x_continuous()` modifies the *x aesthetic*, not the *horizontal axis* per se. This same intuition works when we specify `xlim` inside the `coord_flip()` function.



# Switching to another example

Here we will start to get serious about pretty graphics by switching to another example: party ID among men and women over time, with confidence intervals.

First, we have to create the data. I'll do this with my own confidence interval function that can handle survey weights. Don't sweat too much how these data are created, but do note the structure of the data that we are working with. We have a proportion estimate of each party ID group, plus upper and lower bounds on that proportion estimate. We'll aggregate this into a dataset called `pid_gendergap`.

```{r}
# CI function
prop_ci <- function(successes, n, level=0.05) {

  # get parameters
  p1 <- successes/n
  q1 <- 1 - p1

  # compute standard error
  SE <- sqrt((p1*q1)/n)

  # find upper and lower bound
  lower <- p1 - qnorm(1-(level/2))*SE
  upper <- p1 + qnorm(0.975)*SE

  # return data frame
  return(data.frame(lower, upper))

}

# rename weight variable and
# collapse the party variable into 3 categories
anes <- anes %>% 
  rename(wt = VCF0009z) %>%
  mutate(party = case_when(pid7 %in% 1:3 ~ "Dem", 
                           pid7 == 4 ~ "Ind", 
                           pid7 %in% 5:7 ~ "Rep"))

# proportion in each PID in each year
pid_gendergap <- anes %>%
  select(cycle, gender, party, wt) %>%
  # weighted count in each cycle x gender x party category
  group_by(gender, cycle, party) %>%
  count(wt = wt) %>%
  rename(x = n) %>% 
  # get the denominator by summing within gender x cycle
  group_by(gender, cycle) %>%
  mutate(n = sum(x)) %>% 
  ungroup() %>%
  # proportion in each party ID, with CIs
  mutate(prop = x / n,
         lower = prop_ci(successes = x, n = n)$lower,
         upper = prop_ci(successes = x, n = n)$upper) %>%
  # drop NAs
  filter(cycle > 1948 & !is.na(party)) %>%
  select(cycle, gender, party, prop:upper) %>%
  print()
```

Now we'll use this dataset to demonstrate some more concepts.

# Facets

Faceting creates subsets for plotting. Here we create separate panels for men and women.

Note the rest of the graphic. We plot cycle as the `x`, the proportion in each party ID as the `y`, and color according to party ID. This is possible because we created a nice tidy dataset that has columns dedicated to each variable we want to incorporate when plotting.

Note we also use the `geom_line()` geom, which obviously plots a line.

There are two faceting functions. `facet_wrap()` wraps categories. If we had a lot of categories, the panels would wrap across rows.

```{r}
ggplot(pid_gendergap, aes(x = cycle, y = prop, color = party)) +
  facet_wrap(~ gender) +
  geom_line()
```

We use the `~` notation so that ggplot knows that `gender` is in the `pid_gendergap` data frame.

The `facet_grid()` function, rather than wrapping, lets you specify a grid of variables to be divided into rows and columns (using `facet_grid(rowvar ~ colvar)`. Let's do an example where gender is in rows and partisanship is in columns. 

```{r}
ggplot(pid_gendergap, aes(x = cycle, y = prop, color = party)) +
  facet_grid(gender ~ party) +
  geom_line()
```

You can suppress a row or column variable using `.`

```{r}
ggplot(pid_gendergap, aes(x = cycle, y = prop, color = party)) +
  facet_grid(. ~ gender) +
  geom_line()
```




# Confidence intervals as ribbons

Here's a cool geom: `geom_ribbon()`. It lets you color in regions of the plot, which is especially useful for confidence intervals. We will use the `lower` and `upper` variables in our dataset for the upper and lower bounds of the ribbon. Let's also add points.

```{r}
ggplot(pid_gendergap, aes(x = cycle, y = prop, color = party)) +
  facet_grid(. ~ gender) +
  geom_line() +
  geom_point() +
  geom_ribbon(aes(ymin = lower, ymax = upper))
```

So the "color" of the ribbon is mapped to party. For a ribbon, "color" is the outline color, while "fill" is the interior. We should map party to fill, therefore.

```{r}
ggplot(pid_gendergap, 
       aes(x = cycle, y = prop, color = party, fill = party)) +
  facet_grid(. ~ gender) +
  geom_line() +
  geom_point() +
  geom_ribbon(aes(ymin = lower, ymax = upper))
```

We'll turn down the opacity (alpha) of the ribbon so we can see what's going on inside it. We'll also make the points smaller.

```{r}
ggplot(pid_gendergap, 
       aes(x = cycle, y = prop, color = party, fill = party)) +
  facet_grid(. ~ gender) +
  geom_line() +
  geom_point(size = 1) +
  geom_ribbon(aes(ymin = lower, ymax = upper),
              alpha = 0.3)
```

Let's just remove the ribbon color. It's getting in the way.

```{r}
ggplot(pid_gendergap, 
       aes(x = cycle, y = prop, color = party, fill = party)) +
  facet_grid(. ~ gender) +
  geom_line() +
  geom_point(size = 1) +
  geom_ribbon(aes(ymin = lower, ymax = upper),
              alpha = 0.3, 
              color = NA)
```


We'll continue making this plot prettier by modifying the coordinates, aesthetics, scales, and labels. Note: we have to change the color and fill separately, since they're separate aesthetics.

We'll also change the `y` labels using the `percent()` function in the `scales` package, which should be automatically installed and loaded with `ggplot2` (install it if not!). Note that this only changes the printing of the labels, not the underlying data. This is convenient because if we ever want to change from proportions to percentages, we don't have to change the underlying data.

```{r}
ggplot(pid_gendergap, 
       aes(x = cycle, y = prop, color = party, fill = party)) +
  facet_grid(. ~ gender) +
  geom_line() +
  geom_point(size = 1) +
  geom_ribbon(aes(ymin = lower, ymax = upper),
              alpha = 0.3,
              color = NA) +
  coord_cartesian(ylim = c(0, 0.65)) +
  scale_y_continuous(breaks = seq(0, .6, .1), labels = scales::percent) +
  scale_color_manual(values = c("dodgerblue", "gray50", "maroon")) +
  scale_fill_manual(values = c("dodgerblue", "gray50", "maroon")) +
  labs(x = "Election Year",
       y = "Proportion Identifiers",
       color = "Partisanship",
       fill = "Partisanship")
```

The scales package also lets us easily do log transformations, print large numbers with commas for the thousands places, and so on. I encourage you to do your own research those needs arise.

# Themes

Themes control ancillary aesthetic components of the plot. There are several preloaded themes that you can learn about [here](http://ggplot2.tidyverse.org/reference/ggtheme.html), and you can learn about [other ggplot theme packages online](https://cran.r-project.org/web/packages/ggthemes/vignettes/ggthemes.html).

We'll use `theme_bw()`.

```{r}
ggplot(pid_gendergap, 
       aes(x = cycle, y = prop, color = party, fill = party)) +
  facet_grid(. ~ gender) +
  geom_line() +
  geom_point(size = 1) +
  geom_ribbon(aes(ymin = lower, ymax = upper),
              alpha = 0.3,
              color = NA) +
  coord_cartesian(ylim = c(0, 0.65)) +
  scale_y_continuous(breaks = seq(0, .6, .1), labels = scales::percent) +
  scale_color_manual(values = c("dodgerblue", "gray50", "maroon")) +
  scale_fill_manual(values = c("dodgerblue", "gray50", "maroon")) +
  labs(x = "Election Year",
       y = "Proportion Identifiers",
       color = "Partisanship",
       fill = "Partisanship") +
  theme_bw()
```

There is also a `theme()` function, which allows you to change details of the theme without changing the entire theme. Here we will suppress the "minor" grid lines for the y axis only.

```{r}
ggplot(pid_gendergap, 
       aes(x = cycle, y = prop, color = party, fill = party)) +
  facet_grid(. ~ gender) +
  geom_line() +
  geom_point(size = 1) +
  geom_ribbon(aes(ymin = lower, ymax = upper),
              alpha = 0.3,
              color = NA) +
  coord_cartesian(ylim = c(0, 0.65)) +
  scale_y_continuous(breaks = seq(0, .6, .1), labels = scales::percent) +
  scale_color_manual(values = c("dodgerblue", "gray50", "maroon")) +
  scale_fill_manual(values = c("dodgerblue", "gray50", "maroon")) +
  labs(x = "Election Year",
       y = "Proportion Identifiers",
       color = "Partisanship",
       fill = "Partisanship") +
  theme_bw() +
  theme(panel.grid.minor.y = element_blank())
```

If we wanted to modify the x axis scale, it might get cluttered.

```{r}
ggplot(pid_gendergap, 
       aes(x = cycle, y = prop, color = party, fill = party)) +
  facet_grid(. ~ gender) +
  geom_line() +
  geom_point(size = 1) +
  geom_ribbon(aes(ymin = lower, ymax = upper),
              alpha = 0.3,
              color = NA) +
  coord_cartesian(ylim = c(0, 0.65)) +
  scale_y_continuous(breaks = seq(0, .6, .1), labels = scales::percent) +
  scale_x_continuous(breaks = seq(1952, 2012, 8)) +
  scale_color_manual(values = c("dodgerblue", "gray50", "maroon")) +
  scale_fill_manual(values = c("dodgerblue", "gray50", "maroon")) +
  labs(x = "Election Year",
       y = "Proportion Identifiers",
       color = "Partisanship",
       fill = "Partisanship") +
  theme_bw() +
  theme(panel.grid.minor.y = element_blank())
```

We could use the theme function to print the x axis diagonally and shift it down.

```{r}
ggplot(pid_gendergap, 
       aes(x = cycle, y = prop, color = party, fill = party)) +
  facet_grid(. ~ gender) +
  geom_line() +
  geom_point(size = 1) +
  geom_ribbon(aes(ymin = lower, ymax = upper),
              alpha = 0.3,
              color = NA) +
  coord_cartesian(ylim = c(0, 0.65)) +
  scale_y_continuous(breaks = seq(0, .6, .1), labels = scales::percent) +
  scale_x_continuous(breaks = seq(1952, 2012, 8)) +
  scale_color_manual(values = c("dodgerblue", "gray50", "maroon")) +
  scale_fill_manual(values = c("dodgerblue", "gray50", "maroon")) +
  labs(x = "Election Year",
       y = "Proportion Identifiers",
       color = "Partisanship",
       fill = "Partisanship") +
  theme_bw() +
  theme(panel.grid.minor.y = element_blank(),
        axis.text.x = element_text(angle = 45, vjust=0.75))
```


# Finishing touches and saving a graphic

Let's use the `labs()` function to add some titles and captions. We'll also tweak the caption color.

```{r}
ggplot(pid_gendergap, 
       aes(x = cycle, y = prop, color = party, fill = party)) +
  facet_grid(. ~ gender) +
  geom_line() +
  geom_point(size = 1) +
  geom_ribbon(aes(ymin = lower, ymax = upper),
              alpha = 0.3,
              color = NA) +
  coord_cartesian(ylim = c(0, 0.65)) +
  scale_y_continuous(breaks = seq(0, .6, .1), labels = scales::percent) +
  scale_x_continuous(breaks = seq(1952, 2012, 8)) +
  scale_color_manual(values = c("dodgerblue", "gray50", "maroon")) +
  scale_fill_manual(values = c("dodgerblue", "gray50", "maroon")) +
  labs(x = "Election Year",
       y = "Proportion Identifiers",
       color = "Partisanship",
       fill = "Partisanship",
       title = "Party Identification of Men and Women",
       subtitle = "Leaning independents coded as partisans",
       caption = "Data source: ANES Cumulative File") +
  theme_bw() +
  theme(panel.grid.minor.y = element_blank(),
        axis.text.x = element_text(angle = 45, vjust=0.75),
        plot.caption = element_text(color = "gray", size = rel(0.75)))
```


This looks like a darn good graphic now, and it didn't take much code at all!

Saving this graphic is easy with the `ggsave` function. You generally want to save graphic as vector images in order to scale (that is, embiggen) a graphic without any pixelation. PDF is usually good for papers and presentations.

```{r, eval = FALSE}
# generally want to save it into your paper's dedicated folder, inside the graphics folder
# set height and width (usually requires some trial and error)
ggsave("paper/graphics/party-gender-gap.PDF", width = 5, height = 3)
```

# Other graphics

There are plenty of other geoms that use slightly different aesthetics. Let's just breeze through some now.


## Histrograms and density plots

Histrograms and density plots, because they only show the distribution of one variable, only need one axis aesthetic (`x`).

```{r}
anes %>%
  filter(!is.na(party)) %>% 
  ggplot(aes(x = reltherm_cand)) +
    geom_histogram(aes(color = party)) +
    labs(x = "Relative Candidate Thermometer Score",
         y = "Frequency",
         color = "Partisanship")
```

Histogram bars are stacked by default, which is weird. Let's make them dodge each other.

```{r}
anes %>%
  filter(!is.na(party)) %>% 
  ggplot(aes(x = reltherm_cand)) +
    geom_histogram(aes(color = party,
                       fill = party),
                   alpha = 0.5,
                   position = "dodge") +
    scale_color_manual(values = c("dodgerblue", "gray20", "maroon")) +
    scale_fill_manual(values = c("dodgerblue", "gray20", "maroon")) +
    labs(x = "Relative Candidate Thermometer Score",
         y = "Frequency",
         color = "Partisanship",
         fill = "Partisanship")
```

You can also do kernel density estimates (which allow you set the kernel bandwidth):

```{r}
anes %>%
  filter(!is.na(party)) %>% 
  ggplot(aes(x = reltherm_cand)) +
    geom_density(aes(color = party, fill = party),
                   alpha = 0.5,
                   bw = 7) +
    scale_color_manual(values = c("dodgerblue", "gray20", "maroon")) +
    scale_fill_manual(values = c("dodgerblue", "gray20", "maroon")) +
    labs(x = "Relative Candidate Thermometer Score",
         y = "Density",
         color = "Partisanship",
         fill = "Partisanship")
```



## Bar graphs

It's a personal preference of mine that I think just about anything that you can show with a bar graph would be better with a dot plot. I tend to think that bar graphs are awkward and misused (e.g. for treatment effects). In my head, bars should be for counts or other things where zero is a hard lower bound (such as proportions). Bah! Anyway, here's how you do them.

Let's make some data of the Democratic share of the two-party vote choice for each partisanship category.

```{r}
# dummy variable for Dem vote (0 = Rep vote, else NA)
anes <- anes %>%
  mutate(vote = VCF0706,
         vote = case_when(vote == 1 ~ "Democratic Candidate",
                          vote == 2 ~ "Republican Candidate"))

# calculate averages for each party
# presidential years since 2000
mean_votes <- anes %>%
  filter(cycle >= 2000 & (cycle %% 4) == 0) %>%
  filter(!is.na(pid7)) %>% 
  group_by(cycle, pid7, vote) %>%
  # weighted count of vote choice for each party ID
  count(wt = wt) %>%
  filter(!is.na(vote)) %>%
  rename(x = n) %>%
  # denominator for proportion
  group_by(pid7, cycle) %>% 
  mutate(n = sum(x, na.rm = TRUE),
         prop = x / n) %>%
  filter(vote == "Democratic Candidate") %>% 
  print()
```

And then plot these averages.

```{r}
ggplot(mean_votes, aes(x = pid7, y = prop)) +
  geom_col(fill = "gray50") +
  facet_wrap(~ cycle) +
  scale_x_continuous(breaks = 1:7,
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Ind", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  labs(x = "Party ID",
       y = "Democratic Share of Two-Party Vote") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```

Here is the same plot as a dot plot, also changing the scales.

```{r}
ggplot(mean_votes, aes(x = pid7, y = prop)) +
  geom_point() +
  facet_wrap(~ cycle) +
  scale_x_continuous(breaks = 1:7,
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Ind", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Party ID",
       y = "Democratic Share of Two-Party Vote") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```


And you can often rotate dot plots so that their labels have more space to print out.

```{r}
ggplot(mean_votes, aes(x = pid7, y = prop)) +
  geom_point() +
  facet_wrap(~ cycle) +
  scale_x_continuous(breaks = 1:7,
                     labels = c("Strong Democrat", "Weak Democrat", "Lean Democrat", "Independent", "Lean Republican", "Weak Republican", "Strong Republican")) +
  scale_y_continuous(breaks = seq(0, 1, .2),
                     labels = scales::percent) +
  labs(x = "Party Identification",
       y = "Democratic Share of Two-Party Vote") +
  theme_bw() +
  theme(panel.grid.minor = element_blank()) +
  coord_flip()
```

There are some other things you can do with geoms. One thing you can do for dot plots is use `geom_pointrange`, which adds a point and an error bar. Like `geom_ribbon`, it takes a `ymin` and `ymax` aesthetic. This makes it good for confidence intervals. Here, we'll use it in a slightly hacky way to help us trace which point goes with which category, making it a little easier to read the plot. Notice how I set the min and max aesthetics.

```{r}
ggplot(mean_votes, aes(x = pid7, y = prop)) +
  geom_pointrange(aes(ymin = 0, ymax = prop),
                  linetype = "dotted") +
  facet_wrap(~ cycle) +
  scale_x_continuous(breaks = 1:7,
                     labels = c("Strong Democrat", "Weak Democrat", "Lean Democrat", "Independent", "Lean Republican", "Weak Republican", "Strong Republican")) +
  scale_y_continuous(breaks = seq(0, 1, .2),
                     labels = scales::percent) +
  labs(x = "Party Identification",
       y = "Democratic Share of Two-Party Vote") +
  theme_bw() +
  theme(panel.grid.minor = element_blank()) +
  coord_flip()
```

--- 




# Categorical variables (strings and factors)

If you plot a categorical variable on one of the axes, `ggplot` will automatically interpret it and plot categories side-by-side. We'll demonstrate this with a toy example.

One potential problem, though, is that `ggplot` will order categorical variables alphabetically or, if the variable is already an ordered factor, will interpret the factor order out of the metadata about the levels.

Here we show what happens when we plot a string variable that can be ordered alphabetically:

```{r}
# x and y: continuous variables
# s: string variable
# f: factor variable with weird order
d <- data_frame(x = rnorm(100, 0, 1),
                y = 4 + (2 * x) + rnorm(100, 0, 1),
                s = sample(c("a", "b", "c", "d"), 100, replace = TRUE),
                f = factor(s, levels = c("c", "d", "a", "b")))

ggplot(d, aes(x = s, y = y)) +
  geom_jitter(shape = 1, width = 0.15) +
  labs(x = "String", y = "Continuous") 
```

...and if we plot from a factor that already has ordered levels...

```{r}
ggplot(d, aes(x = f, y = y)) +
  geom_jitter(shape = 1, width = 0.15) +
  labs(x = "Ordered Factor", y = "Continuous") 
```


...or we wanted to assign colors using an ordered factor.

```{r}
ggplot(d, aes(x = x, y = y)) +
  geom_point(shape = 1,
             aes(color = f)) +
  labs(x = "Continuous", 
       y = "Continuous",
       color = "Ordered Factor") 
```

To reorder these categories, I recommend using tools in the `forcats` package, which, conveniently, is part of the `tidyverse` package.

- `fct_relevel()`: declare a factor variable, and then declare the order of levels. Any level not listed during reordering is given the same precedence as the original variable
- `fct_rev()`: reverse the order of a factor's levels
- `fct_recode()`: change the levels of a factor

Here is an example where we take the `f` variable, a factor with ordered levels, and rearrange the order of the levels so that they appear in the legend with the proper order. This is called "releveling" (changing the order of levels), as opposed to "recoding" (changing the labels themselves).

```{r}
fixed_d <- d %>%
  mutate(fixed_f = fct_relevel(f, "a", "b", "c", "d")) %>%
  print()
```

You'll note that the variables `f` and `fixed_f` now have the same values, but the ordering of `fixed_f`'s levels has been modified.

```{r}
ggplot(fixed_d, aes(x = x, y = y)) +
  geom_point(shape = 1,
             aes(color = fixed_f)) +
  labs(x = "Continuous", 
       y = "Continuous",
       color = "Ordered Factor") 


ggplot(fixed_d, aes(x = f, y = y)) +
  geom_point(shape = 1) +
  labs(x = "Ordered Factor", y = "Continuous") 
```


## An aside on `stringr`

The `stringr` package contains a few useful functions for modifying character vectors.

Let's take the `state.name` vector that comes with R.

```{r}
state.name
```

Here are some useful functions.

```{r}
# look for pattern, return a logical vector
str_detect(state.name, " ") #  spaces

# example: return all two-word state names
state.name[str_detect(state.name, " ")]

# substring based on character position
str_sub(state.name, 1L, 3L)
str_sub(state.name, -3L, -1L)

# cut a string based on a pattern match (returns a list)
str_split(state.name, pattern = " ")

# grab the nth element of a split string list
sapply(str_split(state.name, pattern = " ") , function(x) x[2])

# replace a pattern with another pattern
str_replace(state.name, pattern = " ", replacement = "-")

# for strings that might contain multiple instances of the pattern
# (won't notice a difference here)
str_replace_all(state.name, pattern = " ", replacement = "-")
```


# Concluding notes



## Why plot

You should be plotting your data often, even if you don't expect the plot to make it into your final product. 

- Plotting shows you the distribution of your data, which can help you decide on certain modeling assumptions or variable transformations.
- Plotting shows outliers.
- Plotting gives you a sense of the underlying trends in your data so you can be a better thinker about the problem at hand. 

You can see Hadley Wickham do some exploratory analysis [here](https://www.youtube.com/watch?v=go5Au01Jrvs), which shows how graphics (and `ggplot` in particular) facilitates principled and *fast* exploration of your data. 



## Data and `ggplot`

If you haven't already picked up on it, `ggplot` is designed to complement the philosophy of tidy data. It does this mainly by forcing you to declare a data frame from which you are plotting. This helps ensure that the data you are plotting are conceptually related and can be easily mapped to plot aesthetics. And in order to shape your data so that these mappings are done correctly, the tools in `tidyr` and `dplyr` are extremely helpful.

As we have seen, many tools in `ggplot` are designed to prevent you from modifying the underlying data too much. This is generally a tenet of the Tidyverse philosophy. Your original data frames are sacrosanct, and they serve as the raw material from which analyses and plots are extracted. This is why pipe chains begin with a tidy dataset and work out from there. Changes that you make to the data that *only* exist for the purpose of plotting (or modeling, etc.) should be temporary, as they are not essential to the core underlying data.

Say that you have raw data that has an ugly text label, and every time you plot that variable, you want a prettier text label. Rather than change the underlying data, you might make another table that serves as a dictionary for converting the ugly label to a prettier label. You can then merge this table into your data just before plotting. Practices such as this keep your original data free of extraneous stuff while still allowing you to produce beautiful graphics.

## Graphics approaches, base vs `ggplot`

Base graphics, on the other hand, do not rely on an underlying data model in order to work. You can plot points, lines, labels, and so on, with no conceptual connection between the data used for any of these geoms. Furthermore, legends and labels are entirely detached from the data. This makes base graphics inefficient and prone to human error in a number of ways, mainly because updates to the elements of your graphics need to made separately from updates to legends, labels, axes and so on. These elements are all conceptually independent in base graphics. so they have know knowledge about how you change the data or the appearance of the graphics. That said, it isn't impossible to create a `ggplot`-esque graphic using base tools; it will just take more work and more time to do it.

All this being said, base graphics do have some advantage on `ggplot` graphics if you have to create a plot that contains many unrelated elements that don't share a common data frame. (It isn't impossible to plot from multiple data frames in `ggplot`, but it isn't easy.) 

You can find plenty of disagreements online about how and when base or `ggplot` tools are better. I have an opinionated stance on it, but I'm making the bet that this lesson will lead you to agree with me.


## Other graphical Dos and Don'ts

Some general advice for plotting:

- Never use multiple Y axes. It's easy to use multiple Y axis scales to make variables look more or less related, so you shouldn't do it. In fact, `ggplot` won't let you (because it's opinionated like that).
- Try to make your graphics as minimal as possible. Add elements where it improves the graphic. Otherwise, you don't want to create clutter.
- If you can label points or trends *in the plot* rather than in a legend, do so. You can do this with `geom_text` or the `annotate()` function.


## Other `gg` tools

There are many extensions for `ggplot` that you can install. Rather than tediously describe them, I'll point you to a [web page](http://www.ggplot2-exts.org/gallery/?utm_content=buffer6d153&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer) discussing many of the tools out there. These let you create heatmaps, choropleths, network graphs, mosaic plots, autocorrelation plots, and much more. Extensions I have used in the past include `ggfortify`, `ggridges`, `ggthemes`, `ggsci`, `GGally`, and `ggalt`.


## Graphics in future lessons

We will further explore graphics using `ggplot` in the final lesson on statistical analysis. In particular, we'll discuss how to use `ggplot` tools to summarize statistical models and create post-estimation graphics.


# Save data from this session

```{r, eval = FALSE}
saveRDS(anes, "data/anes-modified-2.RDS")
```

```{r, include = FALSE}
saveRDS(anes, here::here("static/data/anes-modified-2.RDS"))
```
