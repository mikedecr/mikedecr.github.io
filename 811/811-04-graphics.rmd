---
title: "Lecture 2: Graphics"
description: "Graphics in R using ggplot2"
author: "Michael DeCrescenzo"
date: '2018-02-16'
slug: "811-graphics"
categories: ["R", "ps811", "Teaching"]
tags: []
draft: true
---


# Schedule:

Read this before our second R lecture, after the [data lesson](811/811-data).



# How to follow along

A script file walking through some of these commands is available [here](https://uwmadison.box.com/s/mbb25zbc7r7h5plpesgk71kzjqcv7hw1).


# Objectives

The goal of this lesson is to provide an introduction to graphics in R, by way of `ggplot2` in particular. We will cover:

- The "grammar of graphics"---the "gg" in `ggplot`
- How `ggplot2` works
- Common graphics in social science
- Customizing the appearance of ggplot graphic
- Saving graphics

## Some notes to get us started:

- This lesson makes liberal use of pipe chains, which bundle many operations together in one block of code. After last week's lesson, you should be getting comfortable with these. Hopefully my heavy use of them in this (and the next) lesson will demonstrate how essential piping is to the cutting-edge of using R. 
- Because piping is so essential that it appears nearly everywhere, I cannot painstakingly describe every step of every pipe chain---it will take too much of your attention away from what I'm trying to teach in the moment. If you want to dissect what a particular pipe chain is doing, you should run the chain *up to a point* and notice what the results look like when you stop the chain *here* as opposed to *there*. This is often how you write pipe chains as well---writing a line of code, checking the results, and planning what the next step should be.
- Plots created using `ggplot` generally look good by default. As we get started, however, they may look a little awkward. This is because I want to begin by demonstrating ggplot *functionality* (which we don't want to rush though), not creating the prettiest plot imaginable. As we introduce more and more ggplot concepts, plots will begin to look better.
- If you want more help with `ggplot`, I'd recommend that you consult resources I list in the syllabus, in other lessons, and Hadley Wickham's `ggplot2` book (which you can build into a PDF on your own computer [after installing some other tools]). 
- For advice about the principles of creating *good* graphics, you can also check books by folks such as [Claus Wilke](http://serialmentor.com/dataviz/index.html) (author of the `ggridges` and `cowplot` packages for augmenting `ggplot2`) and [Kieran Healy](http://socviz.co/) (author of the brilliant "[Fuck Nuance](https://kieranhealy.org/files/papers/fuck-nuance.pdf)" paper, which isn't about graphics but is worth reading anyway).




# Get started

The `ggplot2` package is loaded whenever you load the `tidyverse` package (but I sometimes load the `ggplot2` package anyway because it sometimes gives your code editor better auto-complete behavior). We'll also install and load `labelled`, which we'll use to remove Stata labels from the data (we don't need them). 


```{r, eval = FALSE, message = FALSE}
library("magrittr")
library("tidyverse")
library("ggplot2")
install.packages("labelled")
```

```{r, include = FALSE, message = FALSE}
library("magrittr")
library("tidyverse")
library("ggplot2")
```

Set your directory where it was last lesson and load the *modified ANES dataset from the previous lesson*:

```{r, eval = FALSE}
# set directory
setwd("~/path/to/wherever")

# read saved RDS data from last lesson
# and remove Stata labels from the data
anes <- readRDS("data/anes-modified.RDS") %>% 
        mutate_all(labelled::remove_labels) 

# pkg::function lets us use functions without loading the full package
# mutate_all applies a function to every variable in the dataset
#   similar to apply() functions, which we'll cover next lesson
```

```{r, include = FALSE, cache = TRUE}
anes <- readRDS(here::here("static/data/anes-modified.RDS")) %>%
        mutate_all(labelled::remove_labels)
```


Verify that you imported the correct dataset when you notice the modified variable names.

```{r, eval = FALSE}
names(anes)
```





# The grammar of graphics

The [grammar of graphics](https://www.springer.com/us/book/9780387245447) is essentially a theory/model that describing the components of a graphic. `ggplot2` is an R package that implements the grammar [in a layered fashion](http://byrneslab.net/classes/biol607/readings/wickham_layered-grammar.pdf) by iteratively adding grammatical components to a figure using functions. 

It is not necessary to consciously memorize the theoretical components of the grammar of graphics---you get an unconscious feel for it---though we will briefly describe it. Suffice it to say that what matters most for you is that the underlying grammar provides a *structure* to `ggplot2` that makes it easy to create complex graphics with an integrated syntax and carefully chosen defaults.

Here are the core components of the grammar of graphics:

- **Data**: what gets visualized
- **Aesthetic mappings**: Attributes of the plot that come directly from the data (plot axes, color groupings)
- **Geoms**: geometric representations of the data (lines, points, etc.); the shapes used to present the values in your data in the plot
- **Scales**: modify how aesthetic mappings are presented. Every mapping from data to plot can be altered (e.g. changing colors, modifying axes, etc.)
- **Coordinates**: the plane on which you're plotting. Most plots use a Cartesian plane ($x$ and $y$ coordinates), but less conventional planes are also possible (e.g. polar coordinates)
- **Faceting system**: how to plot subsets of data in different panels. 
- **Theme**: other aesthetic minutia, such as fonts

Our examples today will start from the basics and build outward, touching on all of these components of the grammar. 

Because `ggplot` is rooted in an underlying model, it's easy to create many different types of plots that share an underlying philosophy and syntax structure. Even if you have never made a particular sort of plot before, you know how you *would* create it, because all plots come from the same building blocks. For instructional purposes, this is great because we will be making very interesting graphics in a very short amount of time.




# Using `ggplot2` 

Graphics from `ggplot2` begin with the titular `ggplot()` function. It works generically like so:

```{r, eval = FALSE}
ggplot(dataset, aes(x = xvariable, y = yvariable))
```

where `dataset` is the name of your dataset, `xvariable` is the variable you want to plot on the horizontal axis, and `yvariable` is the variable you want to plot on the vertical axis. Some details:

- All `ggplot` graphics begin with a data frame. It must be tidy, because we must specify the columns that are mapped to plot aesthetics. As such, we can see why the other components of the Tidyverse work with ggplot---ggplot requires tidy data, and the rest of the Tidyverse is designed to make that easy. 
- The `aes()` function maps variables in your data to an aesthetic feature of the plot. We will use `aes()` whenever we want to modify the plot's according to *features of the dataset*. 
- Every graphic will begin with a declaration of a dataset and a declaration of at least one aesthetic mapping. 


## ANES example

Let's see this with real data. 

We will first recode two variables, "feeling thermometer" scores for the Democratic and Republican presidential candidates. These variables ask respondents to rate candidates on a 0-100 scale, where 100 is "most warm" and 0 is "most cold," with 50 in the middle.

If we consult the codebook for information on the "feeling thermometer," We will notice that all values 97-100 are represented with the number 97 in the codebook, while 98 and 99 are special codes for "don't know" and missing responses. I have no idea why this decision was made, but we have to work with it. We'll want to keep only values 0--97 as valid, and recode everything else to `NA`. 

Once we do that, we will take the difference between the thermometer scores to create a *relative* candidate thermometer rating. Positive values will indicate that an individual feels more warmly to the Republican candidate than to the Democratic candidate, so we will calculate this as the Republican rating minus the Democratic rating.

```{r}
# learn some stuff about the feeling therm variables
summary(anes$VCF0424)  # democratic candidate
summary(anes$VCF0426)  # republican candidate

# bonus: try the skim() function in the 'skimr' package
#   skim() is like summarize(), but it creates data frames

# now that we have a sense of the values of this variable, we'll recode 
# keep 0-97 with case_when(), which implicitly converts all else to NA
# then calculate the difference

anes <- anes %>% 
  mutate(therm_demcand = case_when(VCF0424 > 0 & VCF0424 <= 97 ~ VCF0424),
         therm_gopcand = case_when(VCF0426 > 0 & VCF0426 <= 97 ~ VCF0426),
         reltherm_cand = therm_gopcand - therm_demcand)
```

We'll plot the Republican candidate thermometer over the 7-point index of party ID, which we recoded last week.

```{r}
# data come from anes dataset
# x = party ID, y = candidate thermometer difference
ggplot(data = anes, aes(x = pid7, y = reltherm_cand))
```

This creates a blank plot, but if you think about the grammar, you will understand what happened. We mapped these variables to the `x` and `y` aesthetics, but we haven't chosen how to present the data yet. 


# Geoms

It is important to note that we could visualize the data using a variety of geoms. It happens to be the cases that points make intuitive sense here. 

We layer on grammatical components to a plot using the plus sign `+` after the `ggplot()` function. Each thing that we layer on is done with a function. For geoms, there are a bunch of functions that share the prefix `geom_`. Points are done with `geom_point()`, lines with `geom_line()`, and so on. 

```{r}
# represent the data as points
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_point()
```

What happened here?

- We got a warning about missing data not being plotted. This is helpful, but I will suppress these for the remainder of the lesson.
- We have a lot of data printing overtop one another because we have so many observations at relatively few combinations of values (only 7 $x$ values). 

## Jittering points

To prevent data from printing overtop one another, it is often helpful to *jitter* the points. Jittering is no more than adding a little bit of noise to the data. We also change the "shape" of the point. Learn more about the available point shapes [here](http://www.sthda.com/english/wiki/r-plot-pch-symbols-the-different-point-shapes-available-in-r).

```{r, warning = FALSE}
# geom_jitter() plots jittered points
# we jitter the points IN THE PLOT, not in the underlying data
# we specify how much noise to add (width = )
# shape = 1 plots empty points
# alpha controls the opacity of the points

ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, shape = 1, alpha = 0.3)
```

## Fit lines

Let's add a regression line with `geom_smooth()`. "Smooth" refers to any model-fit curve we might impose on the plot. We specify that we want a linear curve with `method = lm`. Adding a smooth also adds a confidence interval to the plot by default, but we can't see this one because it is so narrow. I will also demonstrate how you can directly change colors (learn more about available colors [here](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)).

```{r, warning = FALSE}
# geom_smooth() adds a model fit line
# method = "lm" specifies a Linear Model
#   By default, `geom_smooth()` fits a loess regression (method = "loess") 
#   for large datasets, it will fit a polynomial model (method = "gam")

ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, shape = 1, alpha = 0.3) +
  geom_smooth(method = "lm", color = "red")
```

You could plot your own custom regression using the `formula = ` argument. 

Here's an important point. The regression line gets fit to the underlying data (the `x` and `y` aesthetics), so it does not get biased by the jittering. This is because jittering is only applied to the points *as they are printed in the plot*; it does not jitter the underlying data directly. This is an example of an important philosophical point about plotting: if you need to perform any weird tricks to make the plot look good, you should strive to modify the *plot* rather than the underlying data. Because ggplot is another "opinionated" package, it has many tools that make it easy to adhere to this philosophy. 



# More aesthetics (color, etc)

As we said above, aesthetic mappings apply features of the data to some aesthetic property in the plot. So far, we have mapped two variables to $x$ and $y$ axes. We can also map colors, fills (interior colors), the sizes of points and lines sizes, line patterns (called "linetypes"), and so on.

Instead of plotting one regression line, we'll add separate regression lines for two different groups in the data. Let's use gender, so first we need to recode it.

```{r}
# here is the raw gender variable in the data
count(anes, VCF0104)

# 0 means NA/missing
# use case_when() to implicitly recode 0 as NA

anes <- anes %>%
  mutate(gender = case_when(VCF0104 == 1 ~ "Men", 
                            VCF0104 == 2 ~ "Women"))
```

Now that we have this variable cleaned up, we can map it to the color aesthetic.

```{r, warning = FALSE}
# create different colored lines by gender
# that is, map color according to gender (from the data)
# any time we want to map from the data, we must use aes().

ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, shape = 1, alpha = 0.3) +
  geom_smooth(method = "lm",
              aes(color = gender))
```

Simple! These colors are also automatically added to a legend. (If you're ever created a legend using base graphics, you know how awesome it is that you no longer have to struggle with that).

When you map a variable to an aesthetic, ggplot automatically picks some default values. This happens for colors, fills (e.g. the color of the confidence interval shading), point sizes, line widths, and so on. You can change defaults using scales, which we'll describe below.


# Scales

When you use `aes()`, ggplot picks some default mapping settings, such as axis scales, color defaults, and so on. Use `scale_` functions to modify the defaults of any aesthetic mapping. 

First we'll use it to control gender's mapping by selecting our own colors.

```{r, warning = FALSE}
# aesthetic mapping makes default choices
# modify those default mapping choices using scale_aes_something() functions
# scale_color_brewer modifies color using color palettes
#   (can do your own googling about color palettes)

ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, shape = 1, alpha = 0.3, size = 0.25) +
  geom_smooth(method = "lm",
              aes(color = gender)) +
  scale_color_brewer(palette = "Set2")
```

Scale functions follow a format of `scale_aesthetic_xyz()`, where `aesthetic` is color, size, and so on. You can control color using color palettes with `scale_color_brewer()`. If you want to specify colors manually, use `scale_color_manual()` with the `values =` argument. 

```{r, warning = FALSE}
# manual specification of color: scale_color_manual()
# one color for each category from the aesthetic mapping
# this will fail if you don't supply the correct number of colors

ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, shape = 1, alpha = 0.3, size = 0.25,) +
  geom_smooth(method = "lm",
              aes(color = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon"))
```

Here we also map the confidence interval's fill color and the linetype of the smooth using gender.

```{r, warning = FALSE}
# modifying more mappings
# such as fill color, linetype
# (Again, pardon the ugliness of the graphic 
#  as we demonstrate general ggplot functionality)


ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid"))
```


Because `x` and `y` are also aesthetics, we can also modify them using `scale` functions.

```{r, warning = FALSE}
# axes are aesthetics, so you also modify axes with scale functions
#   breaks are where ticks are drawn
#   `labels =` can be used to specify the label for each break
#   minor_breaks can be specified separately from breaks

ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7)
```

I can also add text labels to the tick positions.

```{r, warning = FALSE}
# Specify axis labels for each break
# The `\n` character inserts a line break.

ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7, 
                     labels = c("Strong\nDem", "Weak\nDem", 
                                "Lean\nDem", "Independent", "Lean\nRep", 
                                "Weak\nRep", "Strong\nRep"))
```



## Labeling aesthetics

Related to aesthetics and scales is the labels we give these aesthetics. Notice that when we map variables to `x` and `y`, axis titles are created, and as we map variables to color, fill, and so on, a legend title was created. The variable names that get printed can be modified with the `labs()` function.

```{r, warning = FALSE}
# Specify aesthetic labels using labs()
# good for axes, legend titles, also plot title (title = ), etc.

ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7, 
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Independent", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  labs(x = "Party ID Index", y = "Relative Candidate Thermometer Score",
       color = "Gender")
```

The `labs()` function only changes the names that you specify. To fix this dirty legend, I should specify the name for color, fill, and linetype all as `"Gender"`.

```{r, warning = FALSE}
# specify all labels
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7, 
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Independent", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  labs(x = "Party ID Index", y = "Relative Candidate Thermometer Score",
       color = "Gender", fill = "Gender", linetype = "Gender")
```

I could also remove labels by specifying them as `NULL`. In this case, we're pretty sure what men and women signify, so maybe including the "Gender" label is redundant. So we can suppress the legend title.

```{r, warning = FALSE}
# removing labels using NULL
ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7, 
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Independent", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  labs(x = "Party ID Index", y = "Relative Candidate Thermometer Score",
       color = NULL, fill = NULL, linetype = NULL)
```

`NULL` isn't the same as `NA`. We use `NA` for missing data---there should be data here, but we don't know what it is. We use `NULL` to mean "nothing." 


# Coordinates

Coordinates are not very complicated. Most of the time you will use a Cartesian grid, so you'll probably do one of two things. 

- Set the axis limits
- Flip the $x$ and $y$ dimensions.

First, set the axis limits. This is an unrealistic application just to demonstrate the functionality.

```{r, warning = FALSE}
# set axis limits using the coordinate system
# coord_cartesian(xlim = , ylim =)

ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7, 
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Independent", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  labs(x = "Party ID Index", y = "Relative Candidate Thermometer Score",
       color = NULL, fill = NULL, linetype = NULL) +
  coord_cartesian(xlim = c(0, 8), ylim = c(-125, 125))
```

Remember, because the underlying values in the `x` aesthetic are 1 to 7, setting the `xlim` to 0 through 8 will pad each side by one unit. We use the `c()` function to pass a two-element vector of limits (minimum and maximum).

Second is flipping `x` and `y`, which is handy for dot plots and coefficient plots (which we'll see next week). This is going to look strange in this example, of course, but again we're just demonstrating the functionality.

```{r, warning = FALSE}
# invert the coordinate system with coord_flip()
# can specify changes to the coordinate limits when you do this as well

ggplot(data = anes, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7, 
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Independent", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  labs(x = "Party ID Index", y = "Relative Candidate Thermometer Score",
       color = NULL, fill = NULL, linetype = NULL) +
  coord_flip(xlim = c(0.5, 7.5))
```

As above with jittering and smoothing, the `x` and `y` aesthetics themselves have not changed, only the way they are *displayed* in the graphic. The `scale_x_continuous()` function, therefore, still modifies the party ID variable scale even though it's now the vertical axis. That's because `scale_x_continuous()` modifies the *x aesthetic*, not the *horizontal axis* per se. This same intuition works when we specify `xlim` inside the `coord_flip()` function.


# Faceting

Faceting is relatively simple. We use it to plot subsets of the data in different panels. There are two ways to do this.

- `facet_wrap()` creates horizontal panels that will "wrap" to the next line if we run out of space.
- `facet_grid()` creates a grid according to variables that you specify as the rows and columns.

Both of these functions require us to use tildes `~`, so pay attention. 

First: `facet_wrap` using the election cycle variable (on a subset of presidential year data)

```{r, warning = FALSE}
# save only recent presidential years
prez <- anes %>%
  filter(cycle %% 4 == 0) %>%
  filter(cycle >= 1992) 

# wrap panels using facet_wrap( ~ cycle)
# the tilde is necessary

ggplot(prez, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7) +
  labs(x = "Party ID Index", 
       y = "Relative Candidate Thermometer Score",
       color = NULL, fill = NULL, linetype = NULL) +
  facet_wrap(~ cycle)
```



Next: `facet_grid()`, which requires us to specify row and column variables. We'll use election cycle and gender. This will make the legend redundant, but just ignore that for now.


```{r, warning = FALSE}
ggplot(prez, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7) +
  labs(x = "Party ID Index", 
       y = "Relative Candidate Thermometer Score",
       color = NULL, fill = NULL, linetype = NULL) +
  facet_grid(cycle ~ gender)
```


Use a period in the `facet_grid` function to suppress rows or columns. Observe:

```{r, warning = FALSE}
# suppress rows

ggplot(prez, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7) +
  labs(x = "Party ID Index", 
       y = "Relative Candidate Thermometer Score",
       color = NULL, fill = NULL, linetype = NULL) +
  facet_grid(. ~ gender)

# suppress columns

ggplot(prez, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7) +
  labs(x = "Party ID Index", 
       y = "Relative Candidate Thermometer Score",
       color = NULL, fill = NULL, linetype = NULL) +
  facet_grid(gender ~ .)
```



# Themes

Themes control ancillary aesthetic components of the plot. There are several preloaded themes that you can learn about [here](http://ggplot2.tidyverse.org/reference/ggtheme.html), and you can learn about [other ggplot theme packages online](https://cran.r-project.org/web/packages/ggthemes/vignettes/ggthemes.html).

We'll use `theme_bw()`, in case you (like me) think this gray background is kinda nasty.

```{r, warning = FALSE}
# theme_bw()

ggplot(prez, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7) +
  labs(x = "Party ID Index", 
       y = "Relative Candidate Thermometer Score",
       color = NULL, fill = NULL, linetype = NULL) +
  facet_wrap(~ cycle) +
  theme_bw()
```

There is also a `theme()` function, which allows you to change individual details of the theme without changing the entire theme. Here we will suppress the "minor" grid lines.

```{r, warning = FALSE}
ggplot(prez, aes(x = pid7, y = reltherm_cand)) +
  geom_jitter(width = 0.2, 
              shape = 1, alpha = 0.3, size = 0.25, 
              color = "slategray") +
  geom_smooth(method = "lm",
              aes(color = gender, linetype = gender, fill = gender)) +
  scale_color_manual(values = c("dodgerblue", "maroon")) + 
  scale_fill_manual(values = c("dodgerblue", "maroon")) +
  scale_linetype_manual(values = c("dotted", "solid")) +
  scale_x_continuous(breaks = 1:7) +
  labs(x = "Party ID Index", 
       y = "Relative Candidate Thermometer Score",
       color = NULL, fill = NULL, linetype = NULL) +
  facet_wrap(~ cycle) +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```



# Finishing touches and saving a graphic


This looks like an okay graphic now, and it didn't take much code at all!

Saving this graphic is easy with the `ggsave` function. You generally want to save graphic as a "vector" image type in order to scale (that is, increase the size of) a graphic without any pixelation. PDF is usually good for papers and presentations.

```{r, eval = FALSE}
# generally want to save it into your paper's dedicated folder
#   then inside the graphics subfolder

# set height and width (usually requires some trial and error)
ggsave("paper/graphics/my-plot.PDF", width = 7, height = 3)
```


# Another example: party ID of men and women over time


Let's take these tools for a spin. Let's re-create this graphic from an old paper from a former professor of mine.

<center>
  <br>
  <img src="img/kp-fig-1.png"  alt="kaufmann-petrocik-figure-1" style="width: 100%">
</center>
<br>

We will need to set up a dataset that has all of the required components. Let's think of what we need to have in place. 

- `x` is election cycle, `y` is the percentage of men and women identifying as Democrat and Republican (aesthetics). We will need to calculate the `y` variable.
- We have separate point styles based on party (aesthetic)
- We have separate panels for men and women (faceting)
- the `x` axis scale has been modified, and `y` axis scale probably needs to be coerced to go from 0 to 100 (scales)

Let's add some extra flair: 

- calculate confidence intervals for each trend and plot as a "ribbon," which is a shaded region.
- Unlike before, let's make this as pretty as we can.

## Data cleaning

First, we have to create the data. 

To get the confidence intervals, we'll use a user-defined confidence interval function that can handle survey weights. We'll discuss custom functions in the final lesson; for now, just know that this function calculates confidence intervals for proportions based on the number of "successes" and the number of observations. (Side note: you don't need to calculate your own confidence intervals most of the time---this is a special case because survey weights create non-whole-numbers of successes and observations.)

```{r}
# Confidence intervals for proportions
# based on the normal approximation to the binomial

prop_ci <- function(successes, n, level = 0.05) {

  # get pt estimates and standard error
  p <- successes / n
  q <- 1 - p
  SE <- sqrt( (p * q) / n )

  # upper and lower bound
  lower <- p - qnorm(1 - (level / 2) ) * SE
  upper <- p + qnorm(0.975) * SE

  # return data frame
  return(data.frame(estimate = p, lower, upper))

}
```

To get the DV, we'll need the weight variable and to collapse the party ID variable. (We want to keep Independents to calculate proportions, but we'll drop them before plotting.)

```{r}
# copy weight variable and
# collapse the party variable into Dems and Reps
#   code "leaners" as partisans
anes <- anes %>% 
  mutate(wt = VCF0009z,
         party = case_when(pid7 %in% 1:3 ~ "Dem", 
                           pid7 == 4 ~ "Ind", 
                           pid7 %in% 5:7 ~ "Rep"))
```


We will need to find the proportion of men and women in each party ID category, in each cycle. We'll do this with a pipe chain:

- find the number of men and women in each party ID category in each cycle
- get proportions by dividing by the total number of men and women in each cycle
- use the number of successes and the "denominator" from above to find upper and lower bounds on the confidence interval
- trim extraneous stuff from the data


```{r}
# You may want to run this chain line by line 
# to see what each step does
# we want to plot Women left of Men, so we'll reorder the gender variable

pid_gendergap <- anes %>%
  select(cycle, gender, party, wt) %>%  # trim unnecessary stuff
  group_by(gender, cycle, party) %>%    # calc weighted n in each PID
  count(wt = wt) %>%
  rename(x = n) %>%                     # less ambiguous name
  group_by(gender, cycle) %>%           # "denominator" for gender x cycle
  mutate(n = sum(x)) %>% 
  ungroup() %>%
  # proportions and CIs
  mutate(prop = prop_ci(successes = x, n = n)$estimate,
         lower = prop_ci(successes = x, n = n)$lower,
         upper = prop_ci(successes = x, n = n)$upper) %>%
  # keep only Ds and Rs (drop NA and Ind) 
  # keep only presidential years since 1952 reorder variables
  filter(party %in% c("Dem", "Rep")) %>%     
  filter( (cycle >= 1952) & ((cycle %% 4) == 0) ) %>% 
  select(cycle, gender, party, prop:upper) %>% 
  # reorder gender as a factor
  mutate(gender = fct_relevel(as.factor(gender), "Women", "Men")) %>% 
  print()
```

Now we'll use this dataset to build the plot.

We know we need separate panels for men and women, separate trends and linetypes for party. 


```{r, warning = FALSE}
# use `group =` to plot separate line trends
# try removing `group =` from the plot to see why we include it

ggplot(pid_gendergap, aes(x = cycle, y = prop)) +
  facet_grid(. ~ gender) +
  geom_line(aes(group = party)) +
  geom_point(aes(shape = party))
```

Let's modify some scales. We'll want to specify the point styles and change the axis scales.

- by default, fill any empty point with while fill (in `grom_point()`)
- set the coordinates a little wider (`coord_cartesian()`)
- manually specify point shapes (`scale_shape_manual()`)
- modify the ticks on x and y (`scale_x_continuous()`)

```{r, warning = FALSE}
ggplot(pid_gendergap, aes(x = cycle, y = prop)) +
  facet_grid(. ~ gender) +
  geom_line(aes(group = party)) +
  geom_point(aes(shape = party), fill = "white") +
  coord_cartesian(ylim = c(0, 1), xlim = c(1948, 2014),
                  expand = FALSE) +
  scale_shape_manual(values = c(17, 22)) +
  scale_y_continuous(breaks = seq(0, 1, .1)) +
  scale_x_continuous(breaks = seq(1952, 2012, 12))
```

The X axis looks funky now. Let's do some theme modifications to make the text diagonal and suppress busy grid lines. 

```{r, warning = FALSE}
ggplot(pid_gendergap, aes(x = cycle, y = prop)) +
  facet_grid(. ~ gender) +
  geom_line(aes(group = party)) +
  geom_point(aes(shape = party), fill = "white") +
  coord_cartesian(ylim = c(0, 1), xlim = c(1948, 2016),
                  expand = FALSE) +
  scale_shape_manual(values = c(17, 22)) +
  scale_y_continuous(breaks = seq(0, 1, .1)) +
  scale_x_continuous(breaks = seq(1952, 2012, 12)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.8),
        panel.grid.minor = element_blank())
```

Let's suppress the legend created by `geom_point()` and add text labels.

```{r, warning = FALSE}
ggplot(pid_gendergap, aes(x = cycle, y = prop)) +
  facet_grid(. ~ gender) +
  geom_line(aes(group = party)) +
  geom_point(aes(shape = party), fill = "white",
             show.legend = FALSE) +
  coord_cartesian(ylim = c(0, 1), xlim = c(1948, 2016), 
                  expand = FALSE) +
  scale_shape_manual(values = c(17, 22)) +
  scale_y_continuous(breaks = seq(0, 1, .1)) +
  scale_x_continuous(breaks = seq(1952, 2012, 12)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.8),
        panel.grid.minor = element_blank()) +
  annotate("text", x = 1984, y = 0.65, label = "Democrats") +
  annotate("text", x = 1984, y = 0.25, label = "Republicans")
```



If we want to add confidence intervals as ribbons, we'll use `geom_ribbon()`. It inherits the `x` aesthetic from the plot, but we need to specify extra `ymin` and `ymax` aesthetics to draw the upper and lower bounds of the "polygon" that gets drawn. Again, suppress the legend, and for good measure, let's modify the fill color.

```{r, warning = FALSE}
# I always prefer to add ribbons below points and lines
# we want to reduce the ribbon opacity
ggplot(pid_gendergap, aes(x = cycle, y = prop)) +
  facet_grid(. ~ gender) +
  geom_ribbon(aes(ymin = lower, ymax = upper,
                  fill = party), 
              alpha = 0.4, show.legend = FALSE) +
  geom_line(aes(group = party)) +
  geom_point(aes(shape = party), fill = "white", 
             show.legend = FALSE) +
  coord_cartesian(ylim = c(0, 1), xlim = c(1948, 2016), 
                  expand = FALSE) +
  scale_shape_manual(values = c(17, 22)) +
  scale_y_continuous(breaks = seq(0, 1, .1)) +
  scale_x_continuous(breaks = seq(1952, 2012, 12)) +
  scale_fill_manual(values = c("dodgerblue", "orangered")) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.8),
        panel.grid.minor = element_blank()) +
  annotate("text", x = 1984, y = 0.65, label = "Democrats") +
  annotate("text", x = 1984, y = 0.25, label = "Republicans")
```


We'll want to convert the axis to percentages. We can do this in the plot using the `scale_y_continuous()` function and applying a function to the labels. 


```{r, warning = FALSE}
# check the labels = argument in scale_y_continuous
# it uses the percent() function from the 'scales' package
#   scales is automatically installed with ggplot2

ggplot(pid_gendergap, aes(x = cycle, y = prop)) +
  facet_grid(. ~ gender) +
  geom_ribbon(aes(ymin = lower, ymax = upper,
                  fill = party), 
              alpha = 0.4, show.legend = FALSE) +
  geom_line(aes(group = party)) +
  geom_point(aes(shape = party), fill = "white", 
             show.legend = FALSE) +
  coord_cartesian(ylim = c(0, 1), xlim = c(1948, 2016), 
                  expand = FALSE) +
  scale_shape_manual(values = c(17, 22)) +
  scale_y_continuous(breaks = seq(0, 1, .1), 
                     labels = scales::percent) +
  scale_x_continuous(breaks = seq(1952, 2012, 12)) +
  scale_fill_manual(values = c("dodgerblue", "orangered")) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.8),
        panel.grid.minor = element_blank()) +
  annotate("text", x = 1984, y = 0.65, label = "Democrats") +
  annotate("text", x = 1984, y = 0.25, label = "Republicans")
```


Now we'll need to change the labels so they fit the scale transformation.

```{r, warning = FALSE}
ggplot(pid_gendergap, aes(x = cycle, y = prop)) +
  facet_grid(. ~ gender) +
  geom_ribbon(aes(ymin = lower, ymax = upper,
                  fill = party), 
              alpha = 0.4, show.legend = FALSE) +
  geom_line(aes(group = party)) +
  geom_point(aes(shape = party), fill = "white", 
             show.legend = FALSE) +
  coord_cartesian(ylim = c(0, 1), xlim = c(1948, 2016), 
                  expand = FALSE) +
  scale_shape_manual(values = c(17, 22)) +
  scale_y_continuous(breaks = seq(0, 1, .1), 
                     labels = scales::percent) +
  scale_x_continuous(breaks = seq(1952, 2012, 12)) +
  scale_fill_manual(values = c("dodgerblue", "orangered")) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.8),
        panel.grid.minor = element_blank()) +
  annotate("text", x = 1984, y = 0.65, label = "Democrats") +
  annotate("text", x = 1984, y = 0.25, label = "Republicans") +
  labs(x = NULL, y = "Percent (including leaners)",
       title = "Party Identification of Men and Women",
       caption = "Source: NES Surveys of the indicated years")
```





# Other graphics

There are plenty of other geoms that use slightly different aesthetics. Let's just breeze through some now.

As we do this, let's use `theme_bw()` as the default. Here's a trick to set the default ggplot theme.

```{r}
theme_set(theme_bw())
```


## Histograms and density plots

Histograms and density plots, because they only show the distribution of one variable, only need one axis aesthetic (`x`).

```{r}
# subset the anes data
# pipe into the ggplot function 
#   (can do that! but not usually recommended)

anes %>%
  filter(!is.na(party)) %>% 
  ggplot(aes(x = reltherm_cand)) +
    geom_histogram(aes(color = party)) +
    labs(x = "Relative Candidate Thermometer Score",
         y = "Frequency",
         color = "Partisanship")
```

Histogram bars are stacked by default, which is weird. Let's make them dodge each other.

```{r}
# make histogram bars non-stacked ("dodge")

anes %>%
  filter(!is.na(party)) %>% 
  ggplot(aes(x = reltherm_cand)) +
    geom_histogram(aes(color = party,
                       fill = party),
                   alpha = 0.5,
                   position = "dodge") +
    scale_color_manual(values = c("dodgerblue", "gray20", "maroon")) +
    scale_fill_manual(values = c("dodgerblue", "gray20", "maroon")) +
    labs(x = "Relative Candidate Thermometer Score",
         y = "Frequency",
         color = "Partisanship",
         fill = "Partisanship")
```

You can also do kernel density estimates (which allow you set the kernel bandwidth):

```{r}
# density plot instead of histogram

anes %>%
  filter(!is.na(party)) %>% 
  ggplot(aes(x = reltherm_cand)) +
    geom_density(aes(color = party, fill = party),
                   alpha = 0.5,
                   bw = 7) +
    scale_color_manual(values = c("dodgerblue", "gray20", "maroon")) +
    scale_fill_manual(values = c("dodgerblue", "gray20", "maroon")) +
    labs(x = "Relative Candidate Thermometer Score",
         y = "Density",
         color = "Partisanship",
         fill = "Partisanship")
```



## Bar graphs

It's a personal preference of mine that I think just about anything that you can show with a bar graph would be better with a dot plot. I tend to think that bar graphs are awkward and misused (e.g. for experimental treatment effects). In my head, bars should be for counts or other things where zero is a hard lower bound (such as proportions). 

Bah! Anyway, here's how you do them.

Let's make some data of the Democratic share of the two-party vote choice for each partisanship category.

```{r}
# dummy variable for Dem vote (0 = Rep vote, else NA)
anes <- anes %>%
  mutate(vote = VCF0706,
         vote = case_when(vote == 1 ~ "Democratic Candidate",
                          vote == 2 ~ "Republican Candidate"))

# calculate averages for each party ID
# presidential years since 2000
mean_votes <- anes %>%
  filter(cycle >= 2000 & (cycle %% 4) == 0) %>%
  filter(!is.na(pid7)) %>% 
  group_by(cycle, pid7, vote) %>%  # Numerator
  count(wt = wt) %>%
  filter(!is.na(vote)) %>%
  rename(x = n) %>%
  group_by(pid7, cycle) %>%     # Denominator
  mutate(n = sum(x, na.rm = TRUE),
         prop = x / n) %>%
  filter(vote == "Democratic Candidate") %>% 
  print()
```

And then plot these averages.

```{r}
# geom_col to create a column as tall as the (x, y) point
ggplot(mean_votes, aes(x = pid7, y = prop)) +
  geom_col(fill = "gray50") +
  facet_wrap(~ cycle) +
  scale_x_continuous(breaks = 1:7,
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Ind", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  labs(x = "Party ID",
       y = "Democratic Share of Two-Party Vote") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```

Here is the same plot as a dot plot, also changing the scales.

```{r}
# dots instead of bars
ggplot(mean_votes, aes(x = pid7, y = prop)) +
  geom_point() +
  facet_wrap(~ cycle) +
  scale_x_continuous(breaks = 1:7,
                     labels = c("Strong\nDem", "Weak\nDem", "Lean\nDem", "Ind", "Lean\nRep", "Weak\nRep", "Strong\nRep")) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Party ID",
       y = "Democratic Share of Two-Party Vote") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```


And you can often rotate dot plots so that their labels have more space to print out.

```{r}
# rotate the dot plot for axis readability
# this should be used carefully...
# not all plots are easy to read like this
ggplot(mean_votes, aes(x = pid7, y = prop)) +
  geom_point() +
  facet_wrap(~ cycle) +
  scale_x_continuous(breaks = 1:7,
                     labels = c("Strong Democrat", "Weak Democrat", "Lean Democrat", "Independent", "Lean Republican", "Weak Republican", "Strong Republican")) +
  scale_y_continuous(breaks = seq(0, 1, .2),
                     labels = scales::percent) +
  labs(x = "Party Identification",
       y = "Democratic Share of Two-Party Vote") +
  theme_bw() +
  theme(panel.grid.minor = element_blank()) +
  coord_flip()
```

There are some other things you can do with geoms. One thing you can do for dot plots is use `geom_pointrange`, which adds a point and an error bar. Like `geom_ribbon`, it takes a `ymin` and `ymax` aesthetic. This makes it good for point estimates and confidence intervals. In this case though, we'll use it in a slightly hacky way to help us trace which point goes with which category, making it a little easier to read the plot. Notice how I set the min and max aesthetics.

```{r}
# set ymin = 0, ymax = prop. 
# the error bar goes from 0 to the point
ggplot(mean_votes, aes(x = pid7, y = prop)) +
  geom_pointrange(aes(ymin = 0, ymax = prop),
                  linetype = "dotted") +
  facet_wrap(~ cycle) +
  scale_x_continuous(breaks = 1:7,
                     labels = c("Strong Democrat", "Weak Democrat", "Lean Democrat", "Independent", "Lean Republican", "Weak Republican", "Strong Republican")) +
  scale_y_continuous(breaks = seq(0, 1, .2),
                     labels = scales::percent) +
  labs(x = "Party Identification",
       y = "Democratic Share of Two-Party Vote") +
  theme_bw() +
  theme(panel.grid.minor = element_blank()) +
  coord_flip()
```

--- 




# Categorical variables (strings and factors)

If you plot a categorical variable on one of the axes, `ggplot` will automatically interpret it and plot categories side-by-side. We'll demonstrate this with a toy example.

One potential problem, though, is that `ggplot` will order categorical variables alphabetically or, if the variable is already an ordered factor, will interpret the factor order out of the metadata about the levels.

Here we show what happens when we plot a string variable that can be ordered alphabetically:

```{r}
# x and y: continuous variables
# s: string variable
# f: factor variable with weird order
d <- data_frame(x = rnorm(100, 0, 1),
                y = 4 + (2 * x) + rnorm(100, 0, 1),
                s = sample(c("a", "b", "c", "d"), 100, replace = TRUE),
                f = factor(s, levels = c("c", "d", "a", "b")))

# plot y as a function of s (jittering the points)
ggplot(d, aes(x = s, y = y)) +
  geom_jitter(width = 0.15) +
  labs(x = "String", y = "Continuous Y") 
```

...and if we plot from a factor that already has ordered levels...

```{r}
# plot y as f(f), jittered points
# notice weird order. This comes from the underlying data
ggplot(d, aes(x = f, y = y)) +
  geom_jitter(width = 0.15) +
  labs(x = "Ordered Factor", y = "Continuous Y") 
```


...or we wanted to assign colors using an ordered factor.

```{r}
# same situation here
ggplot(d, aes(x = x, y = y)) +
  geom_point(aes(color = f)) +
  labs(x = "Continuous X", 
       y = "Continuous Y",
       color = "Ordered Factor") 
```

To reorder these categories, I recommend using tools in the `forcats` package, which, conveniently, is part of `tidyverse`.

- `fct_relevel()`: take a factor variable and reorder the levels. Any level not listed during reordering is given the same precedence as the original variable
- `fct_rev()`: reverse the order of a factor's levels
- `fct_recode()`: change the levels (text labels) of a factor

Here is an example where we take the `f` variable, a factor with ordered levels, and rearrange the order of the levels so that they appear in the legend with the proper order. This is called "releveling" (changing the order of levels), as opposed to "recoding" (changing the labels themselves).

```{r}
# start with the d object
# mutate
# create fixed_f, which is f but with levels of specified order
fixed_d <- d %>%
  mutate(fixed_f = fct_relevel(f, "a", "b", "c", "d")) %>%
  print()
```

You'll note that the variables `f` and `fixed_f` now have the same values, but the ordering of `fixed_f`'s levels has been modified.

```{r}
# f as color
ggplot(fixed_d, aes(x = x, y = y)) +
  geom_point(shape = 1,
             aes(color = fixed_f)) +
  labs(x = "Continuous X", 
       y = "Continuous Y",
       color = "Ordered Factor") 

# f as x axis
ggplot(fixed_d, aes(x = f, y = y)) +
  geom_point(shape = 1) +
  labs(x = "Ordered Factor", y = "Continuous Y") 
```


## An aside on `stringr`

The `stringr` package contains a few useful functions for modifying character vectors.

Let's take the `state.name` vector that comes with R.

```{r}
state.name
```

Here are some useful functions. Play with these on your own.

```{r, eval = FALSE}
# look for pattern, return a logical vector
str_detect(state.name, " ") #  spaces

# example: return all two-word state names
state.name[str_detect(state.name, " ")]

# substring based on character position
str_sub(state.name, 1L, 3L)
str_sub(state.name, -3L, -1L)

# cut a string based on a pattern match (returns a list)
str_split(state.name, pattern = " ")

# grab the nth element of a split string list
# in this case, the second element (x[2])
sapply(str_split(state.name, pattern = " ") , function(x) x[2])

# replace a pattern with another pattern
str_replace(state.name, pattern = " ", replacement = "-")

# for strings that might contain multiple instances of the pattern
# (won't notice a difference here)
str_replace_all(state.name, pattern = " ", replacement = "-")
```



# Concluding notes

## Why plot

You should be plotting your data often, even if you don't expect the plot to make it into your final product. 

- Plotting shows you the distribution of your data, which can help you decide on certain modeling assumptions or variable transformations. (You should not rely entirely on plots for this...let theory guide you)
- Plotting shows outliers, which may help you think about unmodeled covariates.
- Plotting gives you a sense of the underlying trends in your data so you can be a better thinker about the problem at hand. 

You can see Hadley Wickham do some exploratory analysis [here](https://www.youtube.com/watch?v=go5Au01Jrvs), which shows how graphics (and `ggplot` in particular) facilitates principled and *fast* exploration of your data. 



## Data and `ggplot`

If you haven't already picked up on it, `ggplot` is designed to complement the philosophy of tidy data. It does this mainly by forcing you to declare a data frame from which you are plotting. This helps ensure that the data you are plotting are conceptually related and can be easily mapped to plot aesthetics. And in order to shape your data so that these mappings are done correctly, the tools in `tidyr` and `dplyr` are extremely helpful.

As we have seen, many tools in `ggplot` are designed to prevent you from modifying the underlying data too much. This is generally a tenet of the Tidyverse philosophy. Your original data frames are sacrosanct, and they serve as the raw material from which analyses and plots are extracted. This is why pipe chains begin with a tidy dataset and work out from there. Changes that you make to the data that *only* exist for the purpose of plotting (or modeling, etc.) should be temporary, as they are not essential to the core underlying data.

Say that you have raw data that has an ugly text label, and every time you plot that variable, you want a prettier text label. Rather than change the underlying data, you might make another table that serves as a dictionary for converting the ugly label to a prettier label. You can then merge this table into your data just before plotting. Practices such as this keep your original data free of extraneous stuff while still allowing you to produce beautiful graphics.

## Graphics approaches, base vs `ggplot`

Base graphics, on the other hand, do not rely on an underlying data model in order to work. You can plot points, lines, labels, and so on, with no conceptual connection between the data used for any of these geoms. Furthermore, legends and labels are entirely detached from the data. This makes base graphics inefficient and prone to human error in a number of ways, mainly because updates to the elements of your graphics need to made separately from updates to legends, labels, axes and so on. These elements are all conceptually independent in base graphics, so they have no knowledge about how you change the data or the appearance of the graphics. That said, it is definitely possible to create beautiful graphics using base tools; it will just take more work and more time.

All this being said, base graphics do have some advantage on `ggplot` graphics if you have to create a plot that contains many unrelated elements that don't share a common data frame. (It is possible to plot from multiple data frames in `ggplot`, but it isn't easy.) 

You can find plenty of disagreements online about how and when base or `ggplot` tools are better. I know no human being who has learned ggplot and opted for base graphics, so I'm making the bet that this lesson will lead you to the same conclusion.


## Other graphical Dos and Don'ts

Some general advice for plotting:

- Don't use multiple Y axes. It's easy to use multiple Y axis scales to make variables look more or less related ([see here](https://kieranhealy.org/blog/archives/2016/01/16/two-y-axes/)), so you shouldn't do it. In fact, for the longest time, `ggplot` would not allow you to create a second y-axis (because it's opinionated like that).
- If you can label points or trends *in the plot* rather than in a legend, do so. You can do this with `geom_text` or the `annotate()` function.
- Try to make your graphics as minimal as possible. Add elements where it improves the graphic. Otherwise, you don't want to create clutter.
- If you can use aesthetic features *besides* color to distinguish groups, that would be ideal. Some forms of color-blindness are remarkably common, and at any rate, journals may not allow your article to print in color. It's best to get mentally prepared to use more line types, point styles, and so on, to distinguish groups of data.
- If you must use colors, you should check out some colorblindness-friendly color palettes and packages. You could check out the `dichromat` package to investigate how your color selections look to individuals with various forms of colorblindness. The `viridis` package also provides a variety of scales for colorblind-friendly graphics. 


## Other `gg` tools

There are many extensions for `ggplot` that you can install. Rather than tediously describe them, I'll point you to a [web page](http://www.ggplot2-exts.org/gallery/?utm_content=buffer6d153&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer) discussing many of the tools out there. These let you create heatmaps, choropleths, network graphs, mosaic plots, autocorrelation plots, and much more. Extensions I have used in the past include `ggfortify`, `ggridges`, `ggthemes`, `ggsci`, `GGally`, and `ggalt`.

Many more extensions are in development and cannot be found on CRAN, but they can be downloaded and installed. One that I particularly like is [`patchwork`](https://github.com/thomasp85/patchwork), which combines multiple graphics into the same image using an extremely simple syntax.


## Graphics in future lessons

We will further explore graphics using `ggplot` in the final lesson on statistical analysis. In particular, we'll discuss how to use `ggplot` tools to summarize statistical models and create post-estimation graphics.


# Save data from this session

```{r, eval = FALSE}
saveRDS(anes, "data/anes-modified-2.RDS")
```

```{r, include = FALSE}
saveRDS(anes, here::here("static/data/anes-modified-2.RDS"))
```
