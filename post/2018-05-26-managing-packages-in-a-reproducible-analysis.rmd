---
title: "Packages & Reproducibility: Install what you need, load what you want"
author: Mike DeCrescenzo
description: "A comment on conditionally installing, loading, and not loading packages for reproducible R scripts"
date: '2018-05-30'
slug: reproducible-packages
categories: ["R", "Reproducibility"]
tags: []
comments: no
showcomments: yes
showpagemeta: yes
draft: false
---

When we distribute R code (for publication/replication archives, on Github, through blog posts, etc), we like the code to run smoothly on someone else's machine. Packages present a nominal problem because different users have different packages installed on their computer. Ideally the script we are distributing should install dependencies without the redundancy of re-installing packages that a user already has installed. To this end, many users conditionally install packages using `require()`; if a package fails to load, it is installed. Supposing that we want to load a package called `pkg`...

```{r, include = FALSE}
# future chunks are not evaluated
knitr::opts_chunk$set(eval = FALSE, collapse = TRUE)
```

```{r}
# if require() succeeds, package is loaded
# if require() fails, package is installed
if (require("pkg") == FALSE) {
  install.packages("pkg")
}
```

We see often see this in (for example) package ReadMe files on Github. But for distributing bigger projects, the approach has two shortcomings.

1. Sometimes we require a package, but we don't want to load it. We may only need it for a function or two, or we want to prevent [clashing function names](https://github.com/r-lib/conflicted) in projects where many packages are loaded, and so we prefer to use the `pkg::function()` grammar instead of loading the package with `require()`.
2. If we want to require several packages for a large project (like a replication archive for a published journal article), including code to install all packages ends up unsightly and repetitive (but functional, to be fair).

Here's a straightforward way around this. 


## Check for installed packages without loading them

Rather than use `require()`, which has the side-effect of loading an installed package, we can look for installed packages using the output from `installed.packages()`. In particular, the function should return an array whose rownames contain the names of our installed packages. 

```{r, eval = TRUE}
head(rownames(installed.packages()))
```

Using these rownames, we can check for installed packages without loading those packages incidentally. Just create a character vector of required packages and cross-reference those names with the list of installed packages.

```{r, eval = TRUE}
c("ggplot2", "beepr", "some_other_package") %in% rownames(installed.packages())
```


## Install what we need, load what we want

The structure laid out above can be augmented to install missing packages. Just use a little bit of indexing:

```{r}
# vector of requirements 
requires <- c("pkg_1", "pkg_2")

# evaluates to TRUE if not already installed
to_install <- (requires %in% rownames(installed.packages()) == FALSE)

# install missing packages
cloud_url <- "https://cloud.r-project.org/"
install.packages(requires[to_install], repos = cloud_url)
```

Because we never call `require()`, we can load (or not load) whichever packages we want with subsequent `library()` commands.


# Optional: one function to do it all

We could implement this entire system (installing and loading select packages) with one function that takes two main arguments:

- a vector of required package names
- a vector of package names for which packages to load (or not load)

Before going on, it's fair to note that there are two valid reasons why we might *not* want to do this:

1. We may find it valuable to include separate calls to `library()` for each loaded package. This could be to keep the project layout simple and/or for our own mental organization. I think it's okay to embrace redundancy if we value the explicitness.
2. We may not want to manage yet another custom function to paste around from project to project. Fair.

But supposing that we *did* want one function that could do it all, it might look something like this. 


```{r, eval = TRUE}
pkg_check <- 
  function(packages = character(), load = packages, verbose = FALSE) {
  
    # 1. check which packages are installed
    installed <- packages %in% rownames(installed.packages())
    to_install <- packages[installed == FALSE]

    # 2. install only those not installed
    if (length(to_install) > 0) {
      install.packages(to_install, repos = "https://cloud.r-project.org/")
    }

    # 3. load only specified packages (defaults to all required)
    lapply(packages, function(x) { 
      if (x %in% load) library(x, character.only = TRUE) } 
      )      
    
    # 4. optional verbose output
    if (verbose == TRUE) {
      return(list(`Packages` = data.frame(Names = packages, 
                                          `Already Installed` = installed),
                  `Newly Installed` = to_install,
                  `Loaded` = load,
                  `Not Loaded` = packages[!(packages %in% load)]))  
    }
}
```

We can test this function using some packages that I needed for a recent project.

```{r, eval = TRUE, warning = FALSE, message = FALSE}
pkg_check(c("here", "magrittr", "tidyverse", "ggplot2", 
            "readxl", "R.utils", "haven", "labelled", 
            "gtools", "beepr", "readr", "gghighlight"), 
          load = c("here", "magrittr", "tidyverse", "ggplot2"), 
          verbose = TRUE)
```



# Coda: on the use of `library()` vs `require()`

Thinking back to this [oft-cited post by Yihui Xi](https://yihui.name/en/2014/07/library-vs-require/), the takeaway was that we should only be using `require()` to...

1. conditionally install packages, or 
2. implement "bonus-features" that may enhance a package or function but that aren't strictly necessary

In reference to [1], I think this post demonstrates that we can (and should) flatly avoid `require()` in any situation where we need a package but don't want to load it. For me, this is basically all of my research projects, and I think many other users will find themselves in a similar boat. As long as `require` loads a package in the process of checking for it, `require` gives unintended and unnecessary side-effects.

In reference to [2], it's a little funny that we got to a point where we would only use a function called `require` for features that are *necessarily* not required. It's quite the contradiction (and maybe the function ought to be called something squishier like `supposing()` in a parallel universe). At any rate, the *functional benefit* of using `require` in this case---it returns logical output---isn't necessary either, since `library()` has a `logical.return` argument that achieves the same objective (sidestep an error by returning `FALSE` if a package fails to load).



# Thanks for reading

Feel free to [get in touch](https://www.twitter.com/mikedecr) with comments, links to similar or related posts by others, packages that implement similar features, and so on. 




